/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.CS = (function() {
    
        /**
         * Namespace CS.
         * @exports CS
         * @namespace
         */
        var CS = {};
    
        CS.PROTO = (function() {
    
            /**
             * Namespace PROTO.
             * @memberof CS
             * @namespace
             */
            var PROTO = {};
    
            /**
             * ConnectionDescription_call enum.
             * @name CS.PROTO.ConnectionDescription_call
             * @enum {number}
             * @property {number} Unknown_ConnectionDescription_call=0 Unknown_ConnectionDescription_call value
             * @property {number} ConnectionDescription_call_L=1 ConnectionDescription_call_L value
             * @property {number} ConnectionDescription_call_SSL=2 ConnectionDescription_call_SSL value
             */
            PROTO.ConnectionDescription_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_ConnectionDescription_call"] = 0;
                values[valuesById[1] = "ConnectionDescription_call_L"] = 1;
                values[valuesById[2] = "ConnectionDescription_call_SSL"] = 2;
                return values;
            })();
    
            PROTO.ConnectionDescription_in = (function() {
    
                /**
                 * Properties of a ConnectionDescription_in.
                 * @memberof CS.PROTO
                 * @interface IConnectionDescription_in
                 * @property {CS.PROTO.IAPIService|null} [control] ConnectionDescription_in control
                 * @property {CS.PROTO.ConnectionDescription_call|null} [method] ConnectionDescription_in method
                 * @property {string|null} [connectString] ConnectionDescription_in connectString
                 * @property {string|null} [paramString] ConnectionDescription_in paramString
                 * @property {CS.ILocaleDescriptor|null} [locale] ConnectionDescription_in locale
                 */
    
                /**
                 * Constructs a new ConnectionDescription_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectionDescription_in.
                 * @implements IConnectionDescription_in
                 * @constructor
                 * @param {CS.PROTO.IConnectionDescription_in=} [properties] Properties to set
                 */
                function ConnectionDescription_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConnectionDescription_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @instance
                 */
                ConnectionDescription_in.prototype.control = null;
    
                /**
                 * ConnectionDescription_in method.
                 * @member {CS.PROTO.ConnectionDescription_call} method
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @instance
                 */
                ConnectionDescription_in.prototype.method = 0;
    
                /**
                 * ConnectionDescription_in connectString.
                 * @member {string} connectString
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @instance
                 */
                ConnectionDescription_in.prototype.connectString = "";
    
                /**
                 * ConnectionDescription_in paramString.
                 * @member {string} paramString
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @instance
                 */
                ConnectionDescription_in.prototype.paramString = "";
    
                /**
                 * ConnectionDescription_in locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @instance
                 */
                ConnectionDescription_in.prototype.locale = null;
    
                /**
                 * Creates a new ConnectionDescription_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {CS.PROTO.IConnectionDescription_in=} [properties] Properties to set
                 * @returns {CS.PROTO.ConnectionDescription_in} ConnectionDescription_in instance
                 */
                ConnectionDescription_in.create = function create(properties) {
                    return new ConnectionDescription_in(properties);
                };
    
                /**
                 * Encodes the specified ConnectionDescription_in message. Does not implicitly {@link CS.PROTO.ConnectionDescription_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {CS.PROTO.IConnectionDescription_in} message ConnectionDescription_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectionDescription_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.connectString != null && Object.hasOwnProperty.call(message, "connectString"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.connectString);
                    if (message.paramString != null && Object.hasOwnProperty.call(message, "paramString"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.paramString);
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ConnectionDescription_in message, length delimited. Does not implicitly {@link CS.PROTO.ConnectionDescription_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {CS.PROTO.IConnectionDescription_in} message ConnectionDescription_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectionDescription_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConnectionDescription_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ConnectionDescription_in} ConnectionDescription_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectionDescription_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ConnectionDescription_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.connectString = reader.string();
                            break;
                        case 4:
                            message.paramString = reader.string();
                            break;
                        case 5:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConnectionDescription_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ConnectionDescription_in} ConnectionDescription_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectionDescription_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConnectionDescription_in message.
                 * @function verify
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConnectionDescription_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.connectString != null && message.hasOwnProperty("connectString"))
                        if (!$util.isString(message.connectString))
                            return "connectString: string expected";
                    if (message.paramString != null && message.hasOwnProperty("paramString"))
                        if (!$util.isString(message.paramString))
                            return "paramString: string expected";
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ConnectionDescription_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ConnectionDescription_in} ConnectionDescription_in
                 */
                ConnectionDescription_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ConnectionDescription_in)
                        return object;
                    var message = new $root.CS.PROTO.ConnectionDescription_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.ConnectionDescription_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_ConnectionDescription_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "ConnectionDescription_call_L":
                    case 1:
                        message.method = 1;
                        break;
                    case "ConnectionDescription_call_SSL":
                    case 2:
                        message.method = 2;
                        break;
                    }
                    if (object.connectString != null)
                        message.connectString = String(object.connectString);
                    if (object.paramString != null)
                        message.paramString = String(object.paramString);
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.ConnectionDescription_in.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConnectionDescription_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @static
                 * @param {CS.PROTO.ConnectionDescription_in} message ConnectionDescription_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectionDescription_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_ConnectionDescription_call" : 0;
                        object.connectString = "";
                        object.paramString = "";
                        object.locale = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.ConnectionDescription_call[message.method] : message.method;
                    if (message.connectString != null && message.hasOwnProperty("connectString"))
                        object.connectString = message.connectString;
                    if (message.paramString != null && message.hasOwnProperty("paramString"))
                        object.paramString = message.paramString;
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    return object;
                };
    
                /**
                 * Converts this ConnectionDescription_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ConnectionDescription_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectionDescription_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConnectionDescription_in;
            })();
    
            PROTO.ConnectionDescription_out = (function() {
    
                /**
                 * Properties of a ConnectionDescription_out.
                 * @memberof CS.PROTO
                 * @interface IConnectionDescription_out
                 * @property {CS.Status|null} [status] ConnectionDescription_out status
                 * @property {string|null} [desc] ConnectionDescription_out desc
                 * @property {Array.<CS.IError>|null} [errors] ConnectionDescription_out errors
                 */
    
                /**
                 * Constructs a new ConnectionDescription_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectionDescription_out.
                 * @implements IConnectionDescription_out
                 * @constructor
                 * @param {CS.PROTO.IConnectionDescription_out=} [properties] Properties to set
                 */
                function ConnectionDescription_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConnectionDescription_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @instance
                 */
                ConnectionDescription_out.prototype.status = 0;
    
                /**
                 * ConnectionDescription_out desc.
                 * @member {string} desc
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @instance
                 */
                ConnectionDescription_out.prototype.desc = "";
    
                /**
                 * ConnectionDescription_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @instance
                 */
                ConnectionDescription_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new ConnectionDescription_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {CS.PROTO.IConnectionDescription_out=} [properties] Properties to set
                 * @returns {CS.PROTO.ConnectionDescription_out} ConnectionDescription_out instance
                 */
                ConnectionDescription_out.create = function create(properties) {
                    return new ConnectionDescription_out(properties);
                };
    
                /**
                 * Encodes the specified ConnectionDescription_out message. Does not implicitly {@link CS.PROTO.ConnectionDescription_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {CS.PROTO.IConnectionDescription_out} message ConnectionDescription_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectionDescription_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.desc);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ConnectionDescription_out message, length delimited. Does not implicitly {@link CS.PROTO.ConnectionDescription_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {CS.PROTO.IConnectionDescription_out} message ConnectionDescription_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectionDescription_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConnectionDescription_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ConnectionDescription_out} ConnectionDescription_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectionDescription_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ConnectionDescription_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.desc = reader.string();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConnectionDescription_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ConnectionDescription_out} ConnectionDescription_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectionDescription_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConnectionDescription_out message.
                 * @function verify
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConnectionDescription_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        if (!$util.isString(message.desc))
                            return "desc: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ConnectionDescription_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ConnectionDescription_out} ConnectionDescription_out
                 */
                ConnectionDescription_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ConnectionDescription_out)
                        return object;
                    var message = new $root.CS.PROTO.ConnectionDescription_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.desc != null)
                        message.desc = String(object.desc);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.ConnectionDescription_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.ConnectionDescription_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConnectionDescription_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @static
                 * @param {CS.PROTO.ConnectionDescription_out} message ConnectionDescription_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectionDescription_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.desc = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = message.desc;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ConnectionDescription_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ConnectionDescription_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectionDescription_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConnectionDescription_out;
            })();
    
            /**
             * Inquiry_call enum.
             * @name CS.PROTO.Inquiry_call
             * @enum {number}
             * @property {number} Unknown_Inquiry_call=0 Unknown_Inquiry_call value
             * @property {number} Inquiry_call_S=1 Inquiry_call_S value
             * @property {number} Inquiry_call_SP=2 Inquiry_call_SP value
             */
            PROTO.Inquiry_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_Inquiry_call"] = 0;
                values[valuesById[1] = "Inquiry_call_S"] = 1;
                values[valuesById[2] = "Inquiry_call_SP"] = 2;
                return values;
            })();
    
            PROTO.Inquiry_in = (function() {
    
                /**
                 * Properties of an Inquiry_in.
                 * @memberof CS.PROTO
                 * @interface IInquiry_in
                 * @property {CS.PROTO.IAPIService|null} [control] Inquiry_in control
                 * @property {CS.PROTO.Inquiry_call|null} [method] Inquiry_in method
                 * @property {string|null} ["in"] Inquiry_in in
                 * @property {Array.<CS.IKeyValueProperty>|null} [properties] Inquiry_in properties
                 */
    
                /**
                 * Constructs a new Inquiry_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an Inquiry_in.
                 * @implements IInquiry_in
                 * @constructor
                 * @param {CS.PROTO.IInquiry_in=} [properties] Properties to set
                 */
                function Inquiry_in(properties) {
                    this.properties = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Inquiry_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Inquiry_in
                 * @instance
                 */
                Inquiry_in.prototype.control = null;
    
                /**
                 * Inquiry_in method.
                 * @member {CS.PROTO.Inquiry_call} method
                 * @memberof CS.PROTO.Inquiry_in
                 * @instance
                 */
                Inquiry_in.prototype.method = 0;
    
                /**
                 * Inquiry_in in.
                 * @member {string} in
                 * @memberof CS.PROTO.Inquiry_in
                 * @instance
                 */
                Inquiry_in.prototype["in"] = "";
    
                /**
                 * Inquiry_in properties.
                 * @member {Array.<CS.IKeyValueProperty>} properties
                 * @memberof CS.PROTO.Inquiry_in
                 * @instance
                 */
                Inquiry_in.prototype.properties = $util.emptyArray;
    
                /**
                 * Creates a new Inquiry_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {CS.PROTO.IInquiry_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Inquiry_in} Inquiry_in instance
                 */
                Inquiry_in.create = function create(properties) {
                    return new Inquiry_in(properties);
                };
    
                /**
                 * Encodes the specified Inquiry_in message. Does not implicitly {@link CS.PROTO.Inquiry_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {CS.PROTO.IInquiry_in} message Inquiry_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Inquiry_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message["in"] != null && Object.hasOwnProperty.call(message, "in"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message["in"]);
                    if (message.properties != null && message.properties.length)
                        for (var i = 0; i < message.properties.length; ++i)
                            $root.CS.KeyValueProperty.encode(message.properties[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Inquiry_in message, length delimited. Does not implicitly {@link CS.PROTO.Inquiry_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {CS.PROTO.IInquiry_in} message Inquiry_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Inquiry_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Inquiry_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Inquiry_in} Inquiry_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Inquiry_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Inquiry_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message["in"] = reader.string();
                            break;
                        case 4:
                            if (!(message.properties && message.properties.length))
                                message.properties = [];
                            message.properties.push($root.CS.KeyValueProperty.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Inquiry_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Inquiry_in} Inquiry_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Inquiry_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Inquiry_in message.
                 * @function verify
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Inquiry_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message["in"] != null && message.hasOwnProperty("in"))
                        if (!$util.isString(message["in"]))
                            return "in: string expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!Array.isArray(message.properties))
                            return "properties: array expected";
                        for (var i = 0; i < message.properties.length; ++i) {
                            var error = $root.CS.KeyValueProperty.verify(message.properties[i]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Inquiry_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Inquiry_in} Inquiry_in
                 */
                Inquiry_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Inquiry_in)
                        return object;
                    var message = new $root.CS.PROTO.Inquiry_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Inquiry_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_Inquiry_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "Inquiry_call_S":
                    case 1:
                        message.method = 1;
                        break;
                    case "Inquiry_call_SP":
                    case 2:
                        message.method = 2;
                        break;
                    }
                    if (object["in"] != null)
                        message["in"] = String(object["in"]);
                    if (object.properties) {
                        if (!Array.isArray(object.properties))
                            throw TypeError(".CS.PROTO.Inquiry_in.properties: array expected");
                        message.properties = [];
                        for (var i = 0; i < object.properties.length; ++i) {
                            if (typeof object.properties[i] !== "object")
                                throw TypeError(".CS.PROTO.Inquiry_in.properties: object expected");
                            message.properties[i] = $root.CS.KeyValueProperty.fromObject(object.properties[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Inquiry_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Inquiry_in
                 * @static
                 * @param {CS.PROTO.Inquiry_in} message Inquiry_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Inquiry_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.properties = [];
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_Inquiry_call" : 0;
                        object["in"] = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.Inquiry_call[message.method] : message.method;
                    if (message["in"] != null && message.hasOwnProperty("in"))
                        object["in"] = message["in"];
                    if (message.properties && message.properties.length) {
                        object.properties = [];
                        for (var j = 0; j < message.properties.length; ++j)
                            object.properties[j] = $root.CS.KeyValueProperty.toObject(message.properties[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Inquiry_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Inquiry_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Inquiry_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Inquiry_in;
            })();
    
            PROTO.Inquiry_out = (function() {
    
                /**
                 * Properties of an Inquiry_out.
                 * @memberof CS.PROTO
                 * @interface IInquiry_out
                 * @property {CS.Status|null} [status] Inquiry_out status
                 * @property {string|null} [result] Inquiry_out result
                 * @property {Array.<CS.IError>|null} [errors] Inquiry_out errors
                 */
    
                /**
                 * Constructs a new Inquiry_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an Inquiry_out.
                 * @implements IInquiry_out
                 * @constructor
                 * @param {CS.PROTO.IInquiry_out=} [properties] Properties to set
                 */
                function Inquiry_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Inquiry_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Inquiry_out
                 * @instance
                 */
                Inquiry_out.prototype.status = 0;
    
                /**
                 * Inquiry_out result.
                 * @member {string} result
                 * @memberof CS.PROTO.Inquiry_out
                 * @instance
                 */
                Inquiry_out.prototype.result = "";
    
                /**
                 * Inquiry_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Inquiry_out
                 * @instance
                 */
                Inquiry_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Inquiry_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {CS.PROTO.IInquiry_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Inquiry_out} Inquiry_out instance
                 */
                Inquiry_out.create = function create(properties) {
                    return new Inquiry_out(properties);
                };
    
                /**
                 * Encodes the specified Inquiry_out message. Does not implicitly {@link CS.PROTO.Inquiry_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {CS.PROTO.IInquiry_out} message Inquiry_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Inquiry_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Inquiry_out message, length delimited. Does not implicitly {@link CS.PROTO.Inquiry_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {CS.PROTO.IInquiry_out} message Inquiry_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Inquiry_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Inquiry_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Inquiry_out} Inquiry_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Inquiry_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Inquiry_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.result = reader.string();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Inquiry_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Inquiry_out} Inquiry_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Inquiry_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Inquiry_out message.
                 * @function verify
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Inquiry_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.result != null && message.hasOwnProperty("result"))
                        if (!$util.isString(message.result))
                            return "result: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Inquiry_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Inquiry_out} Inquiry_out
                 */
                Inquiry_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Inquiry_out)
                        return object;
                    var message = new $root.CS.PROTO.Inquiry_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.result != null)
                        message.result = String(object.result);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Inquiry_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Inquiry_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Inquiry_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Inquiry_out
                 * @static
                 * @param {CS.PROTO.Inquiry_out} message Inquiry_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Inquiry_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.result = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.result != null && message.hasOwnProperty("result"))
                        object.result = message.result;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Inquiry_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Inquiry_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Inquiry_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Inquiry_out;
            })();
    
            PROTO.BuildBOStrings_in = (function() {
    
                /**
                 * Properties of a BuildBOStrings_in.
                 * @memberof CS.PROTO
                 * @interface IBuildBOStrings_in
                 * @property {CS.PROTO.IAPIService|null} [control] BuildBOStrings_in control
                 * @property {string|null} [connectionDefinition] BuildBOStrings_in connectionDefinition
                 */
    
                /**
                 * Constructs a new BuildBOStrings_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a BuildBOStrings_in.
                 * @implements IBuildBOStrings_in
                 * @constructor
                 * @param {CS.PROTO.IBuildBOStrings_in=} [properties] Properties to set
                 */
                function BuildBOStrings_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BuildBOStrings_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @instance
                 */
                BuildBOStrings_in.prototype.control = null;
    
                /**
                 * BuildBOStrings_in connectionDefinition.
                 * @member {string} connectionDefinition
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @instance
                 */
                BuildBOStrings_in.prototype.connectionDefinition = "";
    
                /**
                 * Creates a new BuildBOStrings_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {CS.PROTO.IBuildBOStrings_in=} [properties] Properties to set
                 * @returns {CS.PROTO.BuildBOStrings_in} BuildBOStrings_in instance
                 */
                BuildBOStrings_in.create = function create(properties) {
                    return new BuildBOStrings_in(properties);
                };
    
                /**
                 * Encodes the specified BuildBOStrings_in message. Does not implicitly {@link CS.PROTO.BuildBOStrings_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {CS.PROTO.IBuildBOStrings_in} message BuildBOStrings_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildBOStrings_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.connectionDefinition != null && Object.hasOwnProperty.call(message, "connectionDefinition"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionDefinition);
                    return writer;
                };
    
                /**
                 * Encodes the specified BuildBOStrings_in message, length delimited. Does not implicitly {@link CS.PROTO.BuildBOStrings_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {CS.PROTO.IBuildBOStrings_in} message BuildBOStrings_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildBOStrings_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BuildBOStrings_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.BuildBOStrings_in} BuildBOStrings_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildBOStrings_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.BuildBOStrings_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.connectionDefinition = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BuildBOStrings_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.BuildBOStrings_in} BuildBOStrings_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildBOStrings_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BuildBOStrings_in message.
                 * @function verify
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BuildBOStrings_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.connectionDefinition != null && message.hasOwnProperty("connectionDefinition"))
                        if (!$util.isString(message.connectionDefinition))
                            return "connectionDefinition: string expected";
                    return null;
                };
    
                /**
                 * Creates a BuildBOStrings_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.BuildBOStrings_in} BuildBOStrings_in
                 */
                BuildBOStrings_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.BuildBOStrings_in)
                        return object;
                    var message = new $root.CS.PROTO.BuildBOStrings_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.BuildBOStrings_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.connectionDefinition != null)
                        message.connectionDefinition = String(object.connectionDefinition);
                    return message;
                };
    
                /**
                 * Creates a plain object from a BuildBOStrings_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @static
                 * @param {CS.PROTO.BuildBOStrings_in} message BuildBOStrings_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BuildBOStrings_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.connectionDefinition = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.connectionDefinition != null && message.hasOwnProperty("connectionDefinition"))
                        object.connectionDefinition = message.connectionDefinition;
                    return object;
                };
    
                /**
                 * Converts this BuildBOStrings_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.BuildBOStrings_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BuildBOStrings_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BuildBOStrings_in;
            })();
    
            PROTO.BuildBOStrings_out = (function() {
    
                /**
                 * Properties of a BuildBOStrings_out.
                 * @memberof CS.PROTO
                 * @interface IBuildBOStrings_out
                 * @property {CS.Status|null} [status] BuildBOStrings_out status
                 * @property {string|null} [connectString] BuildBOStrings_out connectString
                 * @property {string|null} [paramString] BuildBOStrings_out paramString
                 * @property {Array.<CS.IError>|null} [errors] BuildBOStrings_out errors
                 */
    
                /**
                 * Constructs a new BuildBOStrings_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a BuildBOStrings_out.
                 * @implements IBuildBOStrings_out
                 * @constructor
                 * @param {CS.PROTO.IBuildBOStrings_out=} [properties] Properties to set
                 */
                function BuildBOStrings_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BuildBOStrings_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @instance
                 */
                BuildBOStrings_out.prototype.status = 0;
    
                /**
                 * BuildBOStrings_out connectString.
                 * @member {string} connectString
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @instance
                 */
                BuildBOStrings_out.prototype.connectString = "";
    
                /**
                 * BuildBOStrings_out paramString.
                 * @member {string} paramString
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @instance
                 */
                BuildBOStrings_out.prototype.paramString = "";
    
                /**
                 * BuildBOStrings_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @instance
                 */
                BuildBOStrings_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new BuildBOStrings_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {CS.PROTO.IBuildBOStrings_out=} [properties] Properties to set
                 * @returns {CS.PROTO.BuildBOStrings_out} BuildBOStrings_out instance
                 */
                BuildBOStrings_out.create = function create(properties) {
                    return new BuildBOStrings_out(properties);
                };
    
                /**
                 * Encodes the specified BuildBOStrings_out message. Does not implicitly {@link CS.PROTO.BuildBOStrings_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {CS.PROTO.IBuildBOStrings_out} message BuildBOStrings_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildBOStrings_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.connectString != null && Object.hasOwnProperty.call(message, "connectString"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectString);
                    if (message.paramString != null && Object.hasOwnProperty.call(message, "paramString"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.paramString);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified BuildBOStrings_out message, length delimited. Does not implicitly {@link CS.PROTO.BuildBOStrings_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {CS.PROTO.IBuildBOStrings_out} message BuildBOStrings_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildBOStrings_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BuildBOStrings_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.BuildBOStrings_out} BuildBOStrings_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildBOStrings_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.BuildBOStrings_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.connectString = reader.string();
                            break;
                        case 3:
                            message.paramString = reader.string();
                            break;
                        case 4:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BuildBOStrings_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.BuildBOStrings_out} BuildBOStrings_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildBOStrings_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BuildBOStrings_out message.
                 * @function verify
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BuildBOStrings_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.connectString != null && message.hasOwnProperty("connectString"))
                        if (!$util.isString(message.connectString))
                            return "connectString: string expected";
                    if (message.paramString != null && message.hasOwnProperty("paramString"))
                        if (!$util.isString(message.paramString))
                            return "paramString: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a BuildBOStrings_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.BuildBOStrings_out} BuildBOStrings_out
                 */
                BuildBOStrings_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.BuildBOStrings_out)
                        return object;
                    var message = new $root.CS.PROTO.BuildBOStrings_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.connectString != null)
                        message.connectString = String(object.connectString);
                    if (object.paramString != null)
                        message.paramString = String(object.paramString);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.BuildBOStrings_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.BuildBOStrings_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a BuildBOStrings_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @static
                 * @param {CS.PROTO.BuildBOStrings_out} message BuildBOStrings_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BuildBOStrings_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.connectString = "";
                        object.paramString = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.connectString != null && message.hasOwnProperty("connectString"))
                        object.connectString = message.connectString;
                    if (message.paramString != null && message.hasOwnProperty("paramString"))
                        object.paramString = message.paramString;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this BuildBOStrings_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.BuildBOStrings_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BuildBOStrings_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BuildBOStrings_out;
            })();
    
            PROTO.TestConnection_in = (function() {
    
                /**
                 * Properties of a TestConnection_in.
                 * @memberof CS.PROTO
                 * @interface ITestConnection_in
                 * @property {CS.PROTO.IAPIService|null} [control] TestConnection_in control
                 * @property {string|null} [connectionDefinition] TestConnection_in connectionDefinition
                 * @property {Array.<CS.IKeyValueProperty>|null} [properties] TestConnection_in properties
                 */
    
                /**
                 * Constructs a new TestConnection_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a TestConnection_in.
                 * @implements ITestConnection_in
                 * @constructor
                 * @param {CS.PROTO.ITestConnection_in=} [properties] Properties to set
                 */
                function TestConnection_in(properties) {
                    this.properties = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TestConnection_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.TestConnection_in
                 * @instance
                 */
                TestConnection_in.prototype.control = null;
    
                /**
                 * TestConnection_in connectionDefinition.
                 * @member {string} connectionDefinition
                 * @memberof CS.PROTO.TestConnection_in
                 * @instance
                 */
                TestConnection_in.prototype.connectionDefinition = "";
    
                /**
                 * TestConnection_in properties.
                 * @member {Array.<CS.IKeyValueProperty>} properties
                 * @memberof CS.PROTO.TestConnection_in
                 * @instance
                 */
                TestConnection_in.prototype.properties = $util.emptyArray;
    
                /**
                 * Creates a new TestConnection_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {CS.PROTO.ITestConnection_in=} [properties] Properties to set
                 * @returns {CS.PROTO.TestConnection_in} TestConnection_in instance
                 */
                TestConnection_in.create = function create(properties) {
                    return new TestConnection_in(properties);
                };
    
                /**
                 * Encodes the specified TestConnection_in message. Does not implicitly {@link CS.PROTO.TestConnection_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {CS.PROTO.ITestConnection_in} message TestConnection_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestConnection_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.connectionDefinition != null && Object.hasOwnProperty.call(message, "connectionDefinition"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionDefinition);
                    if (message.properties != null && message.properties.length)
                        for (var i = 0; i < message.properties.length; ++i)
                            $root.CS.KeyValueProperty.encode(message.properties[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified TestConnection_in message, length delimited. Does not implicitly {@link CS.PROTO.TestConnection_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {CS.PROTO.ITestConnection_in} message TestConnection_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestConnection_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a TestConnection_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.TestConnection_in} TestConnection_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestConnection_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.TestConnection_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.connectionDefinition = reader.string();
                            break;
                        case 3:
                            if (!(message.properties && message.properties.length))
                                message.properties = [];
                            message.properties.push($root.CS.KeyValueProperty.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a TestConnection_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.TestConnection_in} TestConnection_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestConnection_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a TestConnection_in message.
                 * @function verify
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestConnection_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.connectionDefinition != null && message.hasOwnProperty("connectionDefinition"))
                        if (!$util.isString(message.connectionDefinition))
                            return "connectionDefinition: string expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!Array.isArray(message.properties))
                            return "properties: array expected";
                        for (var i = 0; i < message.properties.length; ++i) {
                            var error = $root.CS.KeyValueProperty.verify(message.properties[i]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a TestConnection_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.TestConnection_in} TestConnection_in
                 */
                TestConnection_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.TestConnection_in)
                        return object;
                    var message = new $root.CS.PROTO.TestConnection_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.TestConnection_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.connectionDefinition != null)
                        message.connectionDefinition = String(object.connectionDefinition);
                    if (object.properties) {
                        if (!Array.isArray(object.properties))
                            throw TypeError(".CS.PROTO.TestConnection_in.properties: array expected");
                        message.properties = [];
                        for (var i = 0; i < object.properties.length; ++i) {
                            if (typeof object.properties[i] !== "object")
                                throw TypeError(".CS.PROTO.TestConnection_in.properties: object expected");
                            message.properties[i] = $root.CS.KeyValueProperty.fromObject(object.properties[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a TestConnection_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.TestConnection_in
                 * @static
                 * @param {CS.PROTO.TestConnection_in} message TestConnection_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestConnection_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.properties = [];
                    if (options.defaults) {
                        object.control = null;
                        object.connectionDefinition = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.connectionDefinition != null && message.hasOwnProperty("connectionDefinition"))
                        object.connectionDefinition = message.connectionDefinition;
                    if (message.properties && message.properties.length) {
                        object.properties = [];
                        for (var j = 0; j < message.properties.length; ++j)
                            object.properties[j] = $root.CS.KeyValueProperty.toObject(message.properties[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this TestConnection_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.TestConnection_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestConnection_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return TestConnection_in;
            })();
    
            PROTO.TestConnection_out = (function() {
    
                /**
                 * Properties of a TestConnection_out.
                 * @memberof CS.PROTO
                 * @interface ITestConnection_out
                 * @property {CS.Status|null} [status] TestConnection_out status
                 * @property {string|null} [result] TestConnection_out result
                 * @property {Array.<CS.IError>|null} [errors] TestConnection_out errors
                 */
    
                /**
                 * Constructs a new TestConnection_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a TestConnection_out.
                 * @implements ITestConnection_out
                 * @constructor
                 * @param {CS.PROTO.ITestConnection_out=} [properties] Properties to set
                 */
                function TestConnection_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TestConnection_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.TestConnection_out
                 * @instance
                 */
                TestConnection_out.prototype.status = 0;
    
                /**
                 * TestConnection_out result.
                 * @member {string} result
                 * @memberof CS.PROTO.TestConnection_out
                 * @instance
                 */
                TestConnection_out.prototype.result = "";
    
                /**
                 * TestConnection_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.TestConnection_out
                 * @instance
                 */
                TestConnection_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new TestConnection_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {CS.PROTO.ITestConnection_out=} [properties] Properties to set
                 * @returns {CS.PROTO.TestConnection_out} TestConnection_out instance
                 */
                TestConnection_out.create = function create(properties) {
                    return new TestConnection_out(properties);
                };
    
                /**
                 * Encodes the specified TestConnection_out message. Does not implicitly {@link CS.PROTO.TestConnection_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {CS.PROTO.ITestConnection_out} message TestConnection_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestConnection_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified TestConnection_out message, length delimited. Does not implicitly {@link CS.PROTO.TestConnection_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {CS.PROTO.ITestConnection_out} message TestConnection_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestConnection_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a TestConnection_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.TestConnection_out} TestConnection_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestConnection_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.TestConnection_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.result = reader.string();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a TestConnection_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.TestConnection_out} TestConnection_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestConnection_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a TestConnection_out message.
                 * @function verify
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestConnection_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.result != null && message.hasOwnProperty("result"))
                        if (!$util.isString(message.result))
                            return "result: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a TestConnection_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.TestConnection_out} TestConnection_out
                 */
                TestConnection_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.TestConnection_out)
                        return object;
                    var message = new $root.CS.PROTO.TestConnection_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.result != null)
                        message.result = String(object.result);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.TestConnection_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.TestConnection_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a TestConnection_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.TestConnection_out
                 * @static
                 * @param {CS.PROTO.TestConnection_out} message TestConnection_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestConnection_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.result = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.result != null && message.hasOwnProperty("result"))
                        object.result = message.result;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this TestConnection_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.TestConnection_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestConnection_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return TestConnection_out;
            })();
    
            /**
             * APIServiceLevel enum.
             * @name CS.PROTO.APIServiceLevel
             * @enum {number}
             * @property {number} Unknown_ServiceLevel=0 Unknown_ServiceLevel value
             * @property {number} GenericJob=1 GenericJob value
             * @property {number} Job=2 Job value
             * @property {number} OpenJob=3 OpenJob value
             * @property {number} RDBMSJob=4 RDBMSJob value
             * @property {number} RepositoryJob=5 RepositoryJob value
             * @property {number} Dictionary=6 Dictionary value
             * @property {number} OpenDictionary=7 OpenDictionary value
             * @property {number} RDBMSDictionary=8 RDBMSDictionary value
             * @property {number} DictionaryDescriptor=9 DictionaryDescriptor value
             * @property {number} JobDescriptor=10 JobDescriptor value
             */
            PROTO.APIServiceLevel = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_ServiceLevel"] = 0;
                values[valuesById[1] = "GenericJob"] = 1;
                values[valuesById[2] = "Job"] = 2;
                values[valuesById[3] = "OpenJob"] = 3;
                values[valuesById[4] = "RDBMSJob"] = 4;
                values[valuesById[5] = "RepositoryJob"] = 5;
                values[valuesById[6] = "Dictionary"] = 6;
                values[valuesById[7] = "OpenDictionary"] = 7;
                values[valuesById[8] = "RDBMSDictionary"] = 8;
                values[valuesById[9] = "DictionaryDescriptor"] = 9;
                values[valuesById[10] = "JobDescriptor"] = 10;
                return values;
            })();
    
            PROTO.APIService = (function() {
    
                /**
                 * Properties of a APIService.
                 * @memberof CS.PROTO
                 * @interface IAPIService
                 * @property {CS.PROTO.APIServiceLevel|null} [level] APIService level
                 * @property {number|null} [objid] APIService objid
                 */
    
                /**
                 * Constructs a new APIService.
                 * @memberof CS.PROTO
                 * @classdesc Represents a APIService.
                 * @implements IAPIService
                 * @constructor
                 * @param {CS.PROTO.IAPIService=} [properties] Properties to set
                 */
                function APIService(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * APIService level.
                 * @member {CS.PROTO.APIServiceLevel} level
                 * @memberof CS.PROTO.APIService
                 * @instance
                 */
                APIService.prototype.level = 0;
    
                /**
                 * APIService objid.
                 * @member {number} objid
                 * @memberof CS.PROTO.APIService
                 * @instance
                 */
                APIService.prototype.objid = 0;
    
                /**
                 * Creates a new APIService instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {CS.PROTO.IAPIService=} [properties] Properties to set
                 * @returns {CS.PROTO.APIService} APIService instance
                 */
                APIService.create = function create(properties) {
                    return new APIService(properties);
                };
    
                /**
                 * Encodes the specified APIService message. Does not implicitly {@link CS.PROTO.APIService.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {CS.PROTO.IAPIService} message APIService message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                APIService.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
                    if (message.objid != null && Object.hasOwnProperty.call(message, "objid"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.objid);
                    return writer;
                };
    
                /**
                 * Encodes the specified APIService message, length delimited. Does not implicitly {@link CS.PROTO.APIService.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {CS.PROTO.IAPIService} message APIService message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                APIService.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a APIService message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.APIService} APIService
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                APIService.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.APIService();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.level = reader.int32();
                            break;
                        case 2:
                            message.objid = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a APIService message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.APIService} APIService
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                APIService.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a APIService message.
                 * @function verify
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                APIService.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.level != null && message.hasOwnProperty("level"))
                        switch (message.level) {
                        default:
                            return "level: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.objid != null && message.hasOwnProperty("objid"))
                        if (!$util.isInteger(message.objid))
                            return "objid: integer expected";
                    return null;
                };
    
                /**
                 * Creates a APIService message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.APIService} APIService
                 */
                APIService.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.APIService)
                        return object;
                    var message = new $root.CS.PROTO.APIService();
                    switch (object.level) {
                    case "Unknown_ServiceLevel":
                    case 0:
                        message.level = 0;
                        break;
                    case "GenericJob":
                    case 1:
                        message.level = 1;
                        break;
                    case "Job":
                    case 2:
                        message.level = 2;
                        break;
                    case "OpenJob":
                    case 3:
                        message.level = 3;
                        break;
                    case "RDBMSJob":
                    case 4:
                        message.level = 4;
                        break;
                    case "RepositoryJob":
                    case 5:
                        message.level = 5;
                        break;
                    case "Dictionary":
                    case 6:
                        message.level = 6;
                        break;
                    case "OpenDictionary":
                    case 7:
                        message.level = 7;
                        break;
                    case "RDBMSDictionary":
                    case 8:
                        message.level = 8;
                        break;
                    case "DictionaryDescriptor":
                    case 9:
                        message.level = 9;
                        break;
                    case "JobDescriptor":
                    case 10:
                        message.level = 10;
                        break;
                    }
                    if (object.objid != null)
                        message.objid = object.objid >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a APIService message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.APIService
                 * @static
                 * @param {CS.PROTO.APIService} message APIService
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                APIService.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.level = options.enums === String ? "Unknown_ServiceLevel" : 0;
                        object.objid = 0;
                    }
                    if (message.level != null && message.hasOwnProperty("level"))
                        object.level = options.enums === String ? $root.CS.PROTO.APIServiceLevel[message.level] : message.level;
                    if (message.objid != null && message.hasOwnProperty("objid"))
                        object.objid = message.objid;
                    return object;
                };
    
                /**
                 * Converts this APIService to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.APIService
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                APIService.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return APIService;
            })();
    
            PROTO.ConnectionManagerService = (function() {
    
                /**
                 * Constructs a new ConnectionManagerService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectionManagerService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ConnectionManagerService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (ConnectionManagerService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConnectionManagerService;
    
                /**
                 * Creates new ConnectionManagerService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {ConnectionManagerService} RPC service. Useful where requests and/or responses are streamed.
                 */
                ConnectionManagerService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionManagerService#connectionDescription}.
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @typedef ConnectionDescriptionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.ConnectionDescription_out} [response] ConnectionDescription_out
                 */
    
                /**
                 * Calls ConnectionDescription.
                 * @function connectionDescription
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.IConnectionDescription_in} request ConnectionDescription_in message or plain object
                 * @param {CS.PROTO.ConnectionManagerService.ConnectionDescriptionCallback} callback Node-style callback called with the error, if any, and ConnectionDescription_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionManagerService.prototype.connectionDescription = function connectionDescription(request, callback) {
                    return this.rpcCall(connectionDescription, $root.CS.PROTO.ConnectionDescription_in, $root.CS.PROTO.ConnectionDescription_out, request, callback);
                }, "name", { value: "ConnectionDescription" });
    
                /**
                 * Calls ConnectionDescription.
                 * @function connectionDescription
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.IConnectionDescription_in} request ConnectionDescription_in message or plain object
                 * @returns {Promise<CS.PROTO.ConnectionDescription_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionManagerService#inquiry}.
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @typedef InquiryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Inquiry_out} [response] Inquiry_out
                 */
    
                /**
                 * Calls Inquiry.
                 * @function inquiry
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.IInquiry_in} request Inquiry_in message or plain object
                 * @param {CS.PROTO.ConnectionManagerService.InquiryCallback} callback Node-style callback called with the error, if any, and Inquiry_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionManagerService.prototype.inquiry = function inquiry(request, callback) {
                    return this.rpcCall(inquiry, $root.CS.PROTO.Inquiry_in, $root.CS.PROTO.Inquiry_out, request, callback);
                }, "name", { value: "Inquiry" });
    
                /**
                 * Calls Inquiry.
                 * @function inquiry
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.IInquiry_in} request Inquiry_in message or plain object
                 * @returns {Promise<CS.PROTO.Inquiry_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionManagerService#buildBOStrings}.
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @typedef BuildBOStringsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.BuildBOStrings_out} [response] BuildBOStrings_out
                 */
    
                /**
                 * Calls BuildBOStrings.
                 * @function buildBOStrings
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.IBuildBOStrings_in} request BuildBOStrings_in message or plain object
                 * @param {CS.PROTO.ConnectionManagerService.BuildBOStringsCallback} callback Node-style callback called with the error, if any, and BuildBOStrings_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionManagerService.prototype.buildBOStrings = function buildBOStrings(request, callback) {
                    return this.rpcCall(buildBOStrings, $root.CS.PROTO.BuildBOStrings_in, $root.CS.PROTO.BuildBOStrings_out, request, callback);
                }, "name", { value: "BuildBOStrings" });
    
                /**
                 * Calls BuildBOStrings.
                 * @function buildBOStrings
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.IBuildBOStrings_in} request BuildBOStrings_in message or plain object
                 * @returns {Promise<CS.PROTO.BuildBOStrings_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionManagerService#testConnection}.
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @typedef TestConnectionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.TestConnection_out} [response] TestConnection_out
                 */
    
                /**
                 * Calls TestConnection.
                 * @function testConnection
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.ITestConnection_in} request TestConnection_in message or plain object
                 * @param {CS.PROTO.ConnectionManagerService.TestConnectionCallback} callback Node-style callback called with the error, if any, and TestConnection_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionManagerService.prototype.testConnection = function testConnection(request, callback) {
                    return this.rpcCall(testConnection, $root.CS.PROTO.TestConnection_in, $root.CS.PROTO.TestConnection_out, request, callback);
                }, "name", { value: "TestConnection" });
    
                /**
                 * Calls TestConnection.
                 * @function testConnection
                 * @memberof CS.PROTO.ConnectionManagerService
                 * @instance
                 * @param {CS.PROTO.ITestConnection_in} request TestConnection_in message or plain object
                 * @returns {Promise<CS.PROTO.TestConnection_out>} Promise
                 * @variation 2
                 */
    
                return ConnectionManagerService;
            })();
    
            PROTO.ConnectivityKind_in = (function() {
    
                /**
                 * Properties of a ConnectivityKind_in.
                 * @memberof CS.PROTO
                 * @interface IConnectivityKind_in
                 * @property {CS.PROTO.IAPIService|null} [control] ConnectivityKind_in control
                 * @property {string|null} [loginString] ConnectivityKind_in loginString
                 */
    
                /**
                 * Constructs a new ConnectivityKind_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectivityKind_in.
                 * @implements IConnectivityKind_in
                 * @constructor
                 * @param {CS.PROTO.IConnectivityKind_in=} [properties] Properties to set
                 */
                function ConnectivityKind_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConnectivityKind_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @instance
                 */
                ConnectivityKind_in.prototype.control = null;
    
                /**
                 * ConnectivityKind_in loginString.
                 * @member {string} loginString
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @instance
                 */
                ConnectivityKind_in.prototype.loginString = "";
    
                /**
                 * Creates a new ConnectivityKind_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {CS.PROTO.IConnectivityKind_in=} [properties] Properties to set
                 * @returns {CS.PROTO.ConnectivityKind_in} ConnectivityKind_in instance
                 */
                ConnectivityKind_in.create = function create(properties) {
                    return new ConnectivityKind_in(properties);
                };
    
                /**
                 * Encodes the specified ConnectivityKind_in message. Does not implicitly {@link CS.PROTO.ConnectivityKind_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {CS.PROTO.IConnectivityKind_in} message ConnectivityKind_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityKind_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.loginString != null && Object.hasOwnProperty.call(message, "loginString"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.loginString);
                    return writer;
                };
    
                /**
                 * Encodes the specified ConnectivityKind_in message, length delimited. Does not implicitly {@link CS.PROTO.ConnectivityKind_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {CS.PROTO.IConnectivityKind_in} message ConnectivityKind_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityKind_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConnectivityKind_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ConnectivityKind_in} ConnectivityKind_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityKind_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ConnectivityKind_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.loginString = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConnectivityKind_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ConnectivityKind_in} ConnectivityKind_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityKind_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConnectivityKind_in message.
                 * @function verify
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConnectivityKind_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.loginString != null && message.hasOwnProperty("loginString"))
                        if (!$util.isString(message.loginString))
                            return "loginString: string expected";
                    return null;
                };
    
                /**
                 * Creates a ConnectivityKind_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ConnectivityKind_in} ConnectivityKind_in
                 */
                ConnectivityKind_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ConnectivityKind_in)
                        return object;
                    var message = new $root.CS.PROTO.ConnectivityKind_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.ConnectivityKind_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.loginString != null)
                        message.loginString = String(object.loginString);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConnectivityKind_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @static
                 * @param {CS.PROTO.ConnectivityKind_in} message ConnectivityKind_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectivityKind_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.loginString = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.loginString != null && message.hasOwnProperty("loginString"))
                        object.loginString = message.loginString;
                    return object;
                };
    
                /**
                 * Converts this ConnectivityKind_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ConnectivityKind_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectivityKind_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConnectivityKind_in;
            })();
    
            PROTO.ConnectivityKind_out = (function() {
    
                /**
                 * Properties of a ConnectivityKind_out.
                 * @memberof CS.PROTO
                 * @interface IConnectivityKind_out
                 * @property {CS.Status|null} [status] ConnectivityKind_out status
                 * @property {CS.ConnectivityType|null} [type] ConnectivityKind_out type
                 * @property {Array.<CS.IError>|null} [errors] ConnectivityKind_out errors
                 */
    
                /**
                 * Constructs a new ConnectivityKind_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectivityKind_out.
                 * @implements IConnectivityKind_out
                 * @constructor
                 * @param {CS.PROTO.IConnectivityKind_out=} [properties] Properties to set
                 */
                function ConnectivityKind_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConnectivityKind_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @instance
                 */
                ConnectivityKind_out.prototype.status = 0;
    
                /**
                 * ConnectivityKind_out type.
                 * @member {CS.ConnectivityType} type
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @instance
                 */
                ConnectivityKind_out.prototype.type = 0;
    
                /**
                 * ConnectivityKind_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @instance
                 */
                ConnectivityKind_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new ConnectivityKind_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {CS.PROTO.IConnectivityKind_out=} [properties] Properties to set
                 * @returns {CS.PROTO.ConnectivityKind_out} ConnectivityKind_out instance
                 */
                ConnectivityKind_out.create = function create(properties) {
                    return new ConnectivityKind_out(properties);
                };
    
                /**
                 * Encodes the specified ConnectivityKind_out message. Does not implicitly {@link CS.PROTO.ConnectivityKind_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {CS.PROTO.IConnectivityKind_out} message ConnectivityKind_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityKind_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ConnectivityKind_out message, length delimited. Does not implicitly {@link CS.PROTO.ConnectivityKind_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {CS.PROTO.IConnectivityKind_out} message ConnectivityKind_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityKind_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConnectivityKind_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ConnectivityKind_out} ConnectivityKind_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityKind_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ConnectivityKind_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConnectivityKind_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ConnectivityKind_out} ConnectivityKind_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityKind_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConnectivityKind_out message.
                 * @function verify
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConnectivityKind_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ConnectivityKind_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ConnectivityKind_out} ConnectivityKind_out
                 */
                ConnectivityKind_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ConnectivityKind_out)
                        return object;
                    var message = new $root.CS.PROTO.ConnectivityKind_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    switch (object.type) {
                    case "Unknown_ConnectivityType":
                    case 0:
                        message.type = 0;
                        break;
                    case "Relational":
                    case 1:
                        message.type = 1;
                        break;
                    case "OLAP":
                    case 2:
                        message.type = 2;
                        break;
                    case "Open":
                    case 3:
                        message.type = 3;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.ConnectivityKind_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.ConnectivityKind_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConnectivityKind_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @static
                 * @param {CS.PROTO.ConnectivityKind_out} message ConnectivityKind_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectivityKind_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.type = options.enums === String ? "Unknown_ConnectivityType" : 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CS.ConnectivityType[message.type] : message.type;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ConnectivityKind_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ConnectivityKind_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectivityKind_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConnectivityKind_out;
            })();
    
            PROTO.SupportKind_in = (function() {
    
                /**
                 * Properties of a SupportKind_in.
                 * @memberof CS.PROTO
                 * @interface ISupportKind_in
                 * @property {CS.PROTO.IAPIService|null} [control] SupportKind_in control
                 */
    
                /**
                 * Constructs a new SupportKind_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a SupportKind_in.
                 * @implements ISupportKind_in
                 * @constructor
                 * @param {CS.PROTO.ISupportKind_in=} [properties] Properties to set
                 */
                function SupportKind_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SupportKind_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.SupportKind_in
                 * @instance
                 */
                SupportKind_in.prototype.control = null;
    
                /**
                 * Creates a new SupportKind_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {CS.PROTO.ISupportKind_in=} [properties] Properties to set
                 * @returns {CS.PROTO.SupportKind_in} SupportKind_in instance
                 */
                SupportKind_in.create = function create(properties) {
                    return new SupportKind_in(properties);
                };
    
                /**
                 * Encodes the specified SupportKind_in message. Does not implicitly {@link CS.PROTO.SupportKind_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {CS.PROTO.ISupportKind_in} message SupportKind_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportKind_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SupportKind_in message, length delimited. Does not implicitly {@link CS.PROTO.SupportKind_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {CS.PROTO.ISupportKind_in} message SupportKind_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportKind_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SupportKind_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.SupportKind_in} SupportKind_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportKind_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.SupportKind_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SupportKind_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.SupportKind_in} SupportKind_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportKind_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SupportKind_in message.
                 * @function verify
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SupportKind_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a SupportKind_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.SupportKind_in} SupportKind_in
                 */
                SupportKind_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.SupportKind_in)
                        return object;
                    var message = new $root.CS.PROTO.SupportKind_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.SupportKind_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SupportKind_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.SupportKind_in
                 * @static
                 * @param {CS.PROTO.SupportKind_in} message SupportKind_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SupportKind_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this SupportKind_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.SupportKind_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SupportKind_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SupportKind_in;
            })();
    
            PROTO.SupportKind_out = (function() {
    
                /**
                 * Properties of a SupportKind_out.
                 * @memberof CS.PROTO
                 * @interface ISupportKind_out
                 * @property {CS.Status|null} [status] SupportKind_out status
                 * @property {Array.<CS.SupportLevel>|null} [supportLevel] SupportKind_out supportLevel
                 * @property {Array.<CS.IError>|null} [errors] SupportKind_out errors
                 */
    
                /**
                 * Constructs a new SupportKind_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a SupportKind_out.
                 * @implements ISupportKind_out
                 * @constructor
                 * @param {CS.PROTO.ISupportKind_out=} [properties] Properties to set
                 */
                function SupportKind_out(properties) {
                    this.supportLevel = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SupportKind_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.SupportKind_out
                 * @instance
                 */
                SupportKind_out.prototype.status = 0;
    
                /**
                 * SupportKind_out supportLevel.
                 * @member {Array.<CS.SupportLevel>} supportLevel
                 * @memberof CS.PROTO.SupportKind_out
                 * @instance
                 */
                SupportKind_out.prototype.supportLevel = $util.emptyArray;
    
                /**
                 * SupportKind_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.SupportKind_out
                 * @instance
                 */
                SupportKind_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new SupportKind_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {CS.PROTO.ISupportKind_out=} [properties] Properties to set
                 * @returns {CS.PROTO.SupportKind_out} SupportKind_out instance
                 */
                SupportKind_out.create = function create(properties) {
                    return new SupportKind_out(properties);
                };
    
                /**
                 * Encodes the specified SupportKind_out message. Does not implicitly {@link CS.PROTO.SupportKind_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {CS.PROTO.ISupportKind_out} message SupportKind_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportKind_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.supportLevel != null && message.supportLevel.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.supportLevel.length; ++i)
                            writer.int32(message.supportLevel[i]);
                        writer.ldelim();
                    }
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SupportKind_out message, length delimited. Does not implicitly {@link CS.PROTO.SupportKind_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {CS.PROTO.ISupportKind_out} message SupportKind_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportKind_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SupportKind_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.SupportKind_out} SupportKind_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportKind_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.SupportKind_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.supportLevel && message.supportLevel.length))
                                message.supportLevel = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.supportLevel.push(reader.int32());
                            } else
                                message.supportLevel.push(reader.int32());
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SupportKind_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.SupportKind_out} SupportKind_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportKind_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SupportKind_out message.
                 * @function verify
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SupportKind_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.supportLevel != null && message.hasOwnProperty("supportLevel")) {
                        if (!Array.isArray(message.supportLevel))
                            return "supportLevel: array expected";
                        for (var i = 0; i < message.supportLevel.length; ++i)
                            switch (message.supportLevel[i]) {
                            default:
                                return "supportLevel: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SupportKind_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.SupportKind_out} SupportKind_out
                 */
                SupportKind_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.SupportKind_out)
                        return object;
                    var message = new $root.CS.PROTO.SupportKind_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.supportLevel) {
                        if (!Array.isArray(object.supportLevel))
                            throw TypeError(".CS.PROTO.SupportKind_out.supportLevel: array expected");
                        message.supportLevel = [];
                        for (var i = 0; i < object.supportLevel.length; ++i)
                            switch (object.supportLevel[i]) {
                            default:
                            case "Unknown_SupportLevel":
                            case 0:
                                message.supportLevel[i] = 0;
                                break;
                            case "Query":
                            case 1:
                                message.supportLevel[i] = 1;
                                break;
                            case "Repository":
                            case 2:
                                message.supportLevel[i] = 2;
                                break;
                            case "StoredProcedure":
                            case 3:
                                message.supportLevel[i] = 3;
                                break;
                            case "Cancel":
                            case 4:
                                message.supportLevel[i] = 4;
                                break;
                            }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.SupportKind_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.SupportKind_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SupportKind_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.SupportKind_out
                 * @static
                 * @param {CS.PROTO.SupportKind_out} message SupportKind_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SupportKind_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.supportLevel = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.supportLevel && message.supportLevel.length) {
                        object.supportLevel = [];
                        for (var j = 0; j < message.supportLevel.length; ++j)
                            object.supportLevel[j] = options.enums === String ? $root.CS.SupportLevel[message.supportLevel[j]] : message.supportLevel[j];
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SupportKind_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.SupportKind_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SupportKind_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SupportKind_out;
            })();
    
            PROTO.CancelSupportKind_in = (function() {
    
                /**
                 * Properties of a CancelSupportKind_in.
                 * @memberof CS.PROTO
                 * @interface ICancelSupportKind_in
                 * @property {CS.PROTO.IAPIService|null} [control] CancelSupportKind_in control
                 */
    
                /**
                 * Constructs a new CancelSupportKind_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CancelSupportKind_in.
                 * @implements ICancelSupportKind_in
                 * @constructor
                 * @param {CS.PROTO.ICancelSupportKind_in=} [properties] Properties to set
                 */
                function CancelSupportKind_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CancelSupportKind_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @instance
                 */
                CancelSupportKind_in.prototype.control = null;
    
                /**
                 * Creates a new CancelSupportKind_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {CS.PROTO.ICancelSupportKind_in=} [properties] Properties to set
                 * @returns {CS.PROTO.CancelSupportKind_in} CancelSupportKind_in instance
                 */
                CancelSupportKind_in.create = function create(properties) {
                    return new CancelSupportKind_in(properties);
                };
    
                /**
                 * Encodes the specified CancelSupportKind_in message. Does not implicitly {@link CS.PROTO.CancelSupportKind_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {CS.PROTO.ICancelSupportKind_in} message CancelSupportKind_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CancelSupportKind_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CancelSupportKind_in message, length delimited. Does not implicitly {@link CS.PROTO.CancelSupportKind_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {CS.PROTO.ICancelSupportKind_in} message CancelSupportKind_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CancelSupportKind_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CancelSupportKind_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CancelSupportKind_in} CancelSupportKind_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CancelSupportKind_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CancelSupportKind_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CancelSupportKind_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CancelSupportKind_in} CancelSupportKind_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CancelSupportKind_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CancelSupportKind_in message.
                 * @function verify
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CancelSupportKind_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a CancelSupportKind_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CancelSupportKind_in} CancelSupportKind_in
                 */
                CancelSupportKind_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CancelSupportKind_in)
                        return object;
                    var message = new $root.CS.PROTO.CancelSupportKind_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.CancelSupportKind_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CancelSupportKind_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @static
                 * @param {CS.PROTO.CancelSupportKind_in} message CancelSupportKind_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CancelSupportKind_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this CancelSupportKind_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CancelSupportKind_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CancelSupportKind_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CancelSupportKind_in;
            })();
    
            PROTO.CancelSupportKind_out = (function() {
    
                /**
                 * Properties of a CancelSupportKind_out.
                 * @memberof CS.PROTO
                 * @interface ICancelSupportKind_out
                 * @property {CS.Status|null} [status] CancelSupportKind_out status
                 * @property {Array.<CS.CancelSupportLevel>|null} [cancelSupportLevel] CancelSupportKind_out cancelSupportLevel
                 * @property {Array.<CS.IError>|null} [errors] CancelSupportKind_out errors
                 */
    
                /**
                 * Constructs a new CancelSupportKind_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CancelSupportKind_out.
                 * @implements ICancelSupportKind_out
                 * @constructor
                 * @param {CS.PROTO.ICancelSupportKind_out=} [properties] Properties to set
                 */
                function CancelSupportKind_out(properties) {
                    this.cancelSupportLevel = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CancelSupportKind_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @instance
                 */
                CancelSupportKind_out.prototype.status = 0;
    
                /**
                 * CancelSupportKind_out cancelSupportLevel.
                 * @member {Array.<CS.CancelSupportLevel>} cancelSupportLevel
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @instance
                 */
                CancelSupportKind_out.prototype.cancelSupportLevel = $util.emptyArray;
    
                /**
                 * CancelSupportKind_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @instance
                 */
                CancelSupportKind_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new CancelSupportKind_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {CS.PROTO.ICancelSupportKind_out=} [properties] Properties to set
                 * @returns {CS.PROTO.CancelSupportKind_out} CancelSupportKind_out instance
                 */
                CancelSupportKind_out.create = function create(properties) {
                    return new CancelSupportKind_out(properties);
                };
    
                /**
                 * Encodes the specified CancelSupportKind_out message. Does not implicitly {@link CS.PROTO.CancelSupportKind_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {CS.PROTO.ICancelSupportKind_out} message CancelSupportKind_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CancelSupportKind_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.cancelSupportLevel != null && message.cancelSupportLevel.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.cancelSupportLevel.length; ++i)
                            writer.int32(message.cancelSupportLevel[i]);
                        writer.ldelim();
                    }
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CancelSupportKind_out message, length delimited. Does not implicitly {@link CS.PROTO.CancelSupportKind_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {CS.PROTO.ICancelSupportKind_out} message CancelSupportKind_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CancelSupportKind_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CancelSupportKind_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CancelSupportKind_out} CancelSupportKind_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CancelSupportKind_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CancelSupportKind_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.cancelSupportLevel && message.cancelSupportLevel.length))
                                message.cancelSupportLevel = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.cancelSupportLevel.push(reader.int32());
                            } else
                                message.cancelSupportLevel.push(reader.int32());
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CancelSupportKind_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CancelSupportKind_out} CancelSupportKind_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CancelSupportKind_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CancelSupportKind_out message.
                 * @function verify
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CancelSupportKind_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.cancelSupportLevel != null && message.hasOwnProperty("cancelSupportLevel")) {
                        if (!Array.isArray(message.cancelSupportLevel))
                            return "cancelSupportLevel: array expected";
                        for (var i = 0; i < message.cancelSupportLevel.length; ++i)
                            switch (message.cancelSupportLevel[i]) {
                            default:
                                return "cancelSupportLevel: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CancelSupportKind_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CancelSupportKind_out} CancelSupportKind_out
                 */
                CancelSupportKind_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CancelSupportKind_out)
                        return object;
                    var message = new $root.CS.PROTO.CancelSupportKind_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.cancelSupportLevel) {
                        if (!Array.isArray(object.cancelSupportLevel))
                            throw TypeError(".CS.PROTO.CancelSupportKind_out.cancelSupportLevel: array expected");
                        message.cancelSupportLevel = [];
                        for (var i = 0; i < object.cancelSupportLevel.length; ++i)
                            switch (object.cancelSupportLevel[i]) {
                            default:
                            case "Unknown_CancelSupportLevel":
                            case 0:
                                message.cancelSupportLevel[i] = 0;
                                break;
                            case "Describe":
                            case 1:
                                message.cancelSupportLevel[i] = 1;
                                break;
                            case "Execute":
                            case 2:
                                message.cancelSupportLevel[i] = 2;
                                break;
                            case "Fetch":
                            case 3:
                                message.cancelSupportLevel[i] = 3;
                                break;
                            }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.CancelSupportKind_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.CancelSupportKind_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CancelSupportKind_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @static
                 * @param {CS.PROTO.CancelSupportKind_out} message CancelSupportKind_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CancelSupportKind_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.cancelSupportLevel = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.cancelSupportLevel && message.cancelSupportLevel.length) {
                        object.cancelSupportLevel = [];
                        for (var j = 0; j < message.cancelSupportLevel.length; ++j)
                            object.cancelSupportLevel[j] = options.enums === String ? $root.CS.CancelSupportLevel[message.cancelSupportLevel[j]] : message.cancelSupportLevel[j];
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CancelSupportKind_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CancelSupportKind_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CancelSupportKind_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CancelSupportKind_out;
            })();
    
            /**
             * DictionaryProperties_call enum.
             * @name CS.PROTO.DictionaryProperties_call
             * @enum {number}
             * @property {number} Unknown_DictionaryProperties_call=0 Unknown_DictionaryProperties_call value
             * @property {number} DictionaryProperties_call_E=1 DictionaryProperties_call_E value
             * @property {number} DictionaryProperties_call_S=2 DictionaryProperties_call_S value
             * @property {number} DictionaryProperties_call_M=3 DictionaryProperties_call_M value
             * @property {number} DictionaryProperties_call_LS=4 DictionaryProperties_call_LS value
             * @property {number} DictionaryProperties_call_LM=5 DictionaryProperties_call_LM value
             * @property {number} DictionaryProperties_call_L=6 DictionaryProperties_call_L value
             */
            PROTO.DictionaryProperties_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_DictionaryProperties_call"] = 0;
                values[valuesById[1] = "DictionaryProperties_call_E"] = 1;
                values[valuesById[2] = "DictionaryProperties_call_S"] = 2;
                values[valuesById[3] = "DictionaryProperties_call_M"] = 3;
                values[valuesById[4] = "DictionaryProperties_call_LS"] = 4;
                values[valuesById[5] = "DictionaryProperties_call_LM"] = 5;
                values[valuesById[6] = "DictionaryProperties_call_L"] = 6;
                return values;
            })();
    
            PROTO.ClientParam = (function() {
    
                /**
                 * Properties of a ClientParam.
                 * @memberof CS.PROTO
                 * @interface IClientParam
                 * @property {string|null} [key] ClientParam key
                 * @property {string|null} [value] ClientParam value
                 */
    
                /**
                 * Constructs a new ClientParam.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ClientParam.
                 * @implements IClientParam
                 * @constructor
                 * @param {CS.PROTO.IClientParam=} [properties] Properties to set
                 */
                function ClientParam(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ClientParam key.
                 * @member {string} key
                 * @memberof CS.PROTO.ClientParam
                 * @instance
                 */
                ClientParam.prototype.key = "";
    
                /**
                 * ClientParam value.
                 * @member {string} value
                 * @memberof CS.PROTO.ClientParam
                 * @instance
                 */
                ClientParam.prototype.value = "";
    
                /**
                 * Creates a new ClientParam instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {CS.PROTO.IClientParam=} [properties] Properties to set
                 * @returns {CS.PROTO.ClientParam} ClientParam instance
                 */
                ClientParam.create = function create(properties) {
                    return new ClientParam(properties);
                };
    
                /**
                 * Encodes the specified ClientParam message. Does not implicitly {@link CS.PROTO.ClientParam.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {CS.PROTO.IClientParam} message ClientParam message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClientParam.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified ClientParam message, length delimited. Does not implicitly {@link CS.PROTO.ClientParam.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {CS.PROTO.IClientParam} message ClientParam message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClientParam.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ClientParam message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ClientParam} ClientParam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClientParam.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ClientParam();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ClientParam message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ClientParam} ClientParam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClientParam.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ClientParam message.
                 * @function verify
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClientParam.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };
    
                /**
                 * Creates a ClientParam message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ClientParam} ClientParam
                 */
                ClientParam.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ClientParam)
                        return object;
                    var message = new $root.CS.PROTO.ClientParam();
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ClientParam message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ClientParam
                 * @static
                 * @param {CS.PROTO.ClientParam} message ClientParam
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClientParam.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.key = "";
                        object.value = "";
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this ClientParam to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ClientParam
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClientParam.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ClientParam;
            })();
    
            PROTO.DictionaryProperties_in = (function() {
    
                /**
                 * Properties of a DictionaryProperties_in.
                 * @memberof CS.PROTO
                 * @interface IDictionaryProperties_in
                 * @property {CS.PROTO.IAPIService|null} [control] DictionaryProperties_in control
                 * @property {CS.PROTO.DictionaryProperties_call|null} [method] DictionaryProperties_in method
                 * @property {string|null} [paramString] DictionaryProperties_in paramString
                 * @property {CS.ILocaleDescriptor|null} [locale] DictionaryProperties_in locale
                 * @property {Array.<CS.PROTO.IClientParam>|null} [clientParams] DictionaryProperties_in clientParams
                 */
    
                /**
                 * Constructs a new DictionaryProperties_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DictionaryProperties_in.
                 * @implements IDictionaryProperties_in
                 * @constructor
                 * @param {CS.PROTO.IDictionaryProperties_in=} [properties] Properties to set
                 */
                function DictionaryProperties_in(properties) {
                    this.clientParams = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DictionaryProperties_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @instance
                 */
                DictionaryProperties_in.prototype.control = null;
    
                /**
                 * DictionaryProperties_in method.
                 * @member {CS.PROTO.DictionaryProperties_call} method
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @instance
                 */
                DictionaryProperties_in.prototype.method = 0;
    
                /**
                 * DictionaryProperties_in paramString.
                 * @member {string} paramString
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @instance
                 */
                DictionaryProperties_in.prototype.paramString = "";
    
                /**
                 * DictionaryProperties_in locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @instance
                 */
                DictionaryProperties_in.prototype.locale = null;
    
                /**
                 * DictionaryProperties_in clientParams.
                 * @member {Array.<CS.PROTO.IClientParam>} clientParams
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @instance
                 */
                DictionaryProperties_in.prototype.clientParams = $util.emptyArray;
    
                /**
                 * Creates a new DictionaryProperties_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {CS.PROTO.IDictionaryProperties_in=} [properties] Properties to set
                 * @returns {CS.PROTO.DictionaryProperties_in} DictionaryProperties_in instance
                 */
                DictionaryProperties_in.create = function create(properties) {
                    return new DictionaryProperties_in(properties);
                };
    
                /**
                 * Encodes the specified DictionaryProperties_in message. Does not implicitly {@link CS.PROTO.DictionaryProperties_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {CS.PROTO.IDictionaryProperties_in} message DictionaryProperties_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProperties_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.paramString != null && Object.hasOwnProperty.call(message, "paramString"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.paramString);
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.clientParams != null && message.clientParams.length)
                        for (var i = 0; i < message.clientParams.length; ++i)
                            $root.CS.PROTO.ClientParam.encode(message.clientParams[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DictionaryProperties_in message, length delimited. Does not implicitly {@link CS.PROTO.DictionaryProperties_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {CS.PROTO.IDictionaryProperties_in} message DictionaryProperties_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProperties_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DictionaryProperties_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DictionaryProperties_in} DictionaryProperties_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProperties_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DictionaryProperties_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.paramString = reader.string();
                            break;
                        case 4:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.clientParams && message.clientParams.length))
                                message.clientParams = [];
                            message.clientParams.push($root.CS.PROTO.ClientParam.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DictionaryProperties_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DictionaryProperties_in} DictionaryProperties_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProperties_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DictionaryProperties_in message.
                 * @function verify
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DictionaryProperties_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.paramString != null && message.hasOwnProperty("paramString"))
                        if (!$util.isString(message.paramString))
                            return "paramString: string expected";
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    if (message.clientParams != null && message.hasOwnProperty("clientParams")) {
                        if (!Array.isArray(message.clientParams))
                            return "clientParams: array expected";
                        for (var i = 0; i < message.clientParams.length; ++i) {
                            var error = $root.CS.PROTO.ClientParam.verify(message.clientParams[i]);
                            if (error)
                                return "clientParams." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DictionaryProperties_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DictionaryProperties_in} DictionaryProperties_in
                 */
                DictionaryProperties_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DictionaryProperties_in)
                        return object;
                    var message = new $root.CS.PROTO.DictionaryProperties_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.DictionaryProperties_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_DictionaryProperties_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "DictionaryProperties_call_E":
                    case 1:
                        message.method = 1;
                        break;
                    case "DictionaryProperties_call_S":
                    case 2:
                        message.method = 2;
                        break;
                    case "DictionaryProperties_call_M":
                    case 3:
                        message.method = 3;
                        break;
                    case "DictionaryProperties_call_LS":
                    case 4:
                        message.method = 4;
                        break;
                    case "DictionaryProperties_call_LM":
                    case 5:
                        message.method = 5;
                        break;
                    case "DictionaryProperties_call_L":
                    case 6:
                        message.method = 6;
                        break;
                    }
                    if (object.paramString != null)
                        message.paramString = String(object.paramString);
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.DictionaryProperties_in.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    if (object.clientParams) {
                        if (!Array.isArray(object.clientParams))
                            throw TypeError(".CS.PROTO.DictionaryProperties_in.clientParams: array expected");
                        message.clientParams = [];
                        for (var i = 0; i < object.clientParams.length; ++i) {
                            if (typeof object.clientParams[i] !== "object")
                                throw TypeError(".CS.PROTO.DictionaryProperties_in.clientParams: object expected");
                            message.clientParams[i] = $root.CS.PROTO.ClientParam.fromObject(object.clientParams[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DictionaryProperties_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @static
                 * @param {CS.PROTO.DictionaryProperties_in} message DictionaryProperties_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DictionaryProperties_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.clientParams = [];
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_DictionaryProperties_call" : 0;
                        object.paramString = "";
                        object.locale = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.DictionaryProperties_call[message.method] : message.method;
                    if (message.paramString != null && message.hasOwnProperty("paramString"))
                        object.paramString = message.paramString;
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    if (message.clientParams && message.clientParams.length) {
                        object.clientParams = [];
                        for (var j = 0; j < message.clientParams.length; ++j)
                            object.clientParams[j] = $root.CS.PROTO.ClientParam.toObject(message.clientParams[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this DictionaryProperties_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DictionaryProperties_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DictionaryProperties_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictionaryProperties_in;
            })();
    
            PROTO.DictionaryProperties_out = (function() {
    
                /**
                 * Properties of a DictionaryProperties_out.
                 * @memberof CS.PROTO
                 * @interface IDictionaryProperties_out
                 * @property {CS.Status|null} [status] DictionaryProperties_out status
                 * @property {CS.IPropertySet|null} [props] DictionaryProperties_out props
                 * @property {Array.<CS.IError>|null} [errors] DictionaryProperties_out errors
                 */
    
                /**
                 * Constructs a new DictionaryProperties_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DictionaryProperties_out.
                 * @implements IDictionaryProperties_out
                 * @constructor
                 * @param {CS.PROTO.IDictionaryProperties_out=} [properties] Properties to set
                 */
                function DictionaryProperties_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DictionaryProperties_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @instance
                 */
                DictionaryProperties_out.prototype.status = 0;
    
                /**
                 * DictionaryProperties_out props.
                 * @member {CS.IPropertySet|null|undefined} props
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @instance
                 */
                DictionaryProperties_out.prototype.props = null;
    
                /**
                 * DictionaryProperties_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @instance
                 */
                DictionaryProperties_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new DictionaryProperties_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {CS.PROTO.IDictionaryProperties_out=} [properties] Properties to set
                 * @returns {CS.PROTO.DictionaryProperties_out} DictionaryProperties_out instance
                 */
                DictionaryProperties_out.create = function create(properties) {
                    return new DictionaryProperties_out(properties);
                };
    
                /**
                 * Encodes the specified DictionaryProperties_out message. Does not implicitly {@link CS.PROTO.DictionaryProperties_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {CS.PROTO.IDictionaryProperties_out} message DictionaryProperties_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProperties_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.props != null && Object.hasOwnProperty.call(message, "props"))
                        $root.CS.PropertySet.encode(message.props, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DictionaryProperties_out message, length delimited. Does not implicitly {@link CS.PROTO.DictionaryProperties_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {CS.PROTO.IDictionaryProperties_out} message DictionaryProperties_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProperties_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DictionaryProperties_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DictionaryProperties_out} DictionaryProperties_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProperties_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DictionaryProperties_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.props = $root.CS.PropertySet.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DictionaryProperties_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DictionaryProperties_out} DictionaryProperties_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProperties_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DictionaryProperties_out message.
                 * @function verify
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DictionaryProperties_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.props != null && message.hasOwnProperty("props")) {
                        var error = $root.CS.PropertySet.verify(message.props);
                        if (error)
                            return "props." + error;
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DictionaryProperties_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DictionaryProperties_out} DictionaryProperties_out
                 */
                DictionaryProperties_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DictionaryProperties_out)
                        return object;
                    var message = new $root.CS.PROTO.DictionaryProperties_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.props != null) {
                        if (typeof object.props !== "object")
                            throw TypeError(".CS.PROTO.DictionaryProperties_out.props: object expected");
                        message.props = $root.CS.PropertySet.fromObject(object.props);
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.DictionaryProperties_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.DictionaryProperties_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DictionaryProperties_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @static
                 * @param {CS.PROTO.DictionaryProperties_out} message DictionaryProperties_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DictionaryProperties_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.props = null;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.props != null && message.hasOwnProperty("props"))
                        object.props = $root.CS.PropertySet.toObject(message.props, options);
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this DictionaryProperties_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DictionaryProperties_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DictionaryProperties_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictionaryProperties_out;
            })();
    
            PROTO.SetClientInfo_in = (function() {
    
                /**
                 * Properties of a SetClientInfo_in.
                 * @memberof CS.PROTO
                 * @interface ISetClientInfo_in
                 * @property {CS.PROTO.IAPIService|null} [control] SetClientInfo_in control
                 * @property {string|null} [key] SetClientInfo_in key
                 * @property {string|null} [value] SetClientInfo_in value
                 */
    
                /**
                 * Constructs a new SetClientInfo_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a SetClientInfo_in.
                 * @implements ISetClientInfo_in
                 * @constructor
                 * @param {CS.PROTO.ISetClientInfo_in=} [properties] Properties to set
                 */
                function SetClientInfo_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetClientInfo_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @instance
                 */
                SetClientInfo_in.prototype.control = null;
    
                /**
                 * SetClientInfo_in key.
                 * @member {string} key
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @instance
                 */
                SetClientInfo_in.prototype.key = "";
    
                /**
                 * SetClientInfo_in value.
                 * @member {string} value
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @instance
                 */
                SetClientInfo_in.prototype.value = "";
    
                /**
                 * Creates a new SetClientInfo_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {CS.PROTO.ISetClientInfo_in=} [properties] Properties to set
                 * @returns {CS.PROTO.SetClientInfo_in} SetClientInfo_in instance
                 */
                SetClientInfo_in.create = function create(properties) {
                    return new SetClientInfo_in(properties);
                };
    
                /**
                 * Encodes the specified SetClientInfo_in message. Does not implicitly {@link CS.PROTO.SetClientInfo_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {CS.PROTO.ISetClientInfo_in} message SetClientInfo_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetClientInfo_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified SetClientInfo_in message, length delimited. Does not implicitly {@link CS.PROTO.SetClientInfo_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {CS.PROTO.ISetClientInfo_in} message SetClientInfo_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetClientInfo_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SetClientInfo_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.SetClientInfo_in} SetClientInfo_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetClientInfo_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.SetClientInfo_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.string();
                            break;
                        case 3:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SetClientInfo_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.SetClientInfo_in} SetClientInfo_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetClientInfo_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SetClientInfo_in message.
                 * @function verify
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SetClientInfo_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };
    
                /**
                 * Creates a SetClientInfo_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.SetClientInfo_in} SetClientInfo_in
                 */
                SetClientInfo_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.SetClientInfo_in)
                        return object;
                    var message = new $root.CS.PROTO.SetClientInfo_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.SetClientInfo_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a SetClientInfo_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @static
                 * @param {CS.PROTO.SetClientInfo_in} message SetClientInfo_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetClientInfo_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.key = "";
                        object.value = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this SetClientInfo_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.SetClientInfo_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SetClientInfo_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SetClientInfo_in;
            })();
    
            PROTO.SetClientInfo_out = (function() {
    
                /**
                 * Properties of a SetClientInfo_out.
                 * @memberof CS.PROTO
                 * @interface ISetClientInfo_out
                 * @property {CS.Status|null} [status] SetClientInfo_out status
                 * @property {Array.<CS.IError>|null} [errors] SetClientInfo_out errors
                 */
    
                /**
                 * Constructs a new SetClientInfo_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a SetClientInfo_out.
                 * @implements ISetClientInfo_out
                 * @constructor
                 * @param {CS.PROTO.ISetClientInfo_out=} [properties] Properties to set
                 */
                function SetClientInfo_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetClientInfo_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @instance
                 */
                SetClientInfo_out.prototype.status = 0;
    
                /**
                 * SetClientInfo_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @instance
                 */
                SetClientInfo_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new SetClientInfo_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {CS.PROTO.ISetClientInfo_out=} [properties] Properties to set
                 * @returns {CS.PROTO.SetClientInfo_out} SetClientInfo_out instance
                 */
                SetClientInfo_out.create = function create(properties) {
                    return new SetClientInfo_out(properties);
                };
    
                /**
                 * Encodes the specified SetClientInfo_out message. Does not implicitly {@link CS.PROTO.SetClientInfo_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {CS.PROTO.ISetClientInfo_out} message SetClientInfo_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetClientInfo_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SetClientInfo_out message, length delimited. Does not implicitly {@link CS.PROTO.SetClientInfo_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {CS.PROTO.ISetClientInfo_out} message SetClientInfo_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetClientInfo_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SetClientInfo_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.SetClientInfo_out} SetClientInfo_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetClientInfo_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.SetClientInfo_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SetClientInfo_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.SetClientInfo_out} SetClientInfo_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetClientInfo_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SetClientInfo_out message.
                 * @function verify
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SetClientInfo_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SetClientInfo_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.SetClientInfo_out} SetClientInfo_out
                 */
                SetClientInfo_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.SetClientInfo_out)
                        return object;
                    var message = new $root.CS.PROTO.SetClientInfo_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.SetClientInfo_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.SetClientInfo_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SetClientInfo_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @static
                 * @param {CS.PROTO.SetClientInfo_out} message SetClientInfo_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetClientInfo_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SetClientInfo_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.SetClientInfo_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SetClientInfo_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SetClientInfo_out;
            })();
    
            PROTO.GetClientInfo_in = (function() {
    
                /**
                 * Properties of a GetClientInfo_in.
                 * @memberof CS.PROTO
                 * @interface IGetClientInfo_in
                 * @property {CS.PROTO.IAPIService|null} [control] GetClientInfo_in control
                 * @property {string|null} [key] GetClientInfo_in key
                 */
    
                /**
                 * Constructs a new GetClientInfo_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a GetClientInfo_in.
                 * @implements IGetClientInfo_in
                 * @constructor
                 * @param {CS.PROTO.IGetClientInfo_in=} [properties] Properties to set
                 */
                function GetClientInfo_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetClientInfo_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @instance
                 */
                GetClientInfo_in.prototype.control = null;
    
                /**
                 * GetClientInfo_in key.
                 * @member {string} key
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @instance
                 */
                GetClientInfo_in.prototype.key = "";
    
                /**
                 * Creates a new GetClientInfo_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {CS.PROTO.IGetClientInfo_in=} [properties] Properties to set
                 * @returns {CS.PROTO.GetClientInfo_in} GetClientInfo_in instance
                 */
                GetClientInfo_in.create = function create(properties) {
                    return new GetClientInfo_in(properties);
                };
    
                /**
                 * Encodes the specified GetClientInfo_in message. Does not implicitly {@link CS.PROTO.GetClientInfo_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {CS.PROTO.IGetClientInfo_in} message GetClientInfo_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetClientInfo_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                    return writer;
                };
    
                /**
                 * Encodes the specified GetClientInfo_in message, length delimited. Does not implicitly {@link CS.PROTO.GetClientInfo_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {CS.PROTO.IGetClientInfo_in} message GetClientInfo_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetClientInfo_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GetClientInfo_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.GetClientInfo_in} GetClientInfo_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetClientInfo_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.GetClientInfo_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GetClientInfo_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.GetClientInfo_in} GetClientInfo_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetClientInfo_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GetClientInfo_in message.
                 * @function verify
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetClientInfo_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    return null;
                };
    
                /**
                 * Creates a GetClientInfo_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.GetClientInfo_in} GetClientInfo_in
                 */
                GetClientInfo_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.GetClientInfo_in)
                        return object;
                    var message = new $root.CS.PROTO.GetClientInfo_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.GetClientInfo_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.key != null)
                        message.key = String(object.key);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GetClientInfo_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @static
                 * @param {CS.PROTO.GetClientInfo_in} message GetClientInfo_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetClientInfo_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.key = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    return object;
                };
    
                /**
                 * Converts this GetClientInfo_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.GetClientInfo_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetClientInfo_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GetClientInfo_in;
            })();
    
            PROTO.GetClientInfo_out = (function() {
    
                /**
                 * Properties of a GetClientInfo_out.
                 * @memberof CS.PROTO
                 * @interface IGetClientInfo_out
                 * @property {CS.Status|null} [status] GetClientInfo_out status
                 * @property {string|null} [value] GetClientInfo_out value
                 * @property {Array.<CS.IError>|null} [errors] GetClientInfo_out errors
                 */
    
                /**
                 * Constructs a new GetClientInfo_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a GetClientInfo_out.
                 * @implements IGetClientInfo_out
                 * @constructor
                 * @param {CS.PROTO.IGetClientInfo_out=} [properties] Properties to set
                 */
                function GetClientInfo_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetClientInfo_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @instance
                 */
                GetClientInfo_out.prototype.status = 0;
    
                /**
                 * GetClientInfo_out value.
                 * @member {string} value
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @instance
                 */
                GetClientInfo_out.prototype.value = "";
    
                /**
                 * GetClientInfo_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @instance
                 */
                GetClientInfo_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new GetClientInfo_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {CS.PROTO.IGetClientInfo_out=} [properties] Properties to set
                 * @returns {CS.PROTO.GetClientInfo_out} GetClientInfo_out instance
                 */
                GetClientInfo_out.create = function create(properties) {
                    return new GetClientInfo_out(properties);
                };
    
                /**
                 * Encodes the specified GetClientInfo_out message. Does not implicitly {@link CS.PROTO.GetClientInfo_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {CS.PROTO.IGetClientInfo_out} message GetClientInfo_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetClientInfo_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GetClientInfo_out message, length delimited. Does not implicitly {@link CS.PROTO.GetClientInfo_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {CS.PROTO.IGetClientInfo_out} message GetClientInfo_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetClientInfo_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GetClientInfo_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.GetClientInfo_out} GetClientInfo_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetClientInfo_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.GetClientInfo_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GetClientInfo_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.GetClientInfo_out} GetClientInfo_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetClientInfo_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GetClientInfo_out message.
                 * @function verify
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetClientInfo_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GetClientInfo_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.GetClientInfo_out} GetClientInfo_out
                 */
                GetClientInfo_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.GetClientInfo_out)
                        return object;
                    var message = new $root.CS.PROTO.GetClientInfo_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.value != null)
                        message.value = String(object.value);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.GetClientInfo_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.GetClientInfo_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GetClientInfo_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @static
                 * @param {CS.PROTO.GetClientInfo_out} message GetClientInfo_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetClientInfo_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.value = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GetClientInfo_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.GetClientInfo_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetClientInfo_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GetClientInfo_out;
            })();
    
            PROTO.Ping_in = (function() {
    
                /**
                 * Properties of a Ping_in.
                 * @memberof CS.PROTO
                 * @interface IPing_in
                 * @property {CS.PROTO.IAPIService|null} [control] Ping_in control
                 */
    
                /**
                 * Constructs a new Ping_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Ping_in.
                 * @implements IPing_in
                 * @constructor
                 * @param {CS.PROTO.IPing_in=} [properties] Properties to set
                 */
                function Ping_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Ping_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Ping_in
                 * @instance
                 */
                Ping_in.prototype.control = null;
    
                /**
                 * Creates a new Ping_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {CS.PROTO.IPing_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Ping_in} Ping_in instance
                 */
                Ping_in.create = function create(properties) {
                    return new Ping_in(properties);
                };
    
                /**
                 * Encodes the specified Ping_in message. Does not implicitly {@link CS.PROTO.Ping_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {CS.PROTO.IPing_in} message Ping_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ping_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Ping_in message, length delimited. Does not implicitly {@link CS.PROTO.Ping_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {CS.PROTO.IPing_in} message Ping_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ping_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Ping_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Ping_in} Ping_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ping_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Ping_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Ping_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Ping_in} Ping_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ping_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Ping_in message.
                 * @function verify
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ping_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Ping_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Ping_in} Ping_in
                 */
                Ping_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Ping_in)
                        return object;
                    var message = new $root.CS.PROTO.Ping_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Ping_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Ping_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Ping_in
                 * @static
                 * @param {CS.PROTO.Ping_in} message Ping_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ping_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this Ping_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Ping_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ping_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Ping_in;
            })();
    
            PROTO.Ping_out = (function() {
    
                /**
                 * Properties of a Ping_out.
                 * @memberof CS.PROTO
                 * @interface IPing_out
                 * @property {CS.Status|null} [status] Ping_out status
                 * @property {Array.<CS.IError>|null} [errors] Ping_out errors
                 */
    
                /**
                 * Constructs a new Ping_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Ping_out.
                 * @implements IPing_out
                 * @constructor
                 * @param {CS.PROTO.IPing_out=} [properties] Properties to set
                 */
                function Ping_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Ping_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Ping_out
                 * @instance
                 */
                Ping_out.prototype.status = 0;
    
                /**
                 * Ping_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Ping_out
                 * @instance
                 */
                Ping_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Ping_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {CS.PROTO.IPing_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Ping_out} Ping_out instance
                 */
                Ping_out.create = function create(properties) {
                    return new Ping_out(properties);
                };
    
                /**
                 * Encodes the specified Ping_out message. Does not implicitly {@link CS.PROTO.Ping_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {CS.PROTO.IPing_out} message Ping_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ping_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Ping_out message, length delimited. Does not implicitly {@link CS.PROTO.Ping_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {CS.PROTO.IPing_out} message Ping_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ping_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Ping_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Ping_out} Ping_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ping_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Ping_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Ping_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Ping_out} Ping_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ping_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Ping_out message.
                 * @function verify
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ping_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Ping_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Ping_out} Ping_out
                 */
                Ping_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Ping_out)
                        return object;
                    var message = new $root.CS.PROTO.Ping_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Ping_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Ping_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Ping_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Ping_out
                 * @static
                 * @param {CS.PROTO.Ping_out} message Ping_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ping_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Ping_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Ping_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ping_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Ping_out;
            })();
    
            PROTO.PingInfo_in = (function() {
    
                /**
                 * Properties of a PingInfo_in.
                 * @memberof CS.PROTO
                 * @interface IPingInfo_in
                 * @property {CS.PROTO.IAPIService|null} [control] PingInfo_in control
                 */
    
                /**
                 * Constructs a new PingInfo_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a PingInfo_in.
                 * @implements IPingInfo_in
                 * @constructor
                 * @param {CS.PROTO.IPingInfo_in=} [properties] Properties to set
                 */
                function PingInfo_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PingInfo_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.PingInfo_in
                 * @instance
                 */
                PingInfo_in.prototype.control = null;
    
                /**
                 * Creates a new PingInfo_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {CS.PROTO.IPingInfo_in=} [properties] Properties to set
                 * @returns {CS.PROTO.PingInfo_in} PingInfo_in instance
                 */
                PingInfo_in.create = function create(properties) {
                    return new PingInfo_in(properties);
                };
    
                /**
                 * Encodes the specified PingInfo_in message. Does not implicitly {@link CS.PROTO.PingInfo_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {CS.PROTO.IPingInfo_in} message PingInfo_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingInfo_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PingInfo_in message, length delimited. Does not implicitly {@link CS.PROTO.PingInfo_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {CS.PROTO.IPingInfo_in} message PingInfo_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingInfo_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PingInfo_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.PingInfo_in} PingInfo_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingInfo_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.PingInfo_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PingInfo_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.PingInfo_in} PingInfo_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingInfo_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PingInfo_in message.
                 * @function verify
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PingInfo_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a PingInfo_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.PingInfo_in} PingInfo_in
                 */
                PingInfo_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.PingInfo_in)
                        return object;
                    var message = new $root.CS.PROTO.PingInfo_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.PingInfo_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PingInfo_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.PingInfo_in
                 * @static
                 * @param {CS.PROTO.PingInfo_in} message PingInfo_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PingInfo_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this PingInfo_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.PingInfo_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PingInfo_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PingInfo_in;
            })();
    
            PROTO.PingInfo_out = (function() {
    
                /**
                 * Properties of a PingInfo_out.
                 * @memberof CS.PROTO
                 * @interface IPingInfo_out
                 * @property {CS.Status|null} [status] PingInfo_out status
                 * @property {string|null} [pingInfo] PingInfo_out pingInfo
                 * @property {Array.<CS.IError>|null} [errors] PingInfo_out errors
                 */
    
                /**
                 * Constructs a new PingInfo_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a PingInfo_out.
                 * @implements IPingInfo_out
                 * @constructor
                 * @param {CS.PROTO.IPingInfo_out=} [properties] Properties to set
                 */
                function PingInfo_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PingInfo_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.PingInfo_out
                 * @instance
                 */
                PingInfo_out.prototype.status = 0;
    
                /**
                 * PingInfo_out pingInfo.
                 * @member {string} pingInfo
                 * @memberof CS.PROTO.PingInfo_out
                 * @instance
                 */
                PingInfo_out.prototype.pingInfo = "";
    
                /**
                 * PingInfo_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.PingInfo_out
                 * @instance
                 */
                PingInfo_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new PingInfo_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {CS.PROTO.IPingInfo_out=} [properties] Properties to set
                 * @returns {CS.PROTO.PingInfo_out} PingInfo_out instance
                 */
                PingInfo_out.create = function create(properties) {
                    return new PingInfo_out(properties);
                };
    
                /**
                 * Encodes the specified PingInfo_out message. Does not implicitly {@link CS.PROTO.PingInfo_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {CS.PROTO.IPingInfo_out} message PingInfo_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingInfo_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.pingInfo != null && Object.hasOwnProperty.call(message, "pingInfo"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.pingInfo);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PingInfo_out message, length delimited. Does not implicitly {@link CS.PROTO.PingInfo_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {CS.PROTO.IPingInfo_out} message PingInfo_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingInfo_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PingInfo_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.PingInfo_out} PingInfo_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingInfo_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.PingInfo_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.pingInfo = reader.string();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PingInfo_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.PingInfo_out} PingInfo_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingInfo_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PingInfo_out message.
                 * @function verify
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PingInfo_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.pingInfo != null && message.hasOwnProperty("pingInfo"))
                        if (!$util.isString(message.pingInfo))
                            return "pingInfo: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a PingInfo_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.PingInfo_out} PingInfo_out
                 */
                PingInfo_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.PingInfo_out)
                        return object;
                    var message = new $root.CS.PROTO.PingInfo_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.pingInfo != null)
                        message.pingInfo = String(object.pingInfo);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.PingInfo_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.PingInfo_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PingInfo_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.PingInfo_out
                 * @static
                 * @param {CS.PROTO.PingInfo_out} message PingInfo_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PingInfo_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.pingInfo = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.pingInfo != null && message.hasOwnProperty("pingInfo"))
                        object.pingInfo = message.pingInfo;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this PingInfo_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.PingInfo_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PingInfo_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PingInfo_out;
            })();
    
            PROTO.Abort_in = (function() {
    
                /**
                 * Properties of an Abort_in.
                 * @memberof CS.PROTO
                 * @interface IAbort_in
                 * @property {CS.PROTO.IAPIService|null} [control] Abort_in control
                 */
    
                /**
                 * Constructs a new Abort_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an Abort_in.
                 * @implements IAbort_in
                 * @constructor
                 * @param {CS.PROTO.IAbort_in=} [properties] Properties to set
                 */
                function Abort_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Abort_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Abort_in
                 * @instance
                 */
                Abort_in.prototype.control = null;
    
                /**
                 * Creates a new Abort_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {CS.PROTO.IAbort_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Abort_in} Abort_in instance
                 */
                Abort_in.create = function create(properties) {
                    return new Abort_in(properties);
                };
    
                /**
                 * Encodes the specified Abort_in message. Does not implicitly {@link CS.PROTO.Abort_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {CS.PROTO.IAbort_in} message Abort_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Abort_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Abort_in message, length delimited. Does not implicitly {@link CS.PROTO.Abort_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {CS.PROTO.IAbort_in} message Abort_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Abort_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Abort_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Abort_in} Abort_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Abort_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Abort_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Abort_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Abort_in} Abort_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Abort_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Abort_in message.
                 * @function verify
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Abort_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an Abort_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Abort_in} Abort_in
                 */
                Abort_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Abort_in)
                        return object;
                    var message = new $root.CS.PROTO.Abort_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Abort_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Abort_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Abort_in
                 * @static
                 * @param {CS.PROTO.Abort_in} message Abort_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Abort_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this Abort_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Abort_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Abort_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Abort_in;
            })();
    
            PROTO.Abort_out = (function() {
    
                /**
                 * Properties of an Abort_out.
                 * @memberof CS.PROTO
                 * @interface IAbort_out
                 * @property {CS.Status|null} [status] Abort_out status
                 * @property {Array.<CS.IError>|null} [errors] Abort_out errors
                 */
    
                /**
                 * Constructs a new Abort_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an Abort_out.
                 * @implements IAbort_out
                 * @constructor
                 * @param {CS.PROTO.IAbort_out=} [properties] Properties to set
                 */
                function Abort_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Abort_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Abort_out
                 * @instance
                 */
                Abort_out.prototype.status = 0;
    
                /**
                 * Abort_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Abort_out
                 * @instance
                 */
                Abort_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Abort_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {CS.PROTO.IAbort_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Abort_out} Abort_out instance
                 */
                Abort_out.create = function create(properties) {
                    return new Abort_out(properties);
                };
    
                /**
                 * Encodes the specified Abort_out message. Does not implicitly {@link CS.PROTO.Abort_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {CS.PROTO.IAbort_out} message Abort_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Abort_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Abort_out message, length delimited. Does not implicitly {@link CS.PROTO.Abort_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {CS.PROTO.IAbort_out} message Abort_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Abort_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Abort_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Abort_out} Abort_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Abort_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Abort_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Abort_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Abort_out} Abort_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Abort_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Abort_out message.
                 * @function verify
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Abort_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Abort_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Abort_out} Abort_out
                 */
                Abort_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Abort_out)
                        return object;
                    var message = new $root.CS.PROTO.Abort_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Abort_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Abort_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Abort_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Abort_out
                 * @static
                 * @param {CS.PROTO.Abort_out} message Abort_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Abort_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Abort_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Abort_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Abort_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Abort_out;
            })();
    
            PROTO.CloseSession_in = (function() {
    
                /**
                 * Properties of a CloseSession_in.
                 * @memberof CS.PROTO
                 * @interface ICloseSession_in
                 * @property {CS.PROTO.IAPIService|null} [control] CloseSession_in control
                 */
    
                /**
                 * Constructs a new CloseSession_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CloseSession_in.
                 * @implements ICloseSession_in
                 * @constructor
                 * @param {CS.PROTO.ICloseSession_in=} [properties] Properties to set
                 */
                function CloseSession_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CloseSession_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.CloseSession_in
                 * @instance
                 */
                CloseSession_in.prototype.control = null;
    
                /**
                 * Creates a new CloseSession_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {CS.PROTO.ICloseSession_in=} [properties] Properties to set
                 * @returns {CS.PROTO.CloseSession_in} CloseSession_in instance
                 */
                CloseSession_in.create = function create(properties) {
                    return new CloseSession_in(properties);
                };
    
                /**
                 * Encodes the specified CloseSession_in message. Does not implicitly {@link CS.PROTO.CloseSession_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {CS.PROTO.ICloseSession_in} message CloseSession_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseSession_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CloseSession_in message, length delimited. Does not implicitly {@link CS.PROTO.CloseSession_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {CS.PROTO.ICloseSession_in} message CloseSession_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseSession_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CloseSession_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CloseSession_in} CloseSession_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseSession_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CloseSession_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CloseSession_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CloseSession_in} CloseSession_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseSession_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CloseSession_in message.
                 * @function verify
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CloseSession_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a CloseSession_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CloseSession_in} CloseSession_in
                 */
                CloseSession_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CloseSession_in)
                        return object;
                    var message = new $root.CS.PROTO.CloseSession_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.CloseSession_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CloseSession_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CloseSession_in
                 * @static
                 * @param {CS.PROTO.CloseSession_in} message CloseSession_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CloseSession_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this CloseSession_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CloseSession_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CloseSession_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CloseSession_in;
            })();
    
            PROTO.CloseSession_out = (function() {
    
                /**
                 * Properties of a CloseSession_out.
                 * @memberof CS.PROTO
                 * @interface ICloseSession_out
                 * @property {CS.Status|null} [status] CloseSession_out status
                 * @property {Array.<CS.IError>|null} [errors] CloseSession_out errors
                 */
    
                /**
                 * Constructs a new CloseSession_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CloseSession_out.
                 * @implements ICloseSession_out
                 * @constructor
                 * @param {CS.PROTO.ICloseSession_out=} [properties] Properties to set
                 */
                function CloseSession_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CloseSession_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.CloseSession_out
                 * @instance
                 */
                CloseSession_out.prototype.status = 0;
    
                /**
                 * CloseSession_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.CloseSession_out
                 * @instance
                 */
                CloseSession_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new CloseSession_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {CS.PROTO.ICloseSession_out=} [properties] Properties to set
                 * @returns {CS.PROTO.CloseSession_out} CloseSession_out instance
                 */
                CloseSession_out.create = function create(properties) {
                    return new CloseSession_out(properties);
                };
    
                /**
                 * Encodes the specified CloseSession_out message. Does not implicitly {@link CS.PROTO.CloseSession_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {CS.PROTO.ICloseSession_out} message CloseSession_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseSession_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CloseSession_out message, length delimited. Does not implicitly {@link CS.PROTO.CloseSession_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {CS.PROTO.ICloseSession_out} message CloseSession_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseSession_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CloseSession_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CloseSession_out} CloseSession_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseSession_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CloseSession_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CloseSession_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CloseSession_out} CloseSession_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseSession_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CloseSession_out message.
                 * @function verify
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CloseSession_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CloseSession_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CloseSession_out} CloseSession_out
                 */
                CloseSession_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CloseSession_out)
                        return object;
                    var message = new $root.CS.PROTO.CloseSession_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.CloseSession_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.CloseSession_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CloseSession_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CloseSession_out
                 * @static
                 * @param {CS.PROTO.CloseSession_out} message CloseSession_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CloseSession_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CloseSession_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CloseSession_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CloseSession_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CloseSession_out;
            })();
    
            PROTO.CloseObject_in = (function() {
    
                /**
                 * Properties of a CloseObject_in.
                 * @memberof CS.PROTO
                 * @interface ICloseObject_in
                 * @property {CS.PROTO.IAPIService|null} [control] CloseObject_in control
                 */
    
                /**
                 * Constructs a new CloseObject_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CloseObject_in.
                 * @implements ICloseObject_in
                 * @constructor
                 * @param {CS.PROTO.ICloseObject_in=} [properties] Properties to set
                 */
                function CloseObject_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CloseObject_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.CloseObject_in
                 * @instance
                 */
                CloseObject_in.prototype.control = null;
    
                /**
                 * Creates a new CloseObject_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {CS.PROTO.ICloseObject_in=} [properties] Properties to set
                 * @returns {CS.PROTO.CloseObject_in} CloseObject_in instance
                 */
                CloseObject_in.create = function create(properties) {
                    return new CloseObject_in(properties);
                };
    
                /**
                 * Encodes the specified CloseObject_in message. Does not implicitly {@link CS.PROTO.CloseObject_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {CS.PROTO.ICloseObject_in} message CloseObject_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseObject_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CloseObject_in message, length delimited. Does not implicitly {@link CS.PROTO.CloseObject_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {CS.PROTO.ICloseObject_in} message CloseObject_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseObject_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CloseObject_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CloseObject_in} CloseObject_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseObject_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CloseObject_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CloseObject_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CloseObject_in} CloseObject_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseObject_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CloseObject_in message.
                 * @function verify
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CloseObject_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a CloseObject_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CloseObject_in} CloseObject_in
                 */
                CloseObject_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CloseObject_in)
                        return object;
                    var message = new $root.CS.PROTO.CloseObject_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.CloseObject_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CloseObject_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CloseObject_in
                 * @static
                 * @param {CS.PROTO.CloseObject_in} message CloseObject_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CloseObject_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this CloseObject_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CloseObject_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CloseObject_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CloseObject_in;
            })();
    
            PROTO.CloseObject_out = (function() {
    
                /**
                 * Properties of a CloseObject_out.
                 * @memberof CS.PROTO
                 * @interface ICloseObject_out
                 * @property {CS.Status|null} [status] CloseObject_out status
                 * @property {Array.<CS.IError>|null} [errors] CloseObject_out errors
                 */
    
                /**
                 * Constructs a new CloseObject_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CloseObject_out.
                 * @implements ICloseObject_out
                 * @constructor
                 * @param {CS.PROTO.ICloseObject_out=} [properties] Properties to set
                 */
                function CloseObject_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CloseObject_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.CloseObject_out
                 * @instance
                 */
                CloseObject_out.prototype.status = 0;
    
                /**
                 * CloseObject_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.CloseObject_out
                 * @instance
                 */
                CloseObject_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new CloseObject_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {CS.PROTO.ICloseObject_out=} [properties] Properties to set
                 * @returns {CS.PROTO.CloseObject_out} CloseObject_out instance
                 */
                CloseObject_out.create = function create(properties) {
                    return new CloseObject_out(properties);
                };
    
                /**
                 * Encodes the specified CloseObject_out message. Does not implicitly {@link CS.PROTO.CloseObject_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {CS.PROTO.ICloseObject_out} message CloseObject_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseObject_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CloseObject_out message, length delimited. Does not implicitly {@link CS.PROTO.CloseObject_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {CS.PROTO.ICloseObject_out} message CloseObject_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseObject_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CloseObject_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CloseObject_out} CloseObject_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseObject_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CloseObject_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CloseObject_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CloseObject_out} CloseObject_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseObject_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CloseObject_out message.
                 * @function verify
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CloseObject_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CloseObject_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CloseObject_out} CloseObject_out
                 */
                CloseObject_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CloseObject_out)
                        return object;
                    var message = new $root.CS.PROTO.CloseObject_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.CloseObject_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.CloseObject_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CloseObject_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CloseObject_out
                 * @static
                 * @param {CS.PROTO.CloseObject_out} message CloseObject_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CloseObject_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CloseObject_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CloseObject_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CloseObject_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CloseObject_out;
            })();
    
            PROTO.CloseObjectService = (function() {
    
                /**
                 * Constructs a new CloseObjectService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CloseObjectService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function CloseObjectService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (CloseObjectService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CloseObjectService;
    
                /**
                 * Creates new CloseObjectService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.CloseObjectService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {CloseObjectService} RPC service. Useful where requests and/or responses are streamed.
                 */
                CloseObjectService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.CloseObjectService#closeSession}.
                 * @memberof CS.PROTO.CloseObjectService
                 * @typedef CloseSessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.CloseSession_out} [response] CloseSession_out
                 */
    
                /**
                 * Calls CloseSession.
                 * @function closeSession
                 * @memberof CS.PROTO.CloseObjectService
                 * @instance
                 * @param {CS.PROTO.ICloseSession_in} request CloseSession_in message or plain object
                 * @param {CS.PROTO.CloseObjectService.CloseSessionCallback} callback Node-style callback called with the error, if any, and CloseSession_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CloseObjectService.prototype.closeSession = function closeSession(request, callback) {
                    return this.rpcCall(closeSession, $root.CS.PROTO.CloseSession_in, $root.CS.PROTO.CloseSession_out, request, callback);
                }, "name", { value: "CloseSession" });
    
                /**
                 * Calls CloseSession.
                 * @function closeSession
                 * @memberof CS.PROTO.CloseObjectService
                 * @instance
                 * @param {CS.PROTO.ICloseSession_in} request CloseSession_in message or plain object
                 * @returns {Promise<CS.PROTO.CloseSession_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.CloseObjectService#closeObject}.
                 * @memberof CS.PROTO.CloseObjectService
                 * @typedef CloseObjectCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.CloseObject_out} [response] CloseObject_out
                 */
    
                /**
                 * Calls CloseObject.
                 * @function closeObject
                 * @memberof CS.PROTO.CloseObjectService
                 * @instance
                 * @param {CS.PROTO.ICloseObject_in} request CloseObject_in message or plain object
                 * @param {CS.PROTO.CloseObjectService.CloseObjectCallback} callback Node-style callback called with the error, if any, and CloseObject_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CloseObjectService.prototype.closeObject = function closeObject(request, callback) {
                    return this.rpcCall(closeObject, $root.CS.PROTO.CloseObject_in, $root.CS.PROTO.CloseObject_out, request, callback);
                }, "name", { value: "CloseObject" });
    
                /**
                 * Calls CloseObject.
                 * @function closeObject
                 * @memberof CS.PROTO.CloseObjectService
                 * @instance
                 * @param {CS.PROTO.ICloseObject_in} request CloseObject_in message or plain object
                 * @returns {Promise<CS.PROTO.CloseObject_out>} Promise
                 * @variation 2
                 */
    
                return CloseObjectService;
            })();
    
            PROTO.OpenSession_in = (function() {
    
                /**
                 * Properties of an OpenSession_in.
                 * @memberof CS.PROTO
                 * @interface IOpenSession_in
                 * @property {CS.PROTO.IAPIService|null} [control] OpenSession_in control
                 */
    
                /**
                 * Constructs a new OpenSession_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an OpenSession_in.
                 * @implements IOpenSession_in
                 * @constructor
                 * @param {CS.PROTO.IOpenSession_in=} [properties] Properties to set
                 */
                function OpenSession_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OpenSession_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.OpenSession_in
                 * @instance
                 */
                OpenSession_in.prototype.control = null;
    
                /**
                 * Creates a new OpenSession_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {CS.PROTO.IOpenSession_in=} [properties] Properties to set
                 * @returns {CS.PROTO.OpenSession_in} OpenSession_in instance
                 */
                OpenSession_in.create = function create(properties) {
                    return new OpenSession_in(properties);
                };
    
                /**
                 * Encodes the specified OpenSession_in message. Does not implicitly {@link CS.PROTO.OpenSession_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {CS.PROTO.IOpenSession_in} message OpenSession_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenSession_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OpenSession_in message, length delimited. Does not implicitly {@link CS.PROTO.OpenSession_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {CS.PROTO.IOpenSession_in} message OpenSession_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenSession_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OpenSession_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.OpenSession_in} OpenSession_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenSession_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.OpenSession_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OpenSession_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.OpenSession_in} OpenSession_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenSession_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OpenSession_in message.
                 * @function verify
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OpenSession_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an OpenSession_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.OpenSession_in} OpenSession_in
                 */
                OpenSession_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.OpenSession_in)
                        return object;
                    var message = new $root.CS.PROTO.OpenSession_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.OpenSession_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OpenSession_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.OpenSession_in
                 * @static
                 * @param {CS.PROTO.OpenSession_in} message OpenSession_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OpenSession_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this OpenSession_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.OpenSession_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OpenSession_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return OpenSession_in;
            })();
    
            PROTO.OpenSession_out = (function() {
    
                /**
                 * Properties of an OpenSession_out.
                 * @memberof CS.PROTO
                 * @interface IOpenSession_out
                 * @property {CS.Status|null} [status] OpenSession_out status
                 * @property {number|null} [id] OpenSession_out id
                 * @property {Array.<CS.IError>|null} [errors] OpenSession_out errors
                 */
    
                /**
                 * Constructs a new OpenSession_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an OpenSession_out.
                 * @implements IOpenSession_out
                 * @constructor
                 * @param {CS.PROTO.IOpenSession_out=} [properties] Properties to set
                 */
                function OpenSession_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OpenSession_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.OpenSession_out
                 * @instance
                 */
                OpenSession_out.prototype.status = 0;
    
                /**
                 * OpenSession_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.OpenSession_out
                 * @instance
                 */
                OpenSession_out.prototype.id = 0;
    
                /**
                 * OpenSession_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.OpenSession_out
                 * @instance
                 */
                OpenSession_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new OpenSession_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {CS.PROTO.IOpenSession_out=} [properties] Properties to set
                 * @returns {CS.PROTO.OpenSession_out} OpenSession_out instance
                 */
                OpenSession_out.create = function create(properties) {
                    return new OpenSession_out(properties);
                };
    
                /**
                 * Encodes the specified OpenSession_out message. Does not implicitly {@link CS.PROTO.OpenSession_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {CS.PROTO.IOpenSession_out} message OpenSession_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenSession_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OpenSession_out message, length delimited. Does not implicitly {@link CS.PROTO.OpenSession_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {CS.PROTO.IOpenSession_out} message OpenSession_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenSession_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OpenSession_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.OpenSession_out} OpenSession_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenSession_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.OpenSession_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OpenSession_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.OpenSession_out} OpenSession_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenSession_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OpenSession_out message.
                 * @function verify
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OpenSession_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an OpenSession_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.OpenSession_out} OpenSession_out
                 */
                OpenSession_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.OpenSession_out)
                        return object;
                    var message = new $root.CS.PROTO.OpenSession_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.OpenSession_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.OpenSession_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OpenSession_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.OpenSession_out
                 * @static
                 * @param {CS.PROTO.OpenSession_out} message OpenSession_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OpenSession_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this OpenSession_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.OpenSession_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OpenSession_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return OpenSession_out;
            })();
    
            PROTO.NetworkLayers_in = (function() {
    
                /**
                 * Properties of a NetworkLayers_in.
                 * @memberof CS.PROTO
                 * @interface INetworkLayers_in
                 * @property {CS.PROTO.IAPIService|null} [control] NetworkLayers_in control
                 * @property {CS.ILocaleDescriptor|null} [locale] NetworkLayers_in locale
                 */
    
                /**
                 * Constructs a new NetworkLayers_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a NetworkLayers_in.
                 * @implements INetworkLayers_in
                 * @constructor
                 * @param {CS.PROTO.INetworkLayers_in=} [properties] Properties to set
                 */
                function NetworkLayers_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkLayers_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @instance
                 */
                NetworkLayers_in.prototype.control = null;
    
                /**
                 * NetworkLayers_in locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @instance
                 */
                NetworkLayers_in.prototype.locale = null;
    
                /**
                 * Creates a new NetworkLayers_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {CS.PROTO.INetworkLayers_in=} [properties] Properties to set
                 * @returns {CS.PROTO.NetworkLayers_in} NetworkLayers_in instance
                 */
                NetworkLayers_in.create = function create(properties) {
                    return new NetworkLayers_in(properties);
                };
    
                /**
                 * Encodes the specified NetworkLayers_in message. Does not implicitly {@link CS.PROTO.NetworkLayers_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {CS.PROTO.INetworkLayers_in} message NetworkLayers_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayers_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NetworkLayers_in message, length delimited. Does not implicitly {@link CS.PROTO.NetworkLayers_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {CS.PROTO.INetworkLayers_in} message NetworkLayers_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayers_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NetworkLayers_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.NetworkLayers_in} NetworkLayers_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayers_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.NetworkLayers_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NetworkLayers_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.NetworkLayers_in} NetworkLayers_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayers_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NetworkLayers_in message.
                 * @function verify
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NetworkLayers_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a NetworkLayers_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.NetworkLayers_in} NetworkLayers_in
                 */
                NetworkLayers_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.NetworkLayers_in)
                        return object;
                    var message = new $root.CS.PROTO.NetworkLayers_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.NetworkLayers_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.NetworkLayers_in.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NetworkLayers_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @static
                 * @param {CS.PROTO.NetworkLayers_in} message NetworkLayers_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NetworkLayers_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.locale = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    return object;
                };
    
                /**
                 * Converts this NetworkLayers_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.NetworkLayers_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NetworkLayers_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NetworkLayers_in;
            })();
    
            PROTO.NetworkLayers_out = (function() {
    
                /**
                 * Properties of a NetworkLayers_out.
                 * @memberof CS.PROTO
                 * @interface INetworkLayers_out
                 * @property {CS.Status|null} [status] NetworkLayers_out status
                 * @property {Array.<CS.INetworkLayerDescription>|null} [networkLayers] NetworkLayers_out networkLayers
                 * @property {Array.<CS.IError>|null} [errors] NetworkLayers_out errors
                 */
    
                /**
                 * Constructs a new NetworkLayers_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a NetworkLayers_out.
                 * @implements INetworkLayers_out
                 * @constructor
                 * @param {CS.PROTO.INetworkLayers_out=} [properties] Properties to set
                 */
                function NetworkLayers_out(properties) {
                    this.networkLayers = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkLayers_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @instance
                 */
                NetworkLayers_out.prototype.status = 0;
    
                /**
                 * NetworkLayers_out networkLayers.
                 * @member {Array.<CS.INetworkLayerDescription>} networkLayers
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @instance
                 */
                NetworkLayers_out.prototype.networkLayers = $util.emptyArray;
    
                /**
                 * NetworkLayers_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @instance
                 */
                NetworkLayers_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new NetworkLayers_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {CS.PROTO.INetworkLayers_out=} [properties] Properties to set
                 * @returns {CS.PROTO.NetworkLayers_out} NetworkLayers_out instance
                 */
                NetworkLayers_out.create = function create(properties) {
                    return new NetworkLayers_out(properties);
                };
    
                /**
                 * Encodes the specified NetworkLayers_out message. Does not implicitly {@link CS.PROTO.NetworkLayers_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {CS.PROTO.INetworkLayers_out} message NetworkLayers_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayers_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.networkLayers != null && message.networkLayers.length)
                        for (var i = 0; i < message.networkLayers.length; ++i)
                            $root.CS.NetworkLayerDescription.encode(message.networkLayers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NetworkLayers_out message, length delimited. Does not implicitly {@link CS.PROTO.NetworkLayers_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {CS.PROTO.INetworkLayers_out} message NetworkLayers_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayers_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NetworkLayers_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.NetworkLayers_out} NetworkLayers_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayers_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.NetworkLayers_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.networkLayers && message.networkLayers.length))
                                message.networkLayers = [];
                            message.networkLayers.push($root.CS.NetworkLayerDescription.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NetworkLayers_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.NetworkLayers_out} NetworkLayers_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayers_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NetworkLayers_out message.
                 * @function verify
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NetworkLayers_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.networkLayers != null && message.hasOwnProperty("networkLayers")) {
                        if (!Array.isArray(message.networkLayers))
                            return "networkLayers: array expected";
                        for (var i = 0; i < message.networkLayers.length; ++i) {
                            var error = $root.CS.NetworkLayerDescription.verify(message.networkLayers[i]);
                            if (error)
                                return "networkLayers." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NetworkLayers_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.NetworkLayers_out} NetworkLayers_out
                 */
                NetworkLayers_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.NetworkLayers_out)
                        return object;
                    var message = new $root.CS.PROTO.NetworkLayers_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.networkLayers) {
                        if (!Array.isArray(object.networkLayers))
                            throw TypeError(".CS.PROTO.NetworkLayers_out.networkLayers: array expected");
                        message.networkLayers = [];
                        for (var i = 0; i < object.networkLayers.length; ++i) {
                            if (typeof object.networkLayers[i] !== "object")
                                throw TypeError(".CS.PROTO.NetworkLayers_out.networkLayers: object expected");
                            message.networkLayers[i] = $root.CS.NetworkLayerDescription.fromObject(object.networkLayers[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.NetworkLayers_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.NetworkLayers_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NetworkLayers_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @static
                 * @param {CS.PROTO.NetworkLayers_out} message NetworkLayers_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NetworkLayers_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.networkLayers = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.networkLayers && message.networkLayers.length) {
                        object.networkLayers = [];
                        for (var j = 0; j < message.networkLayers.length; ++j)
                            object.networkLayers[j] = $root.CS.NetworkLayerDescription.toObject(message.networkLayers[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NetworkLayers_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.NetworkLayers_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NetworkLayers_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NetworkLayers_out;
            })();
    
            PROTO.NetworkLayerObjects_in = (function() {
    
                /**
                 * Properties of a NetworkLayerObjects_in.
                 * @memberof CS.PROTO
                 * @interface INetworkLayerObjects_in
                 * @property {CS.PROTO.IAPIService|null} [control] NetworkLayerObjects_in control
                 */
    
                /**
                 * Constructs a new NetworkLayerObjects_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a NetworkLayerObjects_in.
                 * @implements INetworkLayerObjects_in
                 * @constructor
                 * @param {CS.PROTO.INetworkLayerObjects_in=} [properties] Properties to set
                 */
                function NetworkLayerObjects_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkLayerObjects_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @instance
                 */
                NetworkLayerObjects_in.prototype.control = null;
    
                /**
                 * Creates a new NetworkLayerObjects_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {CS.PROTO.INetworkLayerObjects_in=} [properties] Properties to set
                 * @returns {CS.PROTO.NetworkLayerObjects_in} NetworkLayerObjects_in instance
                 */
                NetworkLayerObjects_in.create = function create(properties) {
                    return new NetworkLayerObjects_in(properties);
                };
    
                /**
                 * Encodes the specified NetworkLayerObjects_in message. Does not implicitly {@link CS.PROTO.NetworkLayerObjects_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {CS.PROTO.INetworkLayerObjects_in} message NetworkLayerObjects_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayerObjects_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NetworkLayerObjects_in message, length delimited. Does not implicitly {@link CS.PROTO.NetworkLayerObjects_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {CS.PROTO.INetworkLayerObjects_in} message NetworkLayerObjects_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayerObjects_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NetworkLayerObjects_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.NetworkLayerObjects_in} NetworkLayerObjects_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayerObjects_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.NetworkLayerObjects_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NetworkLayerObjects_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.NetworkLayerObjects_in} NetworkLayerObjects_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayerObjects_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NetworkLayerObjects_in message.
                 * @function verify
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NetworkLayerObjects_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a NetworkLayerObjects_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.NetworkLayerObjects_in} NetworkLayerObjects_in
                 */
                NetworkLayerObjects_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.NetworkLayerObjects_in)
                        return object;
                    var message = new $root.CS.PROTO.NetworkLayerObjects_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.NetworkLayerObjects_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NetworkLayerObjects_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @static
                 * @param {CS.PROTO.NetworkLayerObjects_in} message NetworkLayerObjects_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NetworkLayerObjects_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this NetworkLayerObjects_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.NetworkLayerObjects_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NetworkLayerObjects_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NetworkLayerObjects_in;
            })();
    
            PROTO.NetworkLayerObjects_out = (function() {
    
                /**
                 * Properties of a NetworkLayerObjects_out.
                 * @memberof CS.PROTO
                 * @interface INetworkLayerObjects_out
                 * @property {CS.Status|null} [status] NetworkLayerObjects_out status
                 * @property {Array.<CS.INetworkLayerObject>|null} [networkLayers] NetworkLayerObjects_out networkLayers
                 * @property {Array.<CS.IError>|null} [errors] NetworkLayerObjects_out errors
                 */
    
                /**
                 * Constructs a new NetworkLayerObjects_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a NetworkLayerObjects_out.
                 * @implements INetworkLayerObjects_out
                 * @constructor
                 * @param {CS.PROTO.INetworkLayerObjects_out=} [properties] Properties to set
                 */
                function NetworkLayerObjects_out(properties) {
                    this.networkLayers = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkLayerObjects_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @instance
                 */
                NetworkLayerObjects_out.prototype.status = 0;
    
                /**
                 * NetworkLayerObjects_out networkLayers.
                 * @member {Array.<CS.INetworkLayerObject>} networkLayers
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @instance
                 */
                NetworkLayerObjects_out.prototype.networkLayers = $util.emptyArray;
    
                /**
                 * NetworkLayerObjects_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @instance
                 */
                NetworkLayerObjects_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new NetworkLayerObjects_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {CS.PROTO.INetworkLayerObjects_out=} [properties] Properties to set
                 * @returns {CS.PROTO.NetworkLayerObjects_out} NetworkLayerObjects_out instance
                 */
                NetworkLayerObjects_out.create = function create(properties) {
                    return new NetworkLayerObjects_out(properties);
                };
    
                /**
                 * Encodes the specified NetworkLayerObjects_out message. Does not implicitly {@link CS.PROTO.NetworkLayerObjects_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {CS.PROTO.INetworkLayerObjects_out} message NetworkLayerObjects_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayerObjects_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.networkLayers != null && message.networkLayers.length)
                        for (var i = 0; i < message.networkLayers.length; ++i)
                            $root.CS.NetworkLayerObject.encode(message.networkLayers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NetworkLayerObjects_out message, length delimited. Does not implicitly {@link CS.PROTO.NetworkLayerObjects_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {CS.PROTO.INetworkLayerObjects_out} message NetworkLayerObjects_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkLayerObjects_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NetworkLayerObjects_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.NetworkLayerObjects_out} NetworkLayerObjects_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayerObjects_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.NetworkLayerObjects_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.networkLayers && message.networkLayers.length))
                                message.networkLayers = [];
                            message.networkLayers.push($root.CS.NetworkLayerObject.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NetworkLayerObjects_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.NetworkLayerObjects_out} NetworkLayerObjects_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkLayerObjects_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NetworkLayerObjects_out message.
                 * @function verify
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NetworkLayerObjects_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.networkLayers != null && message.hasOwnProperty("networkLayers")) {
                        if (!Array.isArray(message.networkLayers))
                            return "networkLayers: array expected";
                        for (var i = 0; i < message.networkLayers.length; ++i) {
                            var error = $root.CS.NetworkLayerObject.verify(message.networkLayers[i]);
                            if (error)
                                return "networkLayers." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NetworkLayerObjects_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.NetworkLayerObjects_out} NetworkLayerObjects_out
                 */
                NetworkLayerObjects_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.NetworkLayerObjects_out)
                        return object;
                    var message = new $root.CS.PROTO.NetworkLayerObjects_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.networkLayers) {
                        if (!Array.isArray(object.networkLayers))
                            throw TypeError(".CS.PROTO.NetworkLayerObjects_out.networkLayers: array expected");
                        message.networkLayers = [];
                        for (var i = 0; i < object.networkLayers.length; ++i) {
                            if (typeof object.networkLayers[i] !== "object")
                                throw TypeError(".CS.PROTO.NetworkLayerObjects_out.networkLayers: object expected");
                            message.networkLayers[i] = $root.CS.NetworkLayerObject.fromObject(object.networkLayers[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.NetworkLayerObjects_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.NetworkLayerObjects_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NetworkLayerObjects_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @static
                 * @param {CS.PROTO.NetworkLayerObjects_out} message NetworkLayerObjects_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NetworkLayerObjects_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.networkLayers = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.networkLayers && message.networkLayers.length) {
                        object.networkLayers = [];
                        for (var j = 0; j < message.networkLayers.length; ++j)
                            object.networkLayers[j] = $root.CS.NetworkLayerObject.toObject(message.networkLayers[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NetworkLayerObjects_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.NetworkLayerObjects_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NetworkLayerObjects_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NetworkLayerObjects_out;
            })();
    
            PROTO.DataBases_in = (function() {
    
                /**
                 * Properties of a DataBases_in.
                 * @memberof CS.PROTO
                 * @interface IDataBases_in
                 * @property {CS.PROTO.IAPIService|null} [control] DataBases_in control
                 * @property {string|null} [networkLayer] DataBases_in networkLayer
                 */
    
                /**
                 * Constructs a new DataBases_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DataBases_in.
                 * @implements IDataBases_in
                 * @constructor
                 * @param {CS.PROTO.IDataBases_in=} [properties] Properties to set
                 */
                function DataBases_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DataBases_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.DataBases_in
                 * @instance
                 */
                DataBases_in.prototype.control = null;
    
                /**
                 * DataBases_in networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.DataBases_in
                 * @instance
                 */
                DataBases_in.prototype.networkLayer = "";
    
                /**
                 * Creates a new DataBases_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {CS.PROTO.IDataBases_in=} [properties] Properties to set
                 * @returns {CS.PROTO.DataBases_in} DataBases_in instance
                 */
                DataBases_in.create = function create(properties) {
                    return new DataBases_in(properties);
                };
    
                /**
                 * Encodes the specified DataBases_in message. Does not implicitly {@link CS.PROTO.DataBases_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {CS.PROTO.IDataBases_in} message DataBases_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataBases_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.networkLayer);
                    return writer;
                };
    
                /**
                 * Encodes the specified DataBases_in message, length delimited. Does not implicitly {@link CS.PROTO.DataBases_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {CS.PROTO.IDataBases_in} message DataBases_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataBases_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DataBases_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DataBases_in} DataBases_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataBases_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DataBases_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.networkLayer = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DataBases_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DataBases_in} DataBases_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataBases_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DataBases_in message.
                 * @function verify
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DataBases_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    return null;
                };
    
                /**
                 * Creates a DataBases_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DataBases_in} DataBases_in
                 */
                DataBases_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DataBases_in)
                        return object;
                    var message = new $root.CS.PROTO.DataBases_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.DataBases_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    return message;
                };
    
                /**
                 * Creates a plain object from a DataBases_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DataBases_in
                 * @static
                 * @param {CS.PROTO.DataBases_in} message DataBases_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DataBases_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.networkLayer = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    return object;
                };
    
                /**
                 * Converts this DataBases_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DataBases_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DataBases_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DataBases_in;
            })();
    
            PROTO.DataBases_out = (function() {
    
                /**
                 * Properties of a DataBases_out.
                 * @memberof CS.PROTO
                 * @interface IDataBases_out
                 * @property {CS.Status|null} [status] DataBases_out status
                 * @property {Array.<CS.IDataBaseDescription>|null} [databases] DataBases_out databases
                 * @property {Array.<CS.IError>|null} [errors] DataBases_out errors
                 */
    
                /**
                 * Constructs a new DataBases_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DataBases_out.
                 * @implements IDataBases_out
                 * @constructor
                 * @param {CS.PROTO.IDataBases_out=} [properties] Properties to set
                 */
                function DataBases_out(properties) {
                    this.databases = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DataBases_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.DataBases_out
                 * @instance
                 */
                DataBases_out.prototype.status = 0;
    
                /**
                 * DataBases_out databases.
                 * @member {Array.<CS.IDataBaseDescription>} databases
                 * @memberof CS.PROTO.DataBases_out
                 * @instance
                 */
                DataBases_out.prototype.databases = $util.emptyArray;
    
                /**
                 * DataBases_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.DataBases_out
                 * @instance
                 */
                DataBases_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new DataBases_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {CS.PROTO.IDataBases_out=} [properties] Properties to set
                 * @returns {CS.PROTO.DataBases_out} DataBases_out instance
                 */
                DataBases_out.create = function create(properties) {
                    return new DataBases_out(properties);
                };
    
                /**
                 * Encodes the specified DataBases_out message. Does not implicitly {@link CS.PROTO.DataBases_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {CS.PROTO.IDataBases_out} message DataBases_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataBases_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.databases != null && message.databases.length)
                        for (var i = 0; i < message.databases.length; ++i)
                            $root.CS.DataBaseDescription.encode(message.databases[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DataBases_out message, length delimited. Does not implicitly {@link CS.PROTO.DataBases_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {CS.PROTO.IDataBases_out} message DataBases_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataBases_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DataBases_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DataBases_out} DataBases_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataBases_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DataBases_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.databases && message.databases.length))
                                message.databases = [];
                            message.databases.push($root.CS.DataBaseDescription.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DataBases_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DataBases_out} DataBases_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataBases_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DataBases_out message.
                 * @function verify
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DataBases_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.databases != null && message.hasOwnProperty("databases")) {
                        if (!Array.isArray(message.databases))
                            return "databases: array expected";
                        for (var i = 0; i < message.databases.length; ++i) {
                            var error = $root.CS.DataBaseDescription.verify(message.databases[i]);
                            if (error)
                                return "databases." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DataBases_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DataBases_out} DataBases_out
                 */
                DataBases_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DataBases_out)
                        return object;
                    var message = new $root.CS.PROTO.DataBases_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.databases) {
                        if (!Array.isArray(object.databases))
                            throw TypeError(".CS.PROTO.DataBases_out.databases: array expected");
                        message.databases = [];
                        for (var i = 0; i < object.databases.length; ++i) {
                            if (typeof object.databases[i] !== "object")
                                throw TypeError(".CS.PROTO.DataBases_out.databases: object expected");
                            message.databases[i] = $root.CS.DataBaseDescription.fromObject(object.databases[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.DataBases_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.DataBases_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DataBases_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DataBases_out
                 * @static
                 * @param {CS.PROTO.DataBases_out} message DataBases_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DataBases_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.databases = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.databases && message.databases.length) {
                        object.databases = [];
                        for (var j = 0; j < message.databases.length; ++j)
                            object.databases[j] = $root.CS.DataBaseDescription.toObject(message.databases[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this DataBases_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DataBases_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DataBases_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DataBases_out;
            })();
    
            PROTO.ConnectivityList_in = (function() {
    
                /**
                 * Properties of a ConnectivityList_in.
                 * @memberof CS.PROTO
                 * @interface IConnectivityList_in
                 * @property {CS.PROTO.IAPIService|null} [control] ConnectivityList_in control
                 * @property {CS.SupportLevel|null} [type] ConnectivityList_in type
                 * @property {CS.ILocaleDescriptor|null} [locale] ConnectivityList_in locale
                 */
    
                /**
                 * Constructs a new ConnectivityList_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectivityList_in.
                 * @implements IConnectivityList_in
                 * @constructor
                 * @param {CS.PROTO.IConnectivityList_in=} [properties] Properties to set
                 */
                function ConnectivityList_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConnectivityList_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @instance
                 */
                ConnectivityList_in.prototype.control = null;
    
                /**
                 * ConnectivityList_in type.
                 * @member {CS.SupportLevel} type
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @instance
                 */
                ConnectivityList_in.prototype.type = 0;
    
                /**
                 * ConnectivityList_in locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @instance
                 */
                ConnectivityList_in.prototype.locale = null;
    
                /**
                 * Creates a new ConnectivityList_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {CS.PROTO.IConnectivityList_in=} [properties] Properties to set
                 * @returns {CS.PROTO.ConnectivityList_in} ConnectivityList_in instance
                 */
                ConnectivityList_in.create = function create(properties) {
                    return new ConnectivityList_in(properties);
                };
    
                /**
                 * Encodes the specified ConnectivityList_in message. Does not implicitly {@link CS.PROTO.ConnectivityList_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {CS.PROTO.IConnectivityList_in} message ConnectivityList_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityList_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ConnectivityList_in message, length delimited. Does not implicitly {@link CS.PROTO.ConnectivityList_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {CS.PROTO.IConnectivityList_in} message ConnectivityList_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityList_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConnectivityList_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ConnectivityList_in} ConnectivityList_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityList_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ConnectivityList_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConnectivityList_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ConnectivityList_in} ConnectivityList_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityList_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConnectivityList_in message.
                 * @function verify
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConnectivityList_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ConnectivityList_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ConnectivityList_in} ConnectivityList_in
                 */
                ConnectivityList_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ConnectivityList_in)
                        return object;
                    var message = new $root.CS.PROTO.ConnectivityList_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.ConnectivityList_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.type) {
                    case "Unknown_SupportLevel":
                    case 0:
                        message.type = 0;
                        break;
                    case "Query":
                    case 1:
                        message.type = 1;
                        break;
                    case "Repository":
                    case 2:
                        message.type = 2;
                        break;
                    case "StoredProcedure":
                    case 3:
                        message.type = 3;
                        break;
                    case "Cancel":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.ConnectivityList_in.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConnectivityList_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @static
                 * @param {CS.PROTO.ConnectivityList_in} message ConnectivityList_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectivityList_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.type = options.enums === String ? "Unknown_SupportLevel" : 0;
                        object.locale = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CS.SupportLevel[message.type] : message.type;
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    return object;
                };
    
                /**
                 * Converts this ConnectivityList_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ConnectivityList_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectivityList_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConnectivityList_in;
            })();
    
            PROTO.ConnectivityList_out = (function() {
    
                /**
                 * Properties of a ConnectivityList_out.
                 * @memberof CS.PROTO
                 * @interface IConnectivityList_out
                 * @property {CS.Status|null} [status] ConnectivityList_out status
                 * @property {string|null} [connList] ConnectivityList_out connList
                 * @property {Array.<CS.IError>|null} [errors] ConnectivityList_out errors
                 */
    
                /**
                 * Constructs a new ConnectivityList_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectivityList_out.
                 * @implements IConnectivityList_out
                 * @constructor
                 * @param {CS.PROTO.IConnectivityList_out=} [properties] Properties to set
                 */
                function ConnectivityList_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ConnectivityList_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @instance
                 */
                ConnectivityList_out.prototype.status = 0;
    
                /**
                 * ConnectivityList_out connList.
                 * @member {string} connList
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @instance
                 */
                ConnectivityList_out.prototype.connList = "";
    
                /**
                 * ConnectivityList_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @instance
                 */
                ConnectivityList_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new ConnectivityList_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {CS.PROTO.IConnectivityList_out=} [properties] Properties to set
                 * @returns {CS.PROTO.ConnectivityList_out} ConnectivityList_out instance
                 */
                ConnectivityList_out.create = function create(properties) {
                    return new ConnectivityList_out(properties);
                };
    
                /**
                 * Encodes the specified ConnectivityList_out message. Does not implicitly {@link CS.PROTO.ConnectivityList_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {CS.PROTO.IConnectivityList_out} message ConnectivityList_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityList_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.connList != null && Object.hasOwnProperty.call(message, "connList"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.connList);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ConnectivityList_out message, length delimited. Does not implicitly {@link CS.PROTO.ConnectivityList_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {CS.PROTO.IConnectivityList_out} message ConnectivityList_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConnectivityList_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConnectivityList_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ConnectivityList_out} ConnectivityList_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityList_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ConnectivityList_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.connList = reader.string();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConnectivityList_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ConnectivityList_out} ConnectivityList_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConnectivityList_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConnectivityList_out message.
                 * @function verify
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConnectivityList_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.connList != null && message.hasOwnProperty("connList"))
                        if (!$util.isString(message.connList))
                            return "connList: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ConnectivityList_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ConnectivityList_out} ConnectivityList_out
                 */
                ConnectivityList_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ConnectivityList_out)
                        return object;
                    var message = new $root.CS.PROTO.ConnectivityList_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.connList != null)
                        message.connList = String(object.connList);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.ConnectivityList_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.ConnectivityList_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConnectivityList_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @static
                 * @param {CS.PROTO.ConnectivityList_out} message ConnectivityList_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConnectivityList_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.connList = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.connList != null && message.hasOwnProperty("connList"))
                        object.connList = message.connList;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ConnectivityList_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ConnectivityList_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConnectivityList_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConnectivityList_out;
            })();
    
            PROTO.InternalGetLocale_in = (function() {
    
                /**
                 * Properties of an InternalGetLocale_in.
                 * @memberof CS.PROTO
                 * @interface IInternalGetLocale_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalGetLocale_in control
                 * @property {CS.ILocaleDescriptor|null} [locale] InternalGetLocale_in locale
                 */
    
                /**
                 * Constructs a new InternalGetLocale_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalGetLocale_in.
                 * @implements IInternalGetLocale_in
                 * @constructor
                 * @param {CS.PROTO.IInternalGetLocale_in=} [properties] Properties to set
                 */
                function InternalGetLocale_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalGetLocale_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @instance
                 */
                InternalGetLocale_in.prototype.control = null;
    
                /**
                 * InternalGetLocale_in locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @instance
                 */
                InternalGetLocale_in.prototype.locale = null;
    
                /**
                 * Creates a new InternalGetLocale_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalGetLocale_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalGetLocale_in} InternalGetLocale_in instance
                 */
                InternalGetLocale_in.create = function create(properties) {
                    return new InternalGetLocale_in(properties);
                };
    
                /**
                 * Encodes the specified InternalGetLocale_in message. Does not implicitly {@link CS.PROTO.InternalGetLocale_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalGetLocale_in} message InternalGetLocale_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetLocale_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalGetLocale_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalGetLocale_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalGetLocale_in} message InternalGetLocale_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetLocale_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalGetLocale_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalGetLocale_in} InternalGetLocale_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetLocale_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalGetLocale_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalGetLocale_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalGetLocale_in} InternalGetLocale_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetLocale_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalGetLocale_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalGetLocale_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalGetLocale_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalGetLocale_in} InternalGetLocale_in
                 */
                InternalGetLocale_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalGetLocale_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalGetLocale_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalGetLocale_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.InternalGetLocale_in.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalGetLocale_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @static
                 * @param {CS.PROTO.InternalGetLocale_in} message InternalGetLocale_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalGetLocale_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.locale = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    return object;
                };
    
                /**
                 * Converts this InternalGetLocale_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalGetLocale_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalGetLocale_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalGetLocale_in;
            })();
    
            PROTO.InternalGetLocale_out = (function() {
    
                /**
                 * Properties of an InternalGetLocale_out.
                 * @memberof CS.PROTO
                 * @interface IInternalGetLocale_out
                 * @property {CS.Status|null} [status] InternalGetLocale_out status
                 * @property {CS.ILocaleDescriptor|null} [locale] InternalGetLocale_out locale
                 * @property {Array.<CS.IError>|null} [errors] InternalGetLocale_out errors
                 */
    
                /**
                 * Constructs a new InternalGetLocale_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalGetLocale_out.
                 * @implements IInternalGetLocale_out
                 * @constructor
                 * @param {CS.PROTO.IInternalGetLocale_out=} [properties] Properties to set
                 */
                function InternalGetLocale_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalGetLocale_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @instance
                 */
                InternalGetLocale_out.prototype.status = 0;
    
                /**
                 * InternalGetLocale_out locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @instance
                 */
                InternalGetLocale_out.prototype.locale = null;
    
                /**
                 * InternalGetLocale_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @instance
                 */
                InternalGetLocale_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalGetLocale_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalGetLocale_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalGetLocale_out} InternalGetLocale_out instance
                 */
                InternalGetLocale_out.create = function create(properties) {
                    return new InternalGetLocale_out(properties);
                };
    
                /**
                 * Encodes the specified InternalGetLocale_out message. Does not implicitly {@link CS.PROTO.InternalGetLocale_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalGetLocale_out} message InternalGetLocale_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetLocale_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalGetLocale_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalGetLocale_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalGetLocale_out} message InternalGetLocale_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetLocale_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalGetLocale_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalGetLocale_out} InternalGetLocale_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetLocale_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalGetLocale_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalGetLocale_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalGetLocale_out} InternalGetLocale_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetLocale_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalGetLocale_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalGetLocale_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalGetLocale_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalGetLocale_out} InternalGetLocale_out
                 */
                InternalGetLocale_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalGetLocale_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalGetLocale_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.InternalGetLocale_out.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalGetLocale_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalGetLocale_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalGetLocale_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @static
                 * @param {CS.PROTO.InternalGetLocale_out} message InternalGetLocale_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalGetLocale_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.locale = null;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalGetLocale_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalGetLocale_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalGetLocale_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalGetLocale_out;
            })();
    
            PROTO.InternalGetCurrentLocale_in = (function() {
    
                /**
                 * Properties of an InternalGetCurrentLocale_in.
                 * @memberof CS.PROTO
                 * @interface IInternalGetCurrentLocale_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalGetCurrentLocale_in control
                 */
    
                /**
                 * Constructs a new InternalGetCurrentLocale_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalGetCurrentLocale_in.
                 * @implements IInternalGetCurrentLocale_in
                 * @constructor
                 * @param {CS.PROTO.IInternalGetCurrentLocale_in=} [properties] Properties to set
                 */
                function InternalGetCurrentLocale_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalGetCurrentLocale_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @instance
                 */
                InternalGetCurrentLocale_in.prototype.control = null;
    
                /**
                 * Creates a new InternalGetCurrentLocale_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalGetCurrentLocale_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalGetCurrentLocale_in} InternalGetCurrentLocale_in instance
                 */
                InternalGetCurrentLocale_in.create = function create(properties) {
                    return new InternalGetCurrentLocale_in(properties);
                };
    
                /**
                 * Encodes the specified InternalGetCurrentLocale_in message. Does not implicitly {@link CS.PROTO.InternalGetCurrentLocale_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalGetCurrentLocale_in} message InternalGetCurrentLocale_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetCurrentLocale_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalGetCurrentLocale_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalGetCurrentLocale_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalGetCurrentLocale_in} message InternalGetCurrentLocale_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetCurrentLocale_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalGetCurrentLocale_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalGetCurrentLocale_in} InternalGetCurrentLocale_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetCurrentLocale_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalGetCurrentLocale_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalGetCurrentLocale_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalGetCurrentLocale_in} InternalGetCurrentLocale_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetCurrentLocale_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalGetCurrentLocale_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalGetCurrentLocale_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalGetCurrentLocale_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalGetCurrentLocale_in} InternalGetCurrentLocale_in
                 */
                InternalGetCurrentLocale_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalGetCurrentLocale_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalGetCurrentLocale_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalGetCurrentLocale_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalGetCurrentLocale_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.InternalGetCurrentLocale_in} message InternalGetCurrentLocale_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalGetCurrentLocale_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this InternalGetCurrentLocale_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalGetCurrentLocale_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalGetCurrentLocale_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalGetCurrentLocale_in;
            })();
    
            PROTO.InternalGetCurrentLocale_out = (function() {
    
                /**
                 * Properties of an InternalGetCurrentLocale_out.
                 * @memberof CS.PROTO
                 * @interface IInternalGetCurrentLocale_out
                 * @property {CS.Status|null} [status] InternalGetCurrentLocale_out status
                 * @property {CS.ILocaleDescriptor|null} [locale] InternalGetCurrentLocale_out locale
                 * @property {Array.<CS.IError>|null} [errors] InternalGetCurrentLocale_out errors
                 */
    
                /**
                 * Constructs a new InternalGetCurrentLocale_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalGetCurrentLocale_out.
                 * @implements IInternalGetCurrentLocale_out
                 * @constructor
                 * @param {CS.PROTO.IInternalGetCurrentLocale_out=} [properties] Properties to set
                 */
                function InternalGetCurrentLocale_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalGetCurrentLocale_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @instance
                 */
                InternalGetCurrentLocale_out.prototype.status = 0;
    
                /**
                 * InternalGetCurrentLocale_out locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @instance
                 */
                InternalGetCurrentLocale_out.prototype.locale = null;
    
                /**
                 * InternalGetCurrentLocale_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @instance
                 */
                InternalGetCurrentLocale_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalGetCurrentLocale_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalGetCurrentLocale_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalGetCurrentLocale_out} InternalGetCurrentLocale_out instance
                 */
                InternalGetCurrentLocale_out.create = function create(properties) {
                    return new InternalGetCurrentLocale_out(properties);
                };
    
                /**
                 * Encodes the specified InternalGetCurrentLocale_out message. Does not implicitly {@link CS.PROTO.InternalGetCurrentLocale_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalGetCurrentLocale_out} message InternalGetCurrentLocale_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetCurrentLocale_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalGetCurrentLocale_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalGetCurrentLocale_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalGetCurrentLocale_out} message InternalGetCurrentLocale_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalGetCurrentLocale_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalGetCurrentLocale_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalGetCurrentLocale_out} InternalGetCurrentLocale_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetCurrentLocale_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalGetCurrentLocale_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalGetCurrentLocale_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalGetCurrentLocale_out} InternalGetCurrentLocale_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalGetCurrentLocale_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalGetCurrentLocale_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalGetCurrentLocale_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalGetCurrentLocale_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalGetCurrentLocale_out} InternalGetCurrentLocale_out
                 */
                InternalGetCurrentLocale_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalGetCurrentLocale_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalGetCurrentLocale_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.InternalGetCurrentLocale_out.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalGetCurrentLocale_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalGetCurrentLocale_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalGetCurrentLocale_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.InternalGetCurrentLocale_out} message InternalGetCurrentLocale_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalGetCurrentLocale_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.locale = null;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalGetCurrentLocale_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalGetCurrentLocale_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalGetCurrentLocale_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalGetCurrentLocale_out;
            })();
    
            PROTO.InternalSetCurrentLocale_in = (function() {
    
                /**
                 * Properties of an InternalSetCurrentLocale_in.
                 * @memberof CS.PROTO
                 * @interface IInternalSetCurrentLocale_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalSetCurrentLocale_in control
                 * @property {CS.ILocaleDescriptor|null} [locale] InternalSetCurrentLocale_in locale
                 */
    
                /**
                 * Constructs a new InternalSetCurrentLocale_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalSetCurrentLocale_in.
                 * @implements IInternalSetCurrentLocale_in
                 * @constructor
                 * @param {CS.PROTO.IInternalSetCurrentLocale_in=} [properties] Properties to set
                 */
                function InternalSetCurrentLocale_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalSetCurrentLocale_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @instance
                 */
                InternalSetCurrentLocale_in.prototype.control = null;
    
                /**
                 * InternalSetCurrentLocale_in locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @instance
                 */
                InternalSetCurrentLocale_in.prototype.locale = null;
    
                /**
                 * Creates a new InternalSetCurrentLocale_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalSetCurrentLocale_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalSetCurrentLocale_in} InternalSetCurrentLocale_in instance
                 */
                InternalSetCurrentLocale_in.create = function create(properties) {
                    return new InternalSetCurrentLocale_in(properties);
                };
    
                /**
                 * Encodes the specified InternalSetCurrentLocale_in message. Does not implicitly {@link CS.PROTO.InternalSetCurrentLocale_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalSetCurrentLocale_in} message InternalSetCurrentLocale_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSetCurrentLocale_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalSetCurrentLocale_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalSetCurrentLocale_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.IInternalSetCurrentLocale_in} message InternalSetCurrentLocale_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSetCurrentLocale_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalSetCurrentLocale_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalSetCurrentLocale_in} InternalSetCurrentLocale_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSetCurrentLocale_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalSetCurrentLocale_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalSetCurrentLocale_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalSetCurrentLocale_in} InternalSetCurrentLocale_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSetCurrentLocale_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalSetCurrentLocale_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalSetCurrentLocale_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalSetCurrentLocale_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalSetCurrentLocale_in} InternalSetCurrentLocale_in
                 */
                InternalSetCurrentLocale_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalSetCurrentLocale_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalSetCurrentLocale_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalSetCurrentLocale_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.InternalSetCurrentLocale_in.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalSetCurrentLocale_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @static
                 * @param {CS.PROTO.InternalSetCurrentLocale_in} message InternalSetCurrentLocale_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalSetCurrentLocale_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.locale = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    return object;
                };
    
                /**
                 * Converts this InternalSetCurrentLocale_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalSetCurrentLocale_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalSetCurrentLocale_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalSetCurrentLocale_in;
            })();
    
            PROTO.InternalSetCurrentLocale_out = (function() {
    
                /**
                 * Properties of an InternalSetCurrentLocale_out.
                 * @memberof CS.PROTO
                 * @interface IInternalSetCurrentLocale_out
                 * @property {CS.Status|null} [status] InternalSetCurrentLocale_out status
                 * @property {Array.<CS.IError>|null} [errors] InternalSetCurrentLocale_out errors
                 */
    
                /**
                 * Constructs a new InternalSetCurrentLocale_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalSetCurrentLocale_out.
                 * @implements IInternalSetCurrentLocale_out
                 * @constructor
                 * @param {CS.PROTO.IInternalSetCurrentLocale_out=} [properties] Properties to set
                 */
                function InternalSetCurrentLocale_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalSetCurrentLocale_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @instance
                 */
                InternalSetCurrentLocale_out.prototype.status = 0;
    
                /**
                 * InternalSetCurrentLocale_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @instance
                 */
                InternalSetCurrentLocale_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalSetCurrentLocale_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalSetCurrentLocale_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalSetCurrentLocale_out} InternalSetCurrentLocale_out instance
                 */
                InternalSetCurrentLocale_out.create = function create(properties) {
                    return new InternalSetCurrentLocale_out(properties);
                };
    
                /**
                 * Encodes the specified InternalSetCurrentLocale_out message. Does not implicitly {@link CS.PROTO.InternalSetCurrentLocale_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalSetCurrentLocale_out} message InternalSetCurrentLocale_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSetCurrentLocale_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalSetCurrentLocale_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalSetCurrentLocale_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.IInternalSetCurrentLocale_out} message InternalSetCurrentLocale_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSetCurrentLocale_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalSetCurrentLocale_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalSetCurrentLocale_out} InternalSetCurrentLocale_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSetCurrentLocale_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalSetCurrentLocale_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalSetCurrentLocale_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalSetCurrentLocale_out} InternalSetCurrentLocale_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSetCurrentLocale_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalSetCurrentLocale_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalSetCurrentLocale_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalSetCurrentLocale_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalSetCurrentLocale_out} InternalSetCurrentLocale_out
                 */
                InternalSetCurrentLocale_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalSetCurrentLocale_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalSetCurrentLocale_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalSetCurrentLocale_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalSetCurrentLocale_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalSetCurrentLocale_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @static
                 * @param {CS.PROTO.InternalSetCurrentLocale_out} message InternalSetCurrentLocale_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalSetCurrentLocale_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalSetCurrentLocale_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalSetCurrentLocale_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalSetCurrentLocale_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalSetCurrentLocale_out;
            })();
    
            PROTO.DictionaryProfile_in = (function() {
    
                /**
                 * Properties of a DictionaryProfile_in.
                 * @memberof CS.PROTO
                 * @interface IDictionaryProfile_in
                 * @property {CS.PROTO.IAPIService|null} [control] DictionaryProfile_in control
                 * @property {string|null} [networkLayer] DictionaryProfile_in networkLayer
                 * @property {string|null} [RDBMS] DictionaryProfile_in RDBMS
                 */
    
                /**
                 * Constructs a new DictionaryProfile_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DictionaryProfile_in.
                 * @implements IDictionaryProfile_in
                 * @constructor
                 * @param {CS.PROTO.IDictionaryProfile_in=} [properties] Properties to set
                 */
                function DictionaryProfile_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DictionaryProfile_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @instance
                 */
                DictionaryProfile_in.prototype.control = null;
    
                /**
                 * DictionaryProfile_in networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @instance
                 */
                DictionaryProfile_in.prototype.networkLayer = "";
    
                /**
                 * DictionaryProfile_in RDBMS.
                 * @member {string} RDBMS
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @instance
                 */
                DictionaryProfile_in.prototype.RDBMS = "";
    
                /**
                 * Creates a new DictionaryProfile_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {CS.PROTO.IDictionaryProfile_in=} [properties] Properties to set
                 * @returns {CS.PROTO.DictionaryProfile_in} DictionaryProfile_in instance
                 */
                DictionaryProfile_in.create = function create(properties) {
                    return new DictionaryProfile_in(properties);
                };
    
                /**
                 * Encodes the specified DictionaryProfile_in message. Does not implicitly {@link CS.PROTO.DictionaryProfile_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {CS.PROTO.IDictionaryProfile_in} message DictionaryProfile_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProfile_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.networkLayer);
                    if (message.RDBMS != null && Object.hasOwnProperty.call(message, "RDBMS"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.RDBMS);
                    return writer;
                };
    
                /**
                 * Encodes the specified DictionaryProfile_in message, length delimited. Does not implicitly {@link CS.PROTO.DictionaryProfile_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {CS.PROTO.IDictionaryProfile_in} message DictionaryProfile_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProfile_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DictionaryProfile_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DictionaryProfile_in} DictionaryProfile_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProfile_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DictionaryProfile_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.networkLayer = reader.string();
                            break;
                        case 3:
                            message.RDBMS = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DictionaryProfile_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DictionaryProfile_in} DictionaryProfile_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProfile_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DictionaryProfile_in message.
                 * @function verify
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DictionaryProfile_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    if (message.RDBMS != null && message.hasOwnProperty("RDBMS"))
                        if (!$util.isString(message.RDBMS))
                            return "RDBMS: string expected";
                    return null;
                };
    
                /**
                 * Creates a DictionaryProfile_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DictionaryProfile_in} DictionaryProfile_in
                 */
                DictionaryProfile_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DictionaryProfile_in)
                        return object;
                    var message = new $root.CS.PROTO.DictionaryProfile_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.DictionaryProfile_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    if (object.RDBMS != null)
                        message.RDBMS = String(object.RDBMS);
                    return message;
                };
    
                /**
                 * Creates a plain object from a DictionaryProfile_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @static
                 * @param {CS.PROTO.DictionaryProfile_in} message DictionaryProfile_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DictionaryProfile_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.networkLayer = "";
                        object.RDBMS = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    if (message.RDBMS != null && message.hasOwnProperty("RDBMS"))
                        object.RDBMS = message.RDBMS;
                    return object;
                };
    
                /**
                 * Converts this DictionaryProfile_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DictionaryProfile_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DictionaryProfile_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictionaryProfile_in;
            })();
    
            PROTO.DictionaryProfile_out = (function() {
    
                /**
                 * Properties of a DictionaryProfile_out.
                 * @memberof CS.PROTO
                 * @interface IDictionaryProfile_out
                 * @property {CS.Status|null} [status] DictionaryProfile_out status
                 * @property {number|null} [id] DictionaryProfile_out id
                 * @property {Array.<CS.IError>|null} [errors] DictionaryProfile_out errors
                 */
    
                /**
                 * Constructs a new DictionaryProfile_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DictionaryProfile_out.
                 * @implements IDictionaryProfile_out
                 * @constructor
                 * @param {CS.PROTO.IDictionaryProfile_out=} [properties] Properties to set
                 */
                function DictionaryProfile_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DictionaryProfile_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @instance
                 */
                DictionaryProfile_out.prototype.status = 0;
    
                /**
                 * DictionaryProfile_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @instance
                 */
                DictionaryProfile_out.prototype.id = 0;
    
                /**
                 * DictionaryProfile_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @instance
                 */
                DictionaryProfile_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new DictionaryProfile_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {CS.PROTO.IDictionaryProfile_out=} [properties] Properties to set
                 * @returns {CS.PROTO.DictionaryProfile_out} DictionaryProfile_out instance
                 */
                DictionaryProfile_out.create = function create(properties) {
                    return new DictionaryProfile_out(properties);
                };
    
                /**
                 * Encodes the specified DictionaryProfile_out message. Does not implicitly {@link CS.PROTO.DictionaryProfile_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {CS.PROTO.IDictionaryProfile_out} message DictionaryProfile_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProfile_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DictionaryProfile_out message, length delimited. Does not implicitly {@link CS.PROTO.DictionaryProfile_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {CS.PROTO.IDictionaryProfile_out} message DictionaryProfile_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryProfile_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DictionaryProfile_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DictionaryProfile_out} DictionaryProfile_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProfile_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DictionaryProfile_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DictionaryProfile_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DictionaryProfile_out} DictionaryProfile_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryProfile_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DictionaryProfile_out message.
                 * @function verify
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DictionaryProfile_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DictionaryProfile_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DictionaryProfile_out} DictionaryProfile_out
                 */
                DictionaryProfile_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DictionaryProfile_out)
                        return object;
                    var message = new $root.CS.PROTO.DictionaryProfile_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.DictionaryProfile_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.DictionaryProfile_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DictionaryProfile_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @static
                 * @param {CS.PROTO.DictionaryProfile_out} message DictionaryProfile_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DictionaryProfile_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this DictionaryProfile_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DictionaryProfile_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DictionaryProfile_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictionaryProfile_out;
            })();
    
            /**
             * InternalSQLBinding_call enum.
             * @name CS.PROTO.InternalSQLBinding_call
             * @enum {number}
             * @property {number} Unknown_InternalSQLBinding_call=0 Unknown_InternalSQLBinding_call value
             * @property {number} InternalSQLBinding_call_S=1 InternalSQLBinding_call_S value
             * @property {number} InternalSQLBinding_call_SB=2 InternalSQLBinding_call_SB value
             * @property {number} InternalSQLBinding_call_SJ=3 InternalSQLBinding_call_SJ value
             * @property {number} InternalSQLBinding_call_SBJ=4 InternalSQLBinding_call_SBJ value
             */
            PROTO.InternalSQLBinding_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_InternalSQLBinding_call"] = 0;
                values[valuesById[1] = "InternalSQLBinding_call_S"] = 1;
                values[valuesById[2] = "InternalSQLBinding_call_SB"] = 2;
                values[valuesById[3] = "InternalSQLBinding_call_SJ"] = 3;
                values[valuesById[4] = "InternalSQLBinding_call_SBJ"] = 4;
                return values;
            })();
    
            PROTO.InternalSQLBinding_in = (function() {
    
                /**
                 * Properties of an InternalSQLBinding_in.
                 * @memberof CS.PROTO
                 * @interface IInternalSQLBinding_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalSQLBinding_in control
                 * @property {CS.PROTO.InternalSQLBinding_call|null} [method] InternalSQLBinding_in method
                 * @property {CS.SQLType|null} [sqlType] InternalSQLBinding_in sqlType
                 * @property {boolean|null} [unsignedType] InternalSQLBinding_in unsignedType
                 * @property {CS.JAVAType|null} [javaType] InternalSQLBinding_in javaType
                 */
    
                /**
                 * Constructs a new InternalSQLBinding_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalSQLBinding_in.
                 * @implements IInternalSQLBinding_in
                 * @constructor
                 * @param {CS.PROTO.IInternalSQLBinding_in=} [properties] Properties to set
                 */
                function InternalSQLBinding_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalSQLBinding_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @instance
                 */
                InternalSQLBinding_in.prototype.control = null;
    
                /**
                 * InternalSQLBinding_in method.
                 * @member {CS.PROTO.InternalSQLBinding_call} method
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @instance
                 */
                InternalSQLBinding_in.prototype.method = 0;
    
                /**
                 * InternalSQLBinding_in sqlType.
                 * @member {CS.SQLType} sqlType
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @instance
                 */
                InternalSQLBinding_in.prototype.sqlType = 0;
    
                /**
                 * InternalSQLBinding_in unsignedType.
                 * @member {boolean} unsignedType
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @instance
                 */
                InternalSQLBinding_in.prototype.unsignedType = false;
    
                /**
                 * InternalSQLBinding_in javaType.
                 * @member {CS.JAVAType} javaType
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @instance
                 */
                InternalSQLBinding_in.prototype.javaType = 0;
    
                /**
                 * Creates a new InternalSQLBinding_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {CS.PROTO.IInternalSQLBinding_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalSQLBinding_in} InternalSQLBinding_in instance
                 */
                InternalSQLBinding_in.create = function create(properties) {
                    return new InternalSQLBinding_in(properties);
                };
    
                /**
                 * Encodes the specified InternalSQLBinding_in message. Does not implicitly {@link CS.PROTO.InternalSQLBinding_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {CS.PROTO.IInternalSQLBinding_in} message InternalSQLBinding_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSQLBinding_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.sqlType != null && Object.hasOwnProperty.call(message, "sqlType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sqlType);
                    if (message.unsignedType != null && Object.hasOwnProperty.call(message, "unsignedType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.unsignedType);
                    if (message.javaType != null && Object.hasOwnProperty.call(message, "javaType"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.javaType);
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalSQLBinding_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalSQLBinding_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {CS.PROTO.IInternalSQLBinding_in} message InternalSQLBinding_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSQLBinding_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalSQLBinding_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalSQLBinding_in} InternalSQLBinding_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSQLBinding_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalSQLBinding_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.sqlType = reader.int32();
                            break;
                        case 4:
                            message.unsignedType = reader.bool();
                            break;
                        case 5:
                            message.javaType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalSQLBinding_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalSQLBinding_in} InternalSQLBinding_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSQLBinding_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalSQLBinding_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalSQLBinding_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.sqlType != null && message.hasOwnProperty("sqlType"))
                        switch (message.sqlType) {
                        default:
                            return "sqlType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                            break;
                        }
                    if (message.unsignedType != null && message.hasOwnProperty("unsignedType"))
                        if (typeof message.unsignedType !== "boolean")
                            return "unsignedType: boolean expected";
                    if (message.javaType != null && message.hasOwnProperty("javaType"))
                        switch (message.javaType) {
                        default:
                            return "javaType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates an InternalSQLBinding_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalSQLBinding_in} InternalSQLBinding_in
                 */
                InternalSQLBinding_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalSQLBinding_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalSQLBinding_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalSQLBinding_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_InternalSQLBinding_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "InternalSQLBinding_call_S":
                    case 1:
                        message.method = 1;
                        break;
                    case "InternalSQLBinding_call_SB":
                    case 2:
                        message.method = 2;
                        break;
                    case "InternalSQLBinding_call_SJ":
                    case 3:
                        message.method = 3;
                        break;
                    case "InternalSQLBinding_call_SBJ":
                    case 4:
                        message.method = 4;
                        break;
                    }
                    switch (object.sqlType) {
                    case "Unknown_SQLType":
                    case 0:
                        message.sqlType = 0;
                        break;
                    case "SQL_Default":
                    case 1:
                        message.sqlType = 1;
                        break;
                    case "SQL_Char":
                    case 2:
                        message.sqlType = 2;
                        break;
                    case "SQL_VarChar":
                    case 3:
                        message.sqlType = 3;
                        break;
                    case "SQL_LongVarChar":
                    case 4:
                        message.sqlType = 4;
                        break;
                    case "SQL_Xml":
                    case 5:
                        message.sqlType = 5;
                        break;
                    case "SQL_Binary":
                    case 6:
                        message.sqlType = 6;
                        break;
                    case "SQL_VarBinary":
                    case 7:
                        message.sqlType = 7;
                        break;
                    case "SQL_LongVarBinary":
                    case 8:
                        message.sqlType = 8;
                        break;
                    case "SQL_Bit":
                    case 9:
                        message.sqlType = 9;
                        break;
                    case "SQL_TinyInt":
                    case 10:
                        message.sqlType = 10;
                        break;
                    case "SQL_SmallInt":
                    case 11:
                        message.sqlType = 11;
                        break;
                    case "SQL_Integer":
                    case 12:
                        message.sqlType = 12;
                        break;
                    case "SQL_BigInt":
                    case 13:
                        message.sqlType = 13;
                        break;
                    case "SQL_Decimal":
                    case 14:
                        message.sqlType = 14;
                        break;
                    case "SQL_Numeric":
                    case 15:
                        message.sqlType = 15;
                        break;
                    case "SQL_Real":
                    case 16:
                        message.sqlType = 16;
                        break;
                    case "SQL_Float":
                    case 17:
                        message.sqlType = 17;
                        break;
                    case "SQL_Double":
                    case 18:
                        message.sqlType = 18;
                        break;
                    case "SQL_Time":
                    case 19:
                        message.sqlType = 19;
                        break;
                    case "SQL_Date":
                    case 20:
                        message.sqlType = 20;
                        break;
                    case "SQL_TimeStamp":
                    case 21:
                        message.sqlType = 21;
                        break;
                    case "SQL_RefCursor":
                    case 22:
                        message.sqlType = 22;
                        break;
                    case "SQL_Extended":
                    case 23:
                        message.sqlType = 23;
                        break;
                    case "SQL_Unsupported":
                    case 24:
                        message.sqlType = 24;
                        break;
                    }
                    if (object.unsignedType != null)
                        message.unsignedType = Boolean(object.unsignedType);
                    switch (object.javaType) {
                    case "Unknown_JAVAType":
                    case 0:
                        message.javaType = 0;
                        break;
                    case "JAVA_Default":
                    case 1:
                        message.javaType = 1;
                        break;
                    case "JAVA_String":
                    case 2:
                        message.javaType = 2;
                        break;
                    case "JAVA_Binary":
                    case 3:
                        message.javaType = 3;
                        break;
                    case "JAVA_Byte":
                    case 4:
                        message.javaType = 4;
                        break;
                    case "JAVA_Short":
                    case 5:
                        message.javaType = 5;
                        break;
                    case "JAVA_Int":
                    case 6:
                        message.javaType = 6;
                        break;
                    case "JAVA_Long":
                    case 7:
                        message.javaType = 7;
                        break;
                    case "JAVA_Float":
                    case 8:
                        message.javaType = 8;
                        break;
                    case "JAVA_Double":
                    case 9:
                        message.javaType = 9;
                        break;
                    case "JAVA_BigDecimal":
                    case 10:
                        message.javaType = 10;
                        break;
                    case "JAVA_Time":
                    case 11:
                        message.javaType = 11;
                        break;
                    case "JAVA_Date":
                    case 12:
                        message.javaType = 12;
                        break;
                    case "JAVA_Timestamp":
                    case 13:
                        message.javaType = 13;
                        break;
                    case "JAVA_RefCursor":
                    case 14:
                        message.javaType = 14;
                        break;
                    case "JAVA_Blob":
                    case 15:
                        message.javaType = 15;
                        break;
                    case "JAVA_Clob":
                    case 16:
                        message.javaType = 16;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalSQLBinding_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @static
                 * @param {CS.PROTO.InternalSQLBinding_in} message InternalSQLBinding_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalSQLBinding_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_InternalSQLBinding_call" : 0;
                        object.sqlType = options.enums === String ? "Unknown_SQLType" : 0;
                        object.unsignedType = false;
                        object.javaType = options.enums === String ? "Unknown_JAVAType" : 0;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.InternalSQLBinding_call[message.method] : message.method;
                    if (message.sqlType != null && message.hasOwnProperty("sqlType"))
                        object.sqlType = options.enums === String ? $root.CS.SQLType[message.sqlType] : message.sqlType;
                    if (message.unsignedType != null && message.hasOwnProperty("unsignedType"))
                        object.unsignedType = message.unsignedType;
                    if (message.javaType != null && message.hasOwnProperty("javaType"))
                        object.javaType = options.enums === String ? $root.CS.JAVAType[message.javaType] : message.javaType;
                    return object;
                };
    
                /**
                 * Converts this InternalSQLBinding_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalSQLBinding_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalSQLBinding_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalSQLBinding_in;
            })();
    
            PROTO.InternalSQLBinding_out = (function() {
    
                /**
                 * Properties of an InternalSQLBinding_out.
                 * @memberof CS.PROTO
                 * @interface IInternalSQLBinding_out
                 * @property {CS.Status|null} [status] InternalSQLBinding_out status
                 * @property {CS.JAVAType|null} [javaType] InternalSQLBinding_out javaType
                 * @property {Array.<CS.IError>|null} [errors] InternalSQLBinding_out errors
                 */
    
                /**
                 * Constructs a new InternalSQLBinding_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalSQLBinding_out.
                 * @implements IInternalSQLBinding_out
                 * @constructor
                 * @param {CS.PROTO.IInternalSQLBinding_out=} [properties] Properties to set
                 */
                function InternalSQLBinding_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalSQLBinding_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @instance
                 */
                InternalSQLBinding_out.prototype.status = 0;
    
                /**
                 * InternalSQLBinding_out javaType.
                 * @member {CS.JAVAType} javaType
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @instance
                 */
                InternalSQLBinding_out.prototype.javaType = 0;
    
                /**
                 * InternalSQLBinding_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @instance
                 */
                InternalSQLBinding_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalSQLBinding_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {CS.PROTO.IInternalSQLBinding_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalSQLBinding_out} InternalSQLBinding_out instance
                 */
                InternalSQLBinding_out.create = function create(properties) {
                    return new InternalSQLBinding_out(properties);
                };
    
                /**
                 * Encodes the specified InternalSQLBinding_out message. Does not implicitly {@link CS.PROTO.InternalSQLBinding_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {CS.PROTO.IInternalSQLBinding_out} message InternalSQLBinding_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSQLBinding_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.javaType != null && Object.hasOwnProperty.call(message, "javaType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.javaType);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalSQLBinding_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalSQLBinding_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {CS.PROTO.IInternalSQLBinding_out} message InternalSQLBinding_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalSQLBinding_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalSQLBinding_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalSQLBinding_out} InternalSQLBinding_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSQLBinding_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalSQLBinding_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.javaType = reader.int32();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalSQLBinding_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalSQLBinding_out} InternalSQLBinding_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalSQLBinding_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalSQLBinding_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalSQLBinding_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.javaType != null && message.hasOwnProperty("javaType"))
                        switch (message.javaType) {
                        default:
                            return "javaType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalSQLBinding_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalSQLBinding_out} InternalSQLBinding_out
                 */
                InternalSQLBinding_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalSQLBinding_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalSQLBinding_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    switch (object.javaType) {
                    case "Unknown_JAVAType":
                    case 0:
                        message.javaType = 0;
                        break;
                    case "JAVA_Default":
                    case 1:
                        message.javaType = 1;
                        break;
                    case "JAVA_String":
                    case 2:
                        message.javaType = 2;
                        break;
                    case "JAVA_Binary":
                    case 3:
                        message.javaType = 3;
                        break;
                    case "JAVA_Byte":
                    case 4:
                        message.javaType = 4;
                        break;
                    case "JAVA_Short":
                    case 5:
                        message.javaType = 5;
                        break;
                    case "JAVA_Int":
                    case 6:
                        message.javaType = 6;
                        break;
                    case "JAVA_Long":
                    case 7:
                        message.javaType = 7;
                        break;
                    case "JAVA_Float":
                    case 8:
                        message.javaType = 8;
                        break;
                    case "JAVA_Double":
                    case 9:
                        message.javaType = 9;
                        break;
                    case "JAVA_BigDecimal":
                    case 10:
                        message.javaType = 10;
                        break;
                    case "JAVA_Time":
                    case 11:
                        message.javaType = 11;
                        break;
                    case "JAVA_Date":
                    case 12:
                        message.javaType = 12;
                        break;
                    case "JAVA_Timestamp":
                    case 13:
                        message.javaType = 13;
                        break;
                    case "JAVA_RefCursor":
                    case 14:
                        message.javaType = 14;
                        break;
                    case "JAVA_Blob":
                    case 15:
                        message.javaType = 15;
                        break;
                    case "JAVA_Clob":
                    case 16:
                        message.javaType = 16;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalSQLBinding_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalSQLBinding_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalSQLBinding_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @static
                 * @param {CS.PROTO.InternalSQLBinding_out} message InternalSQLBinding_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalSQLBinding_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.javaType = options.enums === String ? "Unknown_JAVAType" : 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.javaType != null && message.hasOwnProperty("javaType"))
                        object.javaType = options.enums === String ? $root.CS.JAVAType[message.javaType] : message.javaType;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalSQLBinding_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalSQLBinding_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalSQLBinding_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalSQLBinding_out;
            })();
    
            PROTO.CreateConnectionManager_in = (function() {
    
                /**
                 * Properties of a CreateConnectionManager_in.
                 * @memberof CS.PROTO
                 * @interface ICreateConnectionManager_in
                 * @property {CS.PROTO.IAPIService|null} [control] CreateConnectionManager_in control
                 * @property {string|null} [networkLayer] CreateConnectionManager_in networkLayer
                 * @property {string|null} [RDBMS] CreateConnectionManager_in RDBMS
                 * @property {string|null} [profile] CreateConnectionManager_in profile
                 */
    
                /**
                 * Constructs a new CreateConnectionManager_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CreateConnectionManager_in.
                 * @implements ICreateConnectionManager_in
                 * @constructor
                 * @param {CS.PROTO.ICreateConnectionManager_in=} [properties] Properties to set
                 */
                function CreateConnectionManager_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateConnectionManager_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @instance
                 */
                CreateConnectionManager_in.prototype.control = null;
    
                /**
                 * CreateConnectionManager_in networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @instance
                 */
                CreateConnectionManager_in.prototype.networkLayer = "";
    
                /**
                 * CreateConnectionManager_in RDBMS.
                 * @member {string} RDBMS
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @instance
                 */
                CreateConnectionManager_in.prototype.RDBMS = "";
    
                /**
                 * CreateConnectionManager_in profile.
                 * @member {string} profile
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @instance
                 */
                CreateConnectionManager_in.prototype.profile = "";
    
                /**
                 * Creates a new CreateConnectionManager_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {CS.PROTO.ICreateConnectionManager_in=} [properties] Properties to set
                 * @returns {CS.PROTO.CreateConnectionManager_in} CreateConnectionManager_in instance
                 */
                CreateConnectionManager_in.create = function create(properties) {
                    return new CreateConnectionManager_in(properties);
                };
    
                /**
                 * Encodes the specified CreateConnectionManager_in message. Does not implicitly {@link CS.PROTO.CreateConnectionManager_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {CS.PROTO.ICreateConnectionManager_in} message CreateConnectionManager_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateConnectionManager_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.networkLayer);
                    if (message.RDBMS != null && Object.hasOwnProperty.call(message, "RDBMS"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.RDBMS);
                    if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.profile);
                    return writer;
                };
    
                /**
                 * Encodes the specified CreateConnectionManager_in message, length delimited. Does not implicitly {@link CS.PROTO.CreateConnectionManager_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {CS.PROTO.ICreateConnectionManager_in} message CreateConnectionManager_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateConnectionManager_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CreateConnectionManager_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CreateConnectionManager_in} CreateConnectionManager_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateConnectionManager_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CreateConnectionManager_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.networkLayer = reader.string();
                            break;
                        case 3:
                            message.RDBMS = reader.string();
                            break;
                        case 4:
                            message.profile = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CreateConnectionManager_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CreateConnectionManager_in} CreateConnectionManager_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateConnectionManager_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CreateConnectionManager_in message.
                 * @function verify
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateConnectionManager_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    if (message.RDBMS != null && message.hasOwnProperty("RDBMS"))
                        if (!$util.isString(message.RDBMS))
                            return "RDBMS: string expected";
                    if (message.profile != null && message.hasOwnProperty("profile"))
                        if (!$util.isString(message.profile))
                            return "profile: string expected";
                    return null;
                };
    
                /**
                 * Creates a CreateConnectionManager_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CreateConnectionManager_in} CreateConnectionManager_in
                 */
                CreateConnectionManager_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CreateConnectionManager_in)
                        return object;
                    var message = new $root.CS.PROTO.CreateConnectionManager_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.CreateConnectionManager_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    if (object.RDBMS != null)
                        message.RDBMS = String(object.RDBMS);
                    if (object.profile != null)
                        message.profile = String(object.profile);
                    return message;
                };
    
                /**
                 * Creates a plain object from a CreateConnectionManager_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @static
                 * @param {CS.PROTO.CreateConnectionManager_in} message CreateConnectionManager_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateConnectionManager_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.networkLayer = "";
                        object.RDBMS = "";
                        object.profile = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    if (message.RDBMS != null && message.hasOwnProperty("RDBMS"))
                        object.RDBMS = message.RDBMS;
                    if (message.profile != null && message.hasOwnProperty("profile"))
                        object.profile = message.profile;
                    return object;
                };
    
                /**
                 * Converts this CreateConnectionManager_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CreateConnectionManager_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateConnectionManager_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CreateConnectionManager_in;
            })();
    
            PROTO.CreateConnectionManager_out = (function() {
    
                /**
                 * Properties of a CreateConnectionManager_out.
                 * @memberof CS.PROTO
                 * @interface ICreateConnectionManager_out
                 * @property {CS.Status|null} [status] CreateConnectionManager_out status
                 * @property {number|null} [id] CreateConnectionManager_out id
                 * @property {Array.<CS.IError>|null} [errors] CreateConnectionManager_out errors
                 */
    
                /**
                 * Constructs a new CreateConnectionManager_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CreateConnectionManager_out.
                 * @implements ICreateConnectionManager_out
                 * @constructor
                 * @param {CS.PROTO.ICreateConnectionManager_out=} [properties] Properties to set
                 */
                function CreateConnectionManager_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateConnectionManager_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @instance
                 */
                CreateConnectionManager_out.prototype.status = 0;
    
                /**
                 * CreateConnectionManager_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @instance
                 */
                CreateConnectionManager_out.prototype.id = 0;
    
                /**
                 * CreateConnectionManager_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @instance
                 */
                CreateConnectionManager_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new CreateConnectionManager_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {CS.PROTO.ICreateConnectionManager_out=} [properties] Properties to set
                 * @returns {CS.PROTO.CreateConnectionManager_out} CreateConnectionManager_out instance
                 */
                CreateConnectionManager_out.create = function create(properties) {
                    return new CreateConnectionManager_out(properties);
                };
    
                /**
                 * Encodes the specified CreateConnectionManager_out message. Does not implicitly {@link CS.PROTO.CreateConnectionManager_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {CS.PROTO.ICreateConnectionManager_out} message CreateConnectionManager_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateConnectionManager_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CreateConnectionManager_out message, length delimited. Does not implicitly {@link CS.PROTO.CreateConnectionManager_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {CS.PROTO.ICreateConnectionManager_out} message CreateConnectionManager_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateConnectionManager_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CreateConnectionManager_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CreateConnectionManager_out} CreateConnectionManager_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateConnectionManager_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CreateConnectionManager_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CreateConnectionManager_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CreateConnectionManager_out} CreateConnectionManager_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateConnectionManager_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CreateConnectionManager_out message.
                 * @function verify
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateConnectionManager_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CreateConnectionManager_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CreateConnectionManager_out} CreateConnectionManager_out
                 */
                CreateConnectionManager_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CreateConnectionManager_out)
                        return object;
                    var message = new $root.CS.PROTO.CreateConnectionManager_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.CreateConnectionManager_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.CreateConnectionManager_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CreateConnectionManager_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @static
                 * @param {CS.PROTO.CreateConnectionManager_out} message CreateConnectionManager_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateConnectionManager_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CreateConnectionManager_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CreateConnectionManager_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateConnectionManager_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CreateConnectionManager_out;
            })();
    
            /**
             * CreateDictionary_call enum.
             * @name CS.PROTO.CreateDictionary_call
             * @enum {number}
             * @property {number} Unknown_CreateDictionary_call=0 Unknown_CreateDictionary_call value
             * @property {number} CreateDictionary_call_SSSD=1 CreateDictionary_call_SSSD value
             * @property {number} CreateDictionary_call_SNSD=2 CreateDictionary_call_SNSD value
             */
            PROTO.CreateDictionary_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_CreateDictionary_call"] = 0;
                values[valuesById[1] = "CreateDictionary_call_SSSD"] = 1;
                values[valuesById[2] = "CreateDictionary_call_SNSD"] = 2;
                return values;
            })();
    
            PROTO.CreateDictionary_in = (function() {
    
                /**
                 * Properties of a CreateDictionary_in.
                 * @memberof CS.PROTO
                 * @interface ICreateDictionary_in
                 * @property {CS.PROTO.IAPIService|null} [control] CreateDictionary_in control
                 * @property {CS.PROTO.CreateDictionary_call|null} [method] CreateDictionary_in method
                 * @property {string|null} [connectionString] CreateDictionary_in connectionString
                 * @property {string|null} [networkLayer] CreateDictionary_in networkLayer
                 * @property {CS.INetworkLayerObject|null} [networkLayerObject] CreateDictionary_in networkLayerObject
                 * @property {string|null} [database] CreateDictionary_in database
                 * @property {CS.IPropertySet|null} [properties] CreateDictionary_in properties
                 */
    
                /**
                 * Constructs a new CreateDictionary_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CreateDictionary_in.
                 * @implements ICreateDictionary_in
                 * @constructor
                 * @param {CS.PROTO.ICreateDictionary_in=} [properties] Properties to set
                 */
                function CreateDictionary_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateDictionary_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 */
                CreateDictionary_in.prototype.control = null;
    
                /**
                 * CreateDictionary_in method.
                 * @member {CS.PROTO.CreateDictionary_call} method
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 */
                CreateDictionary_in.prototype.method = 0;
    
                /**
                 * CreateDictionary_in connectionString.
                 * @member {string} connectionString
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 */
                CreateDictionary_in.prototype.connectionString = "";
    
                /**
                 * CreateDictionary_in networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 */
                CreateDictionary_in.prototype.networkLayer = "";
    
                /**
                 * CreateDictionary_in networkLayerObject.
                 * @member {CS.INetworkLayerObject|null|undefined} networkLayerObject
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 */
                CreateDictionary_in.prototype.networkLayerObject = null;
    
                /**
                 * CreateDictionary_in database.
                 * @member {string} database
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 */
                CreateDictionary_in.prototype.database = "";
    
                /**
                 * CreateDictionary_in properties.
                 * @member {CS.IPropertySet|null|undefined} properties
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 */
                CreateDictionary_in.prototype.properties = null;
    
                /**
                 * Creates a new CreateDictionary_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {CS.PROTO.ICreateDictionary_in=} [properties] Properties to set
                 * @returns {CS.PROTO.CreateDictionary_in} CreateDictionary_in instance
                 */
                CreateDictionary_in.create = function create(properties) {
                    return new CreateDictionary_in(properties);
                };
    
                /**
                 * Encodes the specified CreateDictionary_in message. Does not implicitly {@link CS.PROTO.CreateDictionary_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {CS.PROTO.ICreateDictionary_in} message CreateDictionary_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDictionary_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.connectionString);
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkLayer);
                    if (message.networkLayerObject != null && Object.hasOwnProperty.call(message, "networkLayerObject"))
                        $root.CS.NetworkLayerObject.encode(message.networkLayerObject, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.database);
                    if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                        $root.CS.PropertySet.encode(message.properties, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CreateDictionary_in message, length delimited. Does not implicitly {@link CS.PROTO.CreateDictionary_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {CS.PROTO.ICreateDictionary_in} message CreateDictionary_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDictionary_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CreateDictionary_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CreateDictionary_in} CreateDictionary_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDictionary_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CreateDictionary_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.connectionString = reader.string();
                            break;
                        case 4:
                            message.networkLayer = reader.string();
                            break;
                        case 5:
                            message.networkLayerObject = $root.CS.NetworkLayerObject.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.database = reader.string();
                            break;
                        case 7:
                            message.properties = $root.CS.PropertySet.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CreateDictionary_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CreateDictionary_in} CreateDictionary_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDictionary_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CreateDictionary_in message.
                 * @function verify
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateDictionary_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                        if (!$util.isString(message.connectionString))
                            return "connectionString: string expected";
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    if (message.networkLayerObject != null && message.hasOwnProperty("networkLayerObject")) {
                        var error = $root.CS.NetworkLayerObject.verify(message.networkLayerObject);
                        if (error)
                            return "networkLayerObject." + error;
                    }
                    if (message.database != null && message.hasOwnProperty("database"))
                        if (!$util.isString(message.database))
                            return "database: string expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        var error = $root.CS.PropertySet.verify(message.properties);
                        if (error)
                            return "properties." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a CreateDictionary_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CreateDictionary_in} CreateDictionary_in
                 */
                CreateDictionary_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CreateDictionary_in)
                        return object;
                    var message = new $root.CS.PROTO.CreateDictionary_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.CreateDictionary_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_CreateDictionary_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "CreateDictionary_call_SSSD":
                    case 1:
                        message.method = 1;
                        break;
                    case "CreateDictionary_call_SNSD":
                    case 2:
                        message.method = 2;
                        break;
                    }
                    if (object.connectionString != null)
                        message.connectionString = String(object.connectionString);
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    if (object.networkLayerObject != null) {
                        if (typeof object.networkLayerObject !== "object")
                            throw TypeError(".CS.PROTO.CreateDictionary_in.networkLayerObject: object expected");
                        message.networkLayerObject = $root.CS.NetworkLayerObject.fromObject(object.networkLayerObject);
                    }
                    if (object.database != null)
                        message.database = String(object.database);
                    if (object.properties != null) {
                        if (typeof object.properties !== "object")
                            throw TypeError(".CS.PROTO.CreateDictionary_in.properties: object expected");
                        message.properties = $root.CS.PropertySet.fromObject(object.properties);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CreateDictionary_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @static
                 * @param {CS.PROTO.CreateDictionary_in} message CreateDictionary_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateDictionary_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_CreateDictionary_call" : 0;
                        object.connectionString = "";
                        object.networkLayer = "";
                        object.networkLayerObject = null;
                        object.database = "";
                        object.properties = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.CreateDictionary_call[message.method] : message.method;
                    if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                        object.connectionString = message.connectionString;
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    if (message.networkLayerObject != null && message.hasOwnProperty("networkLayerObject"))
                        object.networkLayerObject = $root.CS.NetworkLayerObject.toObject(message.networkLayerObject, options);
                    if (message.database != null && message.hasOwnProperty("database"))
                        object.database = message.database;
                    if (message.properties != null && message.hasOwnProperty("properties"))
                        object.properties = $root.CS.PropertySet.toObject(message.properties, options);
                    return object;
                };
    
                /**
                 * Converts this CreateDictionary_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CreateDictionary_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateDictionary_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CreateDictionary_in;
            })();
    
            PROTO.CreateDictionary_out = (function() {
    
                /**
                 * Properties of a CreateDictionary_out.
                 * @memberof CS.PROTO
                 * @interface ICreateDictionary_out
                 * @property {CS.Status|null} [status] CreateDictionary_out status
                 * @property {number|null} [id] CreateDictionary_out id
                 * @property {CS.ConnectivityType|null} [type] CreateDictionary_out type
                 * @property {string|null} [networkLayer] CreateDictionary_out networkLayer
                 * @property {Array.<CS.IError>|null} [errors] CreateDictionary_out errors
                 */
    
                /**
                 * Constructs a new CreateDictionary_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CreateDictionary_out.
                 * @implements ICreateDictionary_out
                 * @constructor
                 * @param {CS.PROTO.ICreateDictionary_out=} [properties] Properties to set
                 */
                function CreateDictionary_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateDictionary_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @instance
                 */
                CreateDictionary_out.prototype.status = 0;
    
                /**
                 * CreateDictionary_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @instance
                 */
                CreateDictionary_out.prototype.id = 0;
    
                /**
                 * CreateDictionary_out type.
                 * @member {CS.ConnectivityType} type
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @instance
                 */
                CreateDictionary_out.prototype.type = 0;
    
                /**
                 * CreateDictionary_out networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @instance
                 */
                CreateDictionary_out.prototype.networkLayer = "";
    
                /**
                 * CreateDictionary_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @instance
                 */
                CreateDictionary_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new CreateDictionary_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {CS.PROTO.ICreateDictionary_out=} [properties] Properties to set
                 * @returns {CS.PROTO.CreateDictionary_out} CreateDictionary_out instance
                 */
                CreateDictionary_out.create = function create(properties) {
                    return new CreateDictionary_out(properties);
                };
    
                /**
                 * Encodes the specified CreateDictionary_out message. Does not implicitly {@link CS.PROTO.CreateDictionary_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {CS.PROTO.ICreateDictionary_out} message CreateDictionary_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDictionary_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkLayer);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CreateDictionary_out message, length delimited. Does not implicitly {@link CS.PROTO.CreateDictionary_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {CS.PROTO.ICreateDictionary_out} message CreateDictionary_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateDictionary_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CreateDictionary_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CreateDictionary_out} CreateDictionary_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDictionary_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CreateDictionary_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.type = reader.int32();
                            break;
                        case 4:
                            message.networkLayer = reader.string();
                            break;
                        case 5:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CreateDictionary_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CreateDictionary_out} CreateDictionary_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateDictionary_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CreateDictionary_out message.
                 * @function verify
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateDictionary_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CreateDictionary_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CreateDictionary_out} CreateDictionary_out
                 */
                CreateDictionary_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CreateDictionary_out)
                        return object;
                    var message = new $root.CS.PROTO.CreateDictionary_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    switch (object.type) {
                    case "Unknown_ConnectivityType":
                    case 0:
                        message.type = 0;
                        break;
                    case "Relational":
                    case 1:
                        message.type = 1;
                        break;
                    case "OLAP":
                    case 2:
                        message.type = 2;
                        break;
                    case "Open":
                    case 3:
                        message.type = 3;
                        break;
                    }
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.CreateDictionary_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.CreateDictionary_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CreateDictionary_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @static
                 * @param {CS.PROTO.CreateDictionary_out} message CreateDictionary_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateDictionary_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                        object.type = options.enums === String ? "Unknown_ConnectivityType" : 0;
                        object.networkLayer = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CS.ConnectivityType[message.type] : message.type;
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CreateDictionary_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CreateDictionary_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateDictionary_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CreateDictionary_out;
            })();
    
            PROTO.JobProfile_in = (function() {
    
                /**
                 * Properties of a JobProfile_in.
                 * @memberof CS.PROTO
                 * @interface IJobProfile_in
                 * @property {CS.PROTO.IAPIService|null} [control] JobProfile_in control
                 * @property {string|null} [networkLayer] JobProfile_in networkLayer
                 * @property {string|null} [RDBMS] JobProfile_in RDBMS
                 */
    
                /**
                 * Constructs a new JobProfile_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a JobProfile_in.
                 * @implements IJobProfile_in
                 * @constructor
                 * @param {CS.PROTO.IJobProfile_in=} [properties] Properties to set
                 */
                function JobProfile_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * JobProfile_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.JobProfile_in
                 * @instance
                 */
                JobProfile_in.prototype.control = null;
    
                /**
                 * JobProfile_in networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.JobProfile_in
                 * @instance
                 */
                JobProfile_in.prototype.networkLayer = "";
    
                /**
                 * JobProfile_in RDBMS.
                 * @member {string} RDBMS
                 * @memberof CS.PROTO.JobProfile_in
                 * @instance
                 */
                JobProfile_in.prototype.RDBMS = "";
    
                /**
                 * Creates a new JobProfile_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {CS.PROTO.IJobProfile_in=} [properties] Properties to set
                 * @returns {CS.PROTO.JobProfile_in} JobProfile_in instance
                 */
                JobProfile_in.create = function create(properties) {
                    return new JobProfile_in(properties);
                };
    
                /**
                 * Encodes the specified JobProfile_in message. Does not implicitly {@link CS.PROTO.JobProfile_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {CS.PROTO.IJobProfile_in} message JobProfile_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JobProfile_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.networkLayer);
                    if (message.RDBMS != null && Object.hasOwnProperty.call(message, "RDBMS"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.RDBMS);
                    return writer;
                };
    
                /**
                 * Encodes the specified JobProfile_in message, length delimited. Does not implicitly {@link CS.PROTO.JobProfile_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {CS.PROTO.IJobProfile_in} message JobProfile_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JobProfile_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a JobProfile_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.JobProfile_in} JobProfile_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JobProfile_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.JobProfile_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.networkLayer = reader.string();
                            break;
                        case 3:
                            message.RDBMS = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a JobProfile_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.JobProfile_in} JobProfile_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JobProfile_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a JobProfile_in message.
                 * @function verify
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                JobProfile_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    if (message.RDBMS != null && message.hasOwnProperty("RDBMS"))
                        if (!$util.isString(message.RDBMS))
                            return "RDBMS: string expected";
                    return null;
                };
    
                /**
                 * Creates a JobProfile_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.JobProfile_in} JobProfile_in
                 */
                JobProfile_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.JobProfile_in)
                        return object;
                    var message = new $root.CS.PROTO.JobProfile_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.JobProfile_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    if (object.RDBMS != null)
                        message.RDBMS = String(object.RDBMS);
                    return message;
                };
    
                /**
                 * Creates a plain object from a JobProfile_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.JobProfile_in
                 * @static
                 * @param {CS.PROTO.JobProfile_in} message JobProfile_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                JobProfile_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.networkLayer = "";
                        object.RDBMS = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    if (message.RDBMS != null && message.hasOwnProperty("RDBMS"))
                        object.RDBMS = message.RDBMS;
                    return object;
                };
    
                /**
                 * Converts this JobProfile_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.JobProfile_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                JobProfile_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return JobProfile_in;
            })();
    
            PROTO.JobProfile_out = (function() {
    
                /**
                 * Properties of a JobProfile_out.
                 * @memberof CS.PROTO
                 * @interface IJobProfile_out
                 * @property {CS.Status|null} [status] JobProfile_out status
                 * @property {number|null} [id] JobProfile_out id
                 * @property {Array.<CS.IError>|null} [errors] JobProfile_out errors
                 */
    
                /**
                 * Constructs a new JobProfile_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a JobProfile_out.
                 * @implements IJobProfile_out
                 * @constructor
                 * @param {CS.PROTO.IJobProfile_out=} [properties] Properties to set
                 */
                function JobProfile_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * JobProfile_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.JobProfile_out
                 * @instance
                 */
                JobProfile_out.prototype.status = 0;
    
                /**
                 * JobProfile_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.JobProfile_out
                 * @instance
                 */
                JobProfile_out.prototype.id = 0;
    
                /**
                 * JobProfile_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.JobProfile_out
                 * @instance
                 */
                JobProfile_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new JobProfile_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {CS.PROTO.IJobProfile_out=} [properties] Properties to set
                 * @returns {CS.PROTO.JobProfile_out} JobProfile_out instance
                 */
                JobProfile_out.create = function create(properties) {
                    return new JobProfile_out(properties);
                };
    
                /**
                 * Encodes the specified JobProfile_out message. Does not implicitly {@link CS.PROTO.JobProfile_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {CS.PROTO.IJobProfile_out} message JobProfile_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JobProfile_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified JobProfile_out message, length delimited. Does not implicitly {@link CS.PROTO.JobProfile_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {CS.PROTO.IJobProfile_out} message JobProfile_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JobProfile_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a JobProfile_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.JobProfile_out} JobProfile_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JobProfile_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.JobProfile_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a JobProfile_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.JobProfile_out} JobProfile_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JobProfile_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a JobProfile_out message.
                 * @function verify
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                JobProfile_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a JobProfile_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.JobProfile_out} JobProfile_out
                 */
                JobProfile_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.JobProfile_out)
                        return object;
                    var message = new $root.CS.PROTO.JobProfile_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.JobProfile_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.JobProfile_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a JobProfile_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.JobProfile_out
                 * @static
                 * @param {CS.PROTO.JobProfile_out} message JobProfile_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                JobProfile_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this JobProfile_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.JobProfile_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                JobProfile_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return JobProfile_out;
            })();
    
            /**
             * CreateJob_call enum.
             * @name CS.PROTO.CreateJob_call
             * @enum {number}
             * @property {number} Unknown_CreateJob_call=0 Unknown_CreateJob_call value
             * @property {number} CreateJob_call_SSSD=1 CreateJob_call_SSSD value
             * @property {number} CreateJob_call_SNSD=2 CreateJob_call_SNSD value
             */
            PROTO.CreateJob_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_CreateJob_call"] = 0;
                values[valuesById[1] = "CreateJob_call_SSSD"] = 1;
                values[valuesById[2] = "CreateJob_call_SNSD"] = 2;
                return values;
            })();
    
            PROTO.CreateJob_in = (function() {
    
                /**
                 * Properties of a CreateJob_in.
                 * @memberof CS.PROTO
                 * @interface ICreateJob_in
                 * @property {CS.PROTO.IAPIService|null} [control] CreateJob_in control
                 * @property {CS.PROTO.CreateJob_call|null} [method] CreateJob_in method
                 * @property {string|null} [connectionString] CreateJob_in connectionString
                 * @property {string|null} [networkLayer] CreateJob_in networkLayer
                 * @property {CS.INetworkLayerObject|null} [networkLayerObject] CreateJob_in networkLayerObject
                 * @property {string|null} [database] CreateJob_in database
                 * @property {CS.IPropertySet|null} [properties] CreateJob_in properties
                 */
    
                /**
                 * Constructs a new CreateJob_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CreateJob_in.
                 * @implements ICreateJob_in
                 * @constructor
                 * @param {CS.PROTO.ICreateJob_in=} [properties] Properties to set
                 */
                function CreateJob_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateJob_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 */
                CreateJob_in.prototype.control = null;
    
                /**
                 * CreateJob_in method.
                 * @member {CS.PROTO.CreateJob_call} method
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 */
                CreateJob_in.prototype.method = 0;
    
                /**
                 * CreateJob_in connectionString.
                 * @member {string} connectionString
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 */
                CreateJob_in.prototype.connectionString = "";
    
                /**
                 * CreateJob_in networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 */
                CreateJob_in.prototype.networkLayer = "";
    
                /**
                 * CreateJob_in networkLayerObject.
                 * @member {CS.INetworkLayerObject|null|undefined} networkLayerObject
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 */
                CreateJob_in.prototype.networkLayerObject = null;
    
                /**
                 * CreateJob_in database.
                 * @member {string} database
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 */
                CreateJob_in.prototype.database = "";
    
                /**
                 * CreateJob_in properties.
                 * @member {CS.IPropertySet|null|undefined} properties
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 */
                CreateJob_in.prototype.properties = null;
    
                /**
                 * Creates a new CreateJob_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {CS.PROTO.ICreateJob_in=} [properties] Properties to set
                 * @returns {CS.PROTO.CreateJob_in} CreateJob_in instance
                 */
                CreateJob_in.create = function create(properties) {
                    return new CreateJob_in(properties);
                };
    
                /**
                 * Encodes the specified CreateJob_in message. Does not implicitly {@link CS.PROTO.CreateJob_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {CS.PROTO.ICreateJob_in} message CreateJob_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateJob_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.connectionString);
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkLayer);
                    if (message.networkLayerObject != null && Object.hasOwnProperty.call(message, "networkLayerObject"))
                        $root.CS.NetworkLayerObject.encode(message.networkLayerObject, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.database);
                    if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                        $root.CS.PropertySet.encode(message.properties, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CreateJob_in message, length delimited. Does not implicitly {@link CS.PROTO.CreateJob_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {CS.PROTO.ICreateJob_in} message CreateJob_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateJob_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CreateJob_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CreateJob_in} CreateJob_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateJob_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CreateJob_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.connectionString = reader.string();
                            break;
                        case 4:
                            message.networkLayer = reader.string();
                            break;
                        case 5:
                            message.networkLayerObject = $root.CS.NetworkLayerObject.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.database = reader.string();
                            break;
                        case 7:
                            message.properties = $root.CS.PropertySet.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CreateJob_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CreateJob_in} CreateJob_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateJob_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CreateJob_in message.
                 * @function verify
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateJob_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                        if (!$util.isString(message.connectionString))
                            return "connectionString: string expected";
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    if (message.networkLayerObject != null && message.hasOwnProperty("networkLayerObject")) {
                        var error = $root.CS.NetworkLayerObject.verify(message.networkLayerObject);
                        if (error)
                            return "networkLayerObject." + error;
                    }
                    if (message.database != null && message.hasOwnProperty("database"))
                        if (!$util.isString(message.database))
                            return "database: string expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        var error = $root.CS.PropertySet.verify(message.properties);
                        if (error)
                            return "properties." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a CreateJob_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CreateJob_in} CreateJob_in
                 */
                CreateJob_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CreateJob_in)
                        return object;
                    var message = new $root.CS.PROTO.CreateJob_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.CreateJob_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_CreateJob_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "CreateJob_call_SSSD":
                    case 1:
                        message.method = 1;
                        break;
                    case "CreateJob_call_SNSD":
                    case 2:
                        message.method = 2;
                        break;
                    }
                    if (object.connectionString != null)
                        message.connectionString = String(object.connectionString);
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    if (object.networkLayerObject != null) {
                        if (typeof object.networkLayerObject !== "object")
                            throw TypeError(".CS.PROTO.CreateJob_in.networkLayerObject: object expected");
                        message.networkLayerObject = $root.CS.NetworkLayerObject.fromObject(object.networkLayerObject);
                    }
                    if (object.database != null)
                        message.database = String(object.database);
                    if (object.properties != null) {
                        if (typeof object.properties !== "object")
                            throw TypeError(".CS.PROTO.CreateJob_in.properties: object expected");
                        message.properties = $root.CS.PropertySet.fromObject(object.properties);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CreateJob_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CreateJob_in
                 * @static
                 * @param {CS.PROTO.CreateJob_in} message CreateJob_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateJob_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_CreateJob_call" : 0;
                        object.connectionString = "";
                        object.networkLayer = "";
                        object.networkLayerObject = null;
                        object.database = "";
                        object.properties = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.CreateJob_call[message.method] : message.method;
                    if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                        object.connectionString = message.connectionString;
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    if (message.networkLayerObject != null && message.hasOwnProperty("networkLayerObject"))
                        object.networkLayerObject = $root.CS.NetworkLayerObject.toObject(message.networkLayerObject, options);
                    if (message.database != null && message.hasOwnProperty("database"))
                        object.database = message.database;
                    if (message.properties != null && message.hasOwnProperty("properties"))
                        object.properties = $root.CS.PropertySet.toObject(message.properties, options);
                    return object;
                };
    
                /**
                 * Converts this CreateJob_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CreateJob_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateJob_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CreateJob_in;
            })();
    
            PROTO.CreateJob_out = (function() {
    
                /**
                 * Properties of a CreateJob_out.
                 * @memberof CS.PROTO
                 * @interface ICreateJob_out
                 * @property {CS.Status|null} [status] CreateJob_out status
                 * @property {number|null} [id] CreateJob_out id
                 * @property {CS.ConnectivityType|null} [type] CreateJob_out type
                 * @property {string|null} [networkLayer] CreateJob_out networkLayer
                 * @property {Array.<CS.SupportLevel>|null} [supportLevel] CreateJob_out supportLevel
                 * @property {Array.<CS.IError>|null} [errors] CreateJob_out errors
                 */
    
                /**
                 * Constructs a new CreateJob_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CreateJob_out.
                 * @implements ICreateJob_out
                 * @constructor
                 * @param {CS.PROTO.ICreateJob_out=} [properties] Properties to set
                 */
                function CreateJob_out(properties) {
                    this.supportLevel = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CreateJob_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.CreateJob_out
                 * @instance
                 */
                CreateJob_out.prototype.status = 0;
    
                /**
                 * CreateJob_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.CreateJob_out
                 * @instance
                 */
                CreateJob_out.prototype.id = 0;
    
                /**
                 * CreateJob_out type.
                 * @member {CS.ConnectivityType} type
                 * @memberof CS.PROTO.CreateJob_out
                 * @instance
                 */
                CreateJob_out.prototype.type = 0;
    
                /**
                 * CreateJob_out networkLayer.
                 * @member {string} networkLayer
                 * @memberof CS.PROTO.CreateJob_out
                 * @instance
                 */
                CreateJob_out.prototype.networkLayer = "";
    
                /**
                 * CreateJob_out supportLevel.
                 * @member {Array.<CS.SupportLevel>} supportLevel
                 * @memberof CS.PROTO.CreateJob_out
                 * @instance
                 */
                CreateJob_out.prototype.supportLevel = $util.emptyArray;
    
                /**
                 * CreateJob_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.CreateJob_out
                 * @instance
                 */
                CreateJob_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new CreateJob_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {CS.PROTO.ICreateJob_out=} [properties] Properties to set
                 * @returns {CS.PROTO.CreateJob_out} CreateJob_out instance
                 */
                CreateJob_out.create = function create(properties) {
                    return new CreateJob_out(properties);
                };
    
                /**
                 * Encodes the specified CreateJob_out message. Does not implicitly {@link CS.PROTO.CreateJob_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {CS.PROTO.ICreateJob_out} message CreateJob_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateJob_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                    if (message.networkLayer != null && Object.hasOwnProperty.call(message, "networkLayer"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkLayer);
                    if (message.supportLevel != null && message.supportLevel.length) {
                        writer.uint32(/* id 5, wireType 2 =*/42).fork();
                        for (var i = 0; i < message.supportLevel.length; ++i)
                            writer.int32(message.supportLevel[i]);
                        writer.ldelim();
                    }
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CreateJob_out message, length delimited. Does not implicitly {@link CS.PROTO.CreateJob_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {CS.PROTO.ICreateJob_out} message CreateJob_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateJob_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CreateJob_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CreateJob_out} CreateJob_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateJob_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CreateJob_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.type = reader.int32();
                            break;
                        case 4:
                            message.networkLayer = reader.string();
                            break;
                        case 5:
                            if (!(message.supportLevel && message.supportLevel.length))
                                message.supportLevel = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.supportLevel.push(reader.int32());
                            } else
                                message.supportLevel.push(reader.int32());
                            break;
                        case 6:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CreateJob_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CreateJob_out} CreateJob_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateJob_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CreateJob_out message.
                 * @function verify
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateJob_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        if (!$util.isString(message.networkLayer))
                            return "networkLayer: string expected";
                    if (message.supportLevel != null && message.hasOwnProperty("supportLevel")) {
                        if (!Array.isArray(message.supportLevel))
                            return "supportLevel: array expected";
                        for (var i = 0; i < message.supportLevel.length; ++i)
                            switch (message.supportLevel[i]) {
                            default:
                                return "supportLevel: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CreateJob_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CreateJob_out} CreateJob_out
                 */
                CreateJob_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CreateJob_out)
                        return object;
                    var message = new $root.CS.PROTO.CreateJob_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    switch (object.type) {
                    case "Unknown_ConnectivityType":
                    case 0:
                        message.type = 0;
                        break;
                    case "Relational":
                    case 1:
                        message.type = 1;
                        break;
                    case "OLAP":
                    case 2:
                        message.type = 2;
                        break;
                    case "Open":
                    case 3:
                        message.type = 3;
                        break;
                    }
                    if (object.networkLayer != null)
                        message.networkLayer = String(object.networkLayer);
                    if (object.supportLevel) {
                        if (!Array.isArray(object.supportLevel))
                            throw TypeError(".CS.PROTO.CreateJob_out.supportLevel: array expected");
                        message.supportLevel = [];
                        for (var i = 0; i < object.supportLevel.length; ++i)
                            switch (object.supportLevel[i]) {
                            default:
                            case "Unknown_SupportLevel":
                            case 0:
                                message.supportLevel[i] = 0;
                                break;
                            case "Query":
                            case 1:
                                message.supportLevel[i] = 1;
                                break;
                            case "Repository":
                            case 2:
                                message.supportLevel[i] = 2;
                                break;
                            case "StoredProcedure":
                            case 3:
                                message.supportLevel[i] = 3;
                                break;
                            case "Cancel":
                            case 4:
                                message.supportLevel[i] = 4;
                                break;
                            }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.CreateJob_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.CreateJob_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CreateJob_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CreateJob_out
                 * @static
                 * @param {CS.PROTO.CreateJob_out} message CreateJob_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateJob_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.supportLevel = [];
                        object.errors = [];
                    }
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                        object.type = options.enums === String ? "Unknown_ConnectivityType" : 0;
                        object.networkLayer = "";
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CS.ConnectivityType[message.type] : message.type;
                    if (message.networkLayer != null && message.hasOwnProperty("networkLayer"))
                        object.networkLayer = message.networkLayer;
                    if (message.supportLevel && message.supportLevel.length) {
                        object.supportLevel = [];
                        for (var j = 0; j < message.supportLevel.length; ++j)
                            object.supportLevel[j] = options.enums === String ? $root.CS.SupportLevel[message.supportLevel[j]] : message.supportLevel[j];
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CreateJob_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CreateJob_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateJob_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CreateJob_out;
            })();
    
            PROTO.GetAPIVersion_in = (function() {
    
                /**
                 * Properties of a GetAPIVersion_in.
                 * @memberof CS.PROTO
                 * @interface IGetAPIVersion_in
                 * @property {CS.PROTO.IAPIService|null} [control] GetAPIVersion_in control
                 */
    
                /**
                 * Constructs a new GetAPIVersion_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a GetAPIVersion_in.
                 * @implements IGetAPIVersion_in
                 * @constructor
                 * @param {CS.PROTO.IGetAPIVersion_in=} [properties] Properties to set
                 */
                function GetAPIVersion_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetAPIVersion_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @instance
                 */
                GetAPIVersion_in.prototype.control = null;
    
                /**
                 * Creates a new GetAPIVersion_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {CS.PROTO.IGetAPIVersion_in=} [properties] Properties to set
                 * @returns {CS.PROTO.GetAPIVersion_in} GetAPIVersion_in instance
                 */
                GetAPIVersion_in.create = function create(properties) {
                    return new GetAPIVersion_in(properties);
                };
    
                /**
                 * Encodes the specified GetAPIVersion_in message. Does not implicitly {@link CS.PROTO.GetAPIVersion_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {CS.PROTO.IGetAPIVersion_in} message GetAPIVersion_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetAPIVersion_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GetAPIVersion_in message, length delimited. Does not implicitly {@link CS.PROTO.GetAPIVersion_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {CS.PROTO.IGetAPIVersion_in} message GetAPIVersion_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetAPIVersion_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GetAPIVersion_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.GetAPIVersion_in} GetAPIVersion_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetAPIVersion_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.GetAPIVersion_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GetAPIVersion_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.GetAPIVersion_in} GetAPIVersion_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetAPIVersion_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GetAPIVersion_in message.
                 * @function verify
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetAPIVersion_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GetAPIVersion_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.GetAPIVersion_in} GetAPIVersion_in
                 */
                GetAPIVersion_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.GetAPIVersion_in)
                        return object;
                    var message = new $root.CS.PROTO.GetAPIVersion_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.GetAPIVersion_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GetAPIVersion_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @static
                 * @param {CS.PROTO.GetAPIVersion_in} message GetAPIVersion_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetAPIVersion_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this GetAPIVersion_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.GetAPIVersion_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetAPIVersion_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GetAPIVersion_in;
            })();
    
            PROTO.GetAPIVersion_out = (function() {
    
                /**
                 * Properties of a GetAPIVersion_out.
                 * @memberof CS.PROTO
                 * @interface IGetAPIVersion_out
                 * @property {CS.Status|null} [status] GetAPIVersion_out status
                 * @property {number|null} [version] GetAPIVersion_out version
                 * @property {Array.<CS.IError>|null} [errors] GetAPIVersion_out errors
                 */
    
                /**
                 * Constructs a new GetAPIVersion_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a GetAPIVersion_out.
                 * @implements IGetAPIVersion_out
                 * @constructor
                 * @param {CS.PROTO.IGetAPIVersion_out=} [properties] Properties to set
                 */
                function GetAPIVersion_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetAPIVersion_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @instance
                 */
                GetAPIVersion_out.prototype.status = 0;
    
                /**
                 * GetAPIVersion_out version.
                 * @member {number} version
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @instance
                 */
                GetAPIVersion_out.prototype.version = 0;
    
                /**
                 * GetAPIVersion_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @instance
                 */
                GetAPIVersion_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new GetAPIVersion_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {CS.PROTO.IGetAPIVersion_out=} [properties] Properties to set
                 * @returns {CS.PROTO.GetAPIVersion_out} GetAPIVersion_out instance
                 */
                GetAPIVersion_out.create = function create(properties) {
                    return new GetAPIVersion_out(properties);
                };
    
                /**
                 * Encodes the specified GetAPIVersion_out message. Does not implicitly {@link CS.PROTO.GetAPIVersion_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {CS.PROTO.IGetAPIVersion_out} message GetAPIVersion_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetAPIVersion_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GetAPIVersion_out message, length delimited. Does not implicitly {@link CS.PROTO.GetAPIVersion_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {CS.PROTO.IGetAPIVersion_out} message GetAPIVersion_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetAPIVersion_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GetAPIVersion_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.GetAPIVersion_out} GetAPIVersion_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetAPIVersion_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.GetAPIVersion_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.version = reader.uint32();
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GetAPIVersion_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.GetAPIVersion_out} GetAPIVersion_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetAPIVersion_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GetAPIVersion_out message.
                 * @function verify
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetAPIVersion_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isInteger(message.version))
                            return "version: integer expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GetAPIVersion_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.GetAPIVersion_out} GetAPIVersion_out
                 */
                GetAPIVersion_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.GetAPIVersion_out)
                        return object;
                    var message = new $root.CS.PROTO.GetAPIVersion_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.version != null)
                        message.version = object.version >>> 0;
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.GetAPIVersion_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.GetAPIVersion_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GetAPIVersion_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @static
                 * @param {CS.PROTO.GetAPIVersion_out} message GetAPIVersion_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetAPIVersion_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.version = 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GetAPIVersion_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.GetAPIVersion_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetAPIVersion_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GetAPIVersion_out;
            })();
    
            PROTO.ConnectionServerService = (function() {
    
                /**
                 * Constructs a new ConnectionServerService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ConnectionServerService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ConnectionServerService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (ConnectionServerService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConnectionServerService;
    
                /**
                 * Creates new ConnectionServerService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.ConnectionServerService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {ConnectionServerService} RPC service. Useful where requests and/or responses are streamed.
                 */
                ConnectionServerService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#internalOpenSession}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef InternalOpenSessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.OpenSession_out} [response] OpenSession_out
                 */
    
                /**
                 * Calls InternalOpenSession.
                 * @function internalOpenSession
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IOpenSession_in} request OpenSession_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.InternalOpenSessionCallback} callback Node-style callback called with the error, if any, and OpenSession_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.internalOpenSession = function internalOpenSession(request, callback) {
                    return this.rpcCall(internalOpenSession, $root.CS.PROTO.OpenSession_in, $root.CS.PROTO.OpenSession_out, request, callback);
                }, "name", { value: "InternalOpenSession" });
    
                /**
                 * Calls InternalOpenSession.
                 * @function internalOpenSession
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IOpenSession_in} request OpenSession_in message or plain object
                 * @returns {Promise<CS.PROTO.OpenSession_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#networkLayerObjects}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef NetworkLayerObjectsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.NetworkLayerObjects_out} [response] NetworkLayerObjects_out
                 */
    
                /**
                 * Calls NetworkLayerObjects.
                 * @function networkLayerObjects
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.INetworkLayerObjects_in} request NetworkLayerObjects_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.NetworkLayerObjectsCallback} callback Node-style callback called with the error, if any, and NetworkLayerObjects_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.networkLayerObjects = function networkLayerObjects(request, callback) {
                    return this.rpcCall(networkLayerObjects, $root.CS.PROTO.NetworkLayerObjects_in, $root.CS.PROTO.NetworkLayerObjects_out, request, callback);
                }, "name", { value: "NetworkLayerObjects" });
    
                /**
                 * Calls NetworkLayerObjects.
                 * @function networkLayerObjects
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.INetworkLayerObjects_in} request NetworkLayerObjects_in message or plain object
                 * @returns {Promise<CS.PROTO.NetworkLayerObjects_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#networkLayers}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef NetworkLayersCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.NetworkLayers_out} [response] NetworkLayers_out
                 */
    
                /**
                 * Calls NetworkLayers.
                 * @function networkLayers
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.INetworkLayers_in} request NetworkLayers_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.NetworkLayersCallback} callback Node-style callback called with the error, if any, and NetworkLayers_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.networkLayers = function networkLayers(request, callback) {
                    return this.rpcCall(networkLayers, $root.CS.PROTO.NetworkLayers_in, $root.CS.PROTO.NetworkLayers_out, request, callback);
                }, "name", { value: "NetworkLayers" });
    
                /**
                 * Calls NetworkLayers.
                 * @function networkLayers
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.INetworkLayers_in} request NetworkLayers_in message or plain object
                 * @returns {Promise<CS.PROTO.NetworkLayers_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#dataBases}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef DataBasesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.DataBases_out} [response] DataBases_out
                 */
    
                /**
                 * Calls DataBases.
                 * @function dataBases
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IDataBases_in} request DataBases_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.DataBasesCallback} callback Node-style callback called with the error, if any, and DataBases_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.dataBases = function dataBases(request, callback) {
                    return this.rpcCall(dataBases, $root.CS.PROTO.DataBases_in, $root.CS.PROTO.DataBases_out, request, callback);
                }, "name", { value: "DataBases" });
    
                /**
                 * Calls DataBases.
                 * @function dataBases
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IDataBases_in} request DataBases_in message or plain object
                 * @returns {Promise<CS.PROTO.DataBases_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#connectivityKind}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef ConnectivityKindCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.ConnectivityKind_out} [response] ConnectivityKind_out
                 */
    
                /**
                 * Calls ConnectivityKind.
                 * @function connectivityKind
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IConnectivityKind_in} request ConnectivityKind_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.ConnectivityKindCallback} callback Node-style callback called with the error, if any, and ConnectivityKind_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.connectivityKind = function connectivityKind(request, callback) {
                    return this.rpcCall(connectivityKind, $root.CS.PROTO.ConnectivityKind_in, $root.CS.PROTO.ConnectivityKind_out, request, callback);
                }, "name", { value: "ConnectivityKind" });
    
                /**
                 * Calls ConnectivityKind.
                 * @function connectivityKind
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IConnectivityKind_in} request ConnectivityKind_in message or plain object
                 * @returns {Promise<CS.PROTO.ConnectivityKind_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#connectivityList}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef ConnectivityListCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.ConnectivityList_out} [response] ConnectivityList_out
                 */
    
                /**
                 * Calls ConnectivityList.
                 * @function connectivityList
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IConnectivityList_in} request ConnectivityList_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.ConnectivityListCallback} callback Node-style callback called with the error, if any, and ConnectivityList_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.connectivityList = function connectivityList(request, callback) {
                    return this.rpcCall(connectivityList, $root.CS.PROTO.ConnectivityList_in, $root.CS.PROTO.ConnectivityList_out, request, callback);
                }, "name", { value: "ConnectivityList" });
    
                /**
                 * Calls ConnectivityList.
                 * @function connectivityList
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IConnectivityList_in} request ConnectivityList_in message or plain object
                 * @returns {Promise<CS.PROTO.ConnectivityList_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#internalGetLocale}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef InternalGetLocaleCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalGetLocale_out} [response] InternalGetLocale_out
                 */
    
                /**
                 * Calls InternalGetLocale.
                 * @function internalGetLocale
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalGetLocale_in} request InternalGetLocale_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.InternalGetLocaleCallback} callback Node-style callback called with the error, if any, and InternalGetLocale_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.internalGetLocale = function internalGetLocale(request, callback) {
                    return this.rpcCall(internalGetLocale, $root.CS.PROTO.InternalGetLocale_in, $root.CS.PROTO.InternalGetLocale_out, request, callback);
                }, "name", { value: "InternalGetLocale" });
    
                /**
                 * Calls InternalGetLocale.
                 * @function internalGetLocale
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalGetLocale_in} request InternalGetLocale_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalGetLocale_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#internalGetCurrentLocale}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef InternalGetCurrentLocaleCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalGetCurrentLocale_out} [response] InternalGetCurrentLocale_out
                 */
    
                /**
                 * Calls InternalGetCurrentLocale.
                 * @function internalGetCurrentLocale
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalGetCurrentLocale_in} request InternalGetCurrentLocale_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.InternalGetCurrentLocaleCallback} callback Node-style callback called with the error, if any, and InternalGetCurrentLocale_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.internalGetCurrentLocale = function internalGetCurrentLocale(request, callback) {
                    return this.rpcCall(internalGetCurrentLocale, $root.CS.PROTO.InternalGetCurrentLocale_in, $root.CS.PROTO.InternalGetCurrentLocale_out, request, callback);
                }, "name", { value: "InternalGetCurrentLocale" });
    
                /**
                 * Calls InternalGetCurrentLocale.
                 * @function internalGetCurrentLocale
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalGetCurrentLocale_in} request InternalGetCurrentLocale_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalGetCurrentLocale_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#internalSetCurrentLocale}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef InternalSetCurrentLocaleCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalSetCurrentLocale_out} [response] InternalSetCurrentLocale_out
                 */
    
                /**
                 * Calls InternalSetCurrentLocale.
                 * @function internalSetCurrentLocale
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalSetCurrentLocale_in} request InternalSetCurrentLocale_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.InternalSetCurrentLocaleCallback} callback Node-style callback called with the error, if any, and InternalSetCurrentLocale_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.internalSetCurrentLocale = function internalSetCurrentLocale(request, callback) {
                    return this.rpcCall(internalSetCurrentLocale, $root.CS.PROTO.InternalSetCurrentLocale_in, $root.CS.PROTO.InternalSetCurrentLocale_out, request, callback);
                }, "name", { value: "InternalSetCurrentLocale" });
    
                /**
                 * Calls InternalSetCurrentLocale.
                 * @function internalSetCurrentLocale
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalSetCurrentLocale_in} request InternalSetCurrentLocale_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalSetCurrentLocale_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#dictionaryProfile}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef DictionaryProfileCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.DictionaryProfile_out} [response] DictionaryProfile_out
                 */
    
                /**
                 * Calls DictionaryProfile.
                 * @function dictionaryProfile
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IDictionaryProfile_in} request DictionaryProfile_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.DictionaryProfileCallback} callback Node-style callback called with the error, if any, and DictionaryProfile_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.dictionaryProfile = function dictionaryProfile(request, callback) {
                    return this.rpcCall(dictionaryProfile, $root.CS.PROTO.DictionaryProfile_in, $root.CS.PROTO.DictionaryProfile_out, request, callback);
                }, "name", { value: "DictionaryProfile" });
    
                /**
                 * Calls DictionaryProfile.
                 * @function dictionaryProfile
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IDictionaryProfile_in} request DictionaryProfile_in message or plain object
                 * @returns {Promise<CS.PROTO.DictionaryProfile_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#internalSQLBinding}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef InternalSQLBindingCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalSQLBinding_out} [response] InternalSQLBinding_out
                 */
    
                /**
                 * Calls InternalSQLBinding.
                 * @function internalSQLBinding
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalSQLBinding_in} request InternalSQLBinding_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.InternalSQLBindingCallback} callback Node-style callback called with the error, if any, and InternalSQLBinding_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.internalSQLBinding = function internalSQLBinding(request, callback) {
                    return this.rpcCall(internalSQLBinding, $root.CS.PROTO.InternalSQLBinding_in, $root.CS.PROTO.InternalSQLBinding_out, request, callback);
                }, "name", { value: "InternalSQLBinding" });
    
                /**
                 * Calls InternalSQLBinding.
                 * @function internalSQLBinding
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IInternalSQLBinding_in} request InternalSQLBinding_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalSQLBinding_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#createConnectionManager}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef CreateConnectionManagerCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.CreateConnectionManager_out} [response] CreateConnectionManager_out
                 */
    
                /**
                 * Calls CreateConnectionManager.
                 * @function createConnectionManager
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.ICreateConnectionManager_in} request CreateConnectionManager_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.CreateConnectionManagerCallback} callback Node-style callback called with the error, if any, and CreateConnectionManager_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.createConnectionManager = function createConnectionManager(request, callback) {
                    return this.rpcCall(createConnectionManager, $root.CS.PROTO.CreateConnectionManager_in, $root.CS.PROTO.CreateConnectionManager_out, request, callback);
                }, "name", { value: "CreateConnectionManager" });
    
                /**
                 * Calls CreateConnectionManager.
                 * @function createConnectionManager
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.ICreateConnectionManager_in} request CreateConnectionManager_in message or plain object
                 * @returns {Promise<CS.PROTO.CreateConnectionManager_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#createDictionary}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef CreateDictionaryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.CreateDictionary_out} [response] CreateDictionary_out
                 */
    
                /**
                 * Calls CreateDictionary.
                 * @function createDictionary
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.ICreateDictionary_in} request CreateDictionary_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.CreateDictionaryCallback} callback Node-style callback called with the error, if any, and CreateDictionary_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.createDictionary = function createDictionary(request, callback) {
                    return this.rpcCall(createDictionary, $root.CS.PROTO.CreateDictionary_in, $root.CS.PROTO.CreateDictionary_out, request, callback);
                }, "name", { value: "CreateDictionary" });
    
                /**
                 * Calls CreateDictionary.
                 * @function createDictionary
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.ICreateDictionary_in} request CreateDictionary_in message or plain object
                 * @returns {Promise<CS.PROTO.CreateDictionary_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#jobProfile}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef JobProfileCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.JobProfile_out} [response] JobProfile_out
                 */
    
                /**
                 * Calls JobProfile.
                 * @function jobProfile
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IJobProfile_in} request JobProfile_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.JobProfileCallback} callback Node-style callback called with the error, if any, and JobProfile_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.jobProfile = function jobProfile(request, callback) {
                    return this.rpcCall(jobProfile, $root.CS.PROTO.JobProfile_in, $root.CS.PROTO.JobProfile_out, request, callback);
                }, "name", { value: "JobProfile" });
    
                /**
                 * Calls JobProfile.
                 * @function jobProfile
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.IJobProfile_in} request JobProfile_in message or plain object
                 * @returns {Promise<CS.PROTO.JobProfile_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ConnectionServerService#createJob}.
                 * @memberof CS.PROTO.ConnectionServerService
                 * @typedef CreateJobCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.CreateJob_out} [response] CreateJob_out
                 */
    
                /**
                 * Calls CreateJob.
                 * @function createJob
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.ICreateJob_in} request CreateJob_in message or plain object
                 * @param {CS.PROTO.ConnectionServerService.CreateJobCallback} callback Node-style callback called with the error, if any, and CreateJob_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ConnectionServerService.prototype.createJob = function createJob(request, callback) {
                    return this.rpcCall(createJob, $root.CS.PROTO.CreateJob_in, $root.CS.PROTO.CreateJob_out, request, callback);
                }, "name", { value: "CreateJob" });
    
                /**
                 * Calls CreateJob.
                 * @function createJob
                 * @memberof CS.PROTO.ConnectionServerService
                 * @instance
                 * @param {CS.PROTO.ICreateJob_in} request CreateJob_in message or plain object
                 * @returns {Promise<CS.PROTO.CreateJob_out>} Promise
                 * @variation 2
                 */
    
                return ConnectionServerService;
            })();
    
            PROTO.DbParameters_in = (function() {
    
                /**
                 * Properties of a DbParameters_in.
                 * @memberof CS.PROTO
                 * @interface IDbParameters_in
                 * @property {CS.PROTO.IAPIService|null} [control] DbParameters_in control
                 * @property {CS.ILocaleDescriptor|null} [locale] DbParameters_in locale
                 */
    
                /**
                 * Constructs a new DbParameters_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DbParameters_in.
                 * @implements IDbParameters_in
                 * @constructor
                 * @param {CS.PROTO.IDbParameters_in=} [properties] Properties to set
                 */
                function DbParameters_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DbParameters_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.DbParameters_in
                 * @instance
                 */
                DbParameters_in.prototype.control = null;
    
                /**
                 * DbParameters_in locale.
                 * @member {CS.ILocaleDescriptor|null|undefined} locale
                 * @memberof CS.PROTO.DbParameters_in
                 * @instance
                 */
                DbParameters_in.prototype.locale = null;
    
                /**
                 * Creates a new DbParameters_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {CS.PROTO.IDbParameters_in=} [properties] Properties to set
                 * @returns {CS.PROTO.DbParameters_in} DbParameters_in instance
                 */
                DbParameters_in.create = function create(properties) {
                    return new DbParameters_in(properties);
                };
    
                /**
                 * Encodes the specified DbParameters_in message. Does not implicitly {@link CS.PROTO.DbParameters_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {CS.PROTO.IDbParameters_in} message DbParameters_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DbParameters_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                        $root.CS.LocaleDescriptor.encode(message.locale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DbParameters_in message, length delimited. Does not implicitly {@link CS.PROTO.DbParameters_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {CS.PROTO.IDbParameters_in} message DbParameters_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DbParameters_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DbParameters_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DbParameters_in} DbParameters_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DbParameters_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DbParameters_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DbParameters_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DbParameters_in} DbParameters_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DbParameters_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DbParameters_in message.
                 * @function verify
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DbParameters_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.locale != null && message.hasOwnProperty("locale")) {
                        var error = $root.CS.LocaleDescriptor.verify(message.locale);
                        if (error)
                            return "locale." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DbParameters_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DbParameters_in} DbParameters_in
                 */
                DbParameters_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DbParameters_in)
                        return object;
                    var message = new $root.CS.PROTO.DbParameters_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.DbParameters_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.locale != null) {
                        if (typeof object.locale !== "object")
                            throw TypeError(".CS.PROTO.DbParameters_in.locale: object expected");
                        message.locale = $root.CS.LocaleDescriptor.fromObject(object.locale);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DbParameters_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DbParameters_in
                 * @static
                 * @param {CS.PROTO.DbParameters_in} message DbParameters_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DbParameters_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.locale = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.locale != null && message.hasOwnProperty("locale"))
                        object.locale = $root.CS.LocaleDescriptor.toObject(message.locale, options);
                    return object;
                };
    
                /**
                 * Converts this DbParameters_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DbParameters_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DbParameters_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DbParameters_in;
            })();
    
            PROTO.DbParameters_out = (function() {
    
                /**
                 * Properties of a DbParameters_out.
                 * @memberof CS.PROTO
                 * @interface IDbParameters_out
                 * @property {CS.Status|null} [status] DbParameters_out status
                 * @property {Array.<CS.IDomainParameterSet>|null} [parameters] DbParameters_out parameters
                 * @property {Array.<CS.IError>|null} [errors] DbParameters_out errors
                 */
    
                /**
                 * Constructs a new DbParameters_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DbParameters_out.
                 * @implements IDbParameters_out
                 * @constructor
                 * @param {CS.PROTO.IDbParameters_out=} [properties] Properties to set
                 */
                function DbParameters_out(properties) {
                    this.parameters = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DbParameters_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.DbParameters_out
                 * @instance
                 */
                DbParameters_out.prototype.status = 0;
    
                /**
                 * DbParameters_out parameters.
                 * @member {Array.<CS.IDomainParameterSet>} parameters
                 * @memberof CS.PROTO.DbParameters_out
                 * @instance
                 */
                DbParameters_out.prototype.parameters = $util.emptyArray;
    
                /**
                 * DbParameters_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.DbParameters_out
                 * @instance
                 */
                DbParameters_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new DbParameters_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {CS.PROTO.IDbParameters_out=} [properties] Properties to set
                 * @returns {CS.PROTO.DbParameters_out} DbParameters_out instance
                 */
                DbParameters_out.create = function create(properties) {
                    return new DbParameters_out(properties);
                };
    
                /**
                 * Encodes the specified DbParameters_out message. Does not implicitly {@link CS.PROTO.DbParameters_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {CS.PROTO.IDbParameters_out} message DbParameters_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DbParameters_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.parameters != null && message.parameters.length)
                        for (var i = 0; i < message.parameters.length; ++i)
                            $root.CS.DomainParameterSet.encode(message.parameters[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DbParameters_out message, length delimited. Does not implicitly {@link CS.PROTO.DbParameters_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {CS.PROTO.IDbParameters_out} message DbParameters_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DbParameters_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DbParameters_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.DbParameters_out} DbParameters_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DbParameters_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.DbParameters_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.parameters && message.parameters.length))
                                message.parameters = [];
                            message.parameters.push($root.CS.DomainParameterSet.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DbParameters_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.DbParameters_out} DbParameters_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DbParameters_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DbParameters_out message.
                 * @function verify
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DbParameters_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!Array.isArray(message.parameters))
                            return "parameters: array expected";
                        for (var i = 0; i < message.parameters.length; ++i) {
                            var error = $root.CS.DomainParameterSet.verify(message.parameters[i]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DbParameters_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.DbParameters_out} DbParameters_out
                 */
                DbParameters_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.DbParameters_out)
                        return object;
                    var message = new $root.CS.PROTO.DbParameters_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.parameters) {
                        if (!Array.isArray(object.parameters))
                            throw TypeError(".CS.PROTO.DbParameters_out.parameters: array expected");
                        message.parameters = [];
                        for (var i = 0; i < object.parameters.length; ++i) {
                            if (typeof object.parameters[i] !== "object")
                                throw TypeError(".CS.PROTO.DbParameters_out.parameters: object expected");
                            message.parameters[i] = $root.CS.DomainParameterSet.fromObject(object.parameters[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.DbParameters_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.DbParameters_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DbParameters_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.DbParameters_out
                 * @static
                 * @param {CS.PROTO.DbParameters_out} message DbParameters_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DbParameters_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.parameters = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.parameters && message.parameters.length) {
                        object.parameters = [];
                        for (var j = 0; j < message.parameters.length; ++j)
                            object.parameters[j] = $root.CS.DomainParameterSet.toObject(message.parameters[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this DbParameters_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.DbParameters_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DbParameters_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DbParameters_out;
            })();
    
            PROTO.DictionaryDescriptorService = (function() {
    
                /**
                 * Constructs a new DictionaryDescriptorService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DictionaryDescriptorService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function DictionaryDescriptorService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (DictionaryDescriptorService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DictionaryDescriptorService;
    
                /**
                 * Creates new DictionaryDescriptorService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {DictionaryDescriptorService} RPC service. Useful where requests and/or responses are streamed.
                 */
                DictionaryDescriptorService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.DictionaryDescriptorService#supportKind}.
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @typedef SupportKindCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.SupportKind_out} [response] SupportKind_out
                 */
    
                /**
                 * Calls SupportKind.
                 * @function supportKind
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.ISupportKind_in} request SupportKind_in message or plain object
                 * @param {CS.PROTO.DictionaryDescriptorService.SupportKindCallback} callback Node-style callback called with the error, if any, and SupportKind_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DictionaryDescriptorService.prototype.supportKind = function supportKind(request, callback) {
                    return this.rpcCall(supportKind, $root.CS.PROTO.SupportKind_in, $root.CS.PROTO.SupportKind_out, request, callback);
                }, "name", { value: "SupportKind" });
    
                /**
                 * Calls SupportKind.
                 * @function supportKind
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.ISupportKind_in} request SupportKind_in message or plain object
                 * @returns {Promise<CS.PROTO.SupportKind_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.DictionaryDescriptorService#connectivityKind}.
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @typedef ConnectivityKindCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.ConnectivityKind_out} [response] ConnectivityKind_out
                 */
    
                /**
                 * Calls ConnectivityKind.
                 * @function connectivityKind
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.IConnectivityKind_in} request ConnectivityKind_in message or plain object
                 * @param {CS.PROTO.DictionaryDescriptorService.ConnectivityKindCallback} callback Node-style callback called with the error, if any, and ConnectivityKind_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DictionaryDescriptorService.prototype.connectivityKind = function connectivityKind(request, callback) {
                    return this.rpcCall(connectivityKind, $root.CS.PROTO.ConnectivityKind_in, $root.CS.PROTO.ConnectivityKind_out, request, callback);
                }, "name", { value: "ConnectivityKind" });
    
                /**
                 * Calls ConnectivityKind.
                 * @function connectivityKind
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.IConnectivityKind_in} request ConnectivityKind_in message or plain object
                 * @returns {Promise<CS.PROTO.ConnectivityKind_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.DictionaryDescriptorService#cancelSupportKind}.
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @typedef CancelSupportKindCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.CancelSupportKind_out} [response] CancelSupportKind_out
                 */
    
                /**
                 * Calls CancelSupportKind.
                 * @function cancelSupportKind
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.ICancelSupportKind_in} request CancelSupportKind_in message or plain object
                 * @param {CS.PROTO.DictionaryDescriptorService.CancelSupportKindCallback} callback Node-style callback called with the error, if any, and CancelSupportKind_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DictionaryDescriptorService.prototype.cancelSupportKind = function cancelSupportKind(request, callback) {
                    return this.rpcCall(cancelSupportKind, $root.CS.PROTO.CancelSupportKind_in, $root.CS.PROTO.CancelSupportKind_out, request, callback);
                }, "name", { value: "CancelSupportKind" });
    
                /**
                 * Calls CancelSupportKind.
                 * @function cancelSupportKind
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.ICancelSupportKind_in} request CancelSupportKind_in message or plain object
                 * @returns {Promise<CS.PROTO.CancelSupportKind_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.DictionaryDescriptorService#dictionaryProperties}.
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @typedef DictionaryPropertiesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.DictionaryProperties_out} [response] DictionaryProperties_out
                 */
    
                /**
                 * Calls DictionaryProperties.
                 * @function dictionaryProperties
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.IDictionaryProperties_in} request DictionaryProperties_in message or plain object
                 * @param {CS.PROTO.DictionaryDescriptorService.DictionaryPropertiesCallback} callback Node-style callback called with the error, if any, and DictionaryProperties_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DictionaryDescriptorService.prototype.dictionaryProperties = function dictionaryProperties(request, callback) {
                    return this.rpcCall(dictionaryProperties, $root.CS.PROTO.DictionaryProperties_in, $root.CS.PROTO.DictionaryProperties_out, request, callback);
                }, "name", { value: "DictionaryProperties" });
    
                /**
                 * Calls DictionaryProperties.
                 * @function dictionaryProperties
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.IDictionaryProperties_in} request DictionaryProperties_in message or plain object
                 * @returns {Promise<CS.PROTO.DictionaryProperties_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.DictionaryDescriptorService#dbParameters}.
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @typedef DbParametersCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.DbParameters_out} [response] DbParameters_out
                 */
    
                /**
                 * Calls DbParameters.
                 * @function dbParameters
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.IDbParameters_in} request DbParameters_in message or plain object
                 * @param {CS.PROTO.DictionaryDescriptorService.DbParametersCallback} callback Node-style callback called with the error, if any, and DbParameters_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DictionaryDescriptorService.prototype.dbParameters = function dbParameters(request, callback) {
                    return this.rpcCall(dbParameters, $root.CS.PROTO.DbParameters_in, $root.CS.PROTO.DbParameters_out, request, callback);
                }, "name", { value: "DbParameters" });
    
                /**
                 * Calls DbParameters.
                 * @function dbParameters
                 * @memberof CS.PROTO.DictionaryDescriptorService
                 * @instance
                 * @param {CS.PROTO.IDbParameters_in} request DbParameters_in message or plain object
                 * @returns {Promise<CS.PROTO.DbParameters_out>} Promise
                 * @variation 2
                 */
    
                return DictionaryDescriptorService;
            })();
    
            PROTO.GetNextResultSetSlice_in = (function() {
    
                /**
                 * Properties of a GetNextResultSetSlice_in.
                 * @memberof CS.PROTO
                 * @interface IGetNextResultSetSlice_in
                 * @property {CS.PROTO.IAPIService|null} [control] GetNextResultSetSlice_in control
                 * @property {number|null} [count] GetNextResultSetSlice_in count
                 */
    
                /**
                 * Constructs a new GetNextResultSetSlice_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a GetNextResultSetSlice_in.
                 * @implements IGetNextResultSetSlice_in
                 * @constructor
                 * @param {CS.PROTO.IGetNextResultSetSlice_in=} [properties] Properties to set
                 */
                function GetNextResultSetSlice_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetNextResultSetSlice_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @instance
                 */
                GetNextResultSetSlice_in.prototype.control = null;
    
                /**
                 * GetNextResultSetSlice_in count.
                 * @member {number} count
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @instance
                 */
                GetNextResultSetSlice_in.prototype.count = 0;
    
                /**
                 * Creates a new GetNextResultSetSlice_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {CS.PROTO.IGetNextResultSetSlice_in=} [properties] Properties to set
                 * @returns {CS.PROTO.GetNextResultSetSlice_in} GetNextResultSetSlice_in instance
                 */
                GetNextResultSetSlice_in.create = function create(properties) {
                    return new GetNextResultSetSlice_in(properties);
                };
    
                /**
                 * Encodes the specified GetNextResultSetSlice_in message. Does not implicitly {@link CS.PROTO.GetNextResultSetSlice_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {CS.PROTO.IGetNextResultSetSlice_in} message GetNextResultSetSlice_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNextResultSetSlice_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
                    return writer;
                };
    
                /**
                 * Encodes the specified GetNextResultSetSlice_in message, length delimited. Does not implicitly {@link CS.PROTO.GetNextResultSetSlice_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {CS.PROTO.IGetNextResultSetSlice_in} message GetNextResultSetSlice_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNextResultSetSlice_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GetNextResultSetSlice_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.GetNextResultSetSlice_in} GetNextResultSetSlice_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNextResultSetSlice_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.GetNextResultSetSlice_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.count = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GetNextResultSetSlice_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.GetNextResultSetSlice_in} GetNextResultSetSlice_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNextResultSetSlice_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GetNextResultSetSlice_in message.
                 * @function verify
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetNextResultSetSlice_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.count != null && message.hasOwnProperty("count"))
                        if (!$util.isInteger(message.count))
                            return "count: integer expected";
                    return null;
                };
    
                /**
                 * Creates a GetNextResultSetSlice_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.GetNextResultSetSlice_in} GetNextResultSetSlice_in
                 */
                GetNextResultSetSlice_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.GetNextResultSetSlice_in)
                        return object;
                    var message = new $root.CS.PROTO.GetNextResultSetSlice_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.GetNextResultSetSlice_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.count != null)
                        message.count = object.count >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a GetNextResultSetSlice_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @static
                 * @param {CS.PROTO.GetNextResultSetSlice_in} message GetNextResultSetSlice_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetNextResultSetSlice_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.count = 0;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.count != null && message.hasOwnProperty("count"))
                        object.count = message.count;
                    return object;
                };
    
                /**
                 * Converts this GetNextResultSetSlice_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.GetNextResultSetSlice_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetNextResultSetSlice_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GetNextResultSetSlice_in;
            })();
    
            PROTO.GetNextResultSetSlice_out = (function() {
    
                /**
                 * Properties of a GetNextResultSetSlice_out.
                 * @memberof CS.PROTO
                 * @interface IGetNextResultSetSlice_out
                 * @property {CS.Status|null} [status] GetNextResultSetSlice_out status
                 * @property {Array.<CS.IRecord>|null} [records] GetNextResultSetSlice_out records
                 * @property {Array.<CS.IError>|null} [errors] GetNextResultSetSlice_out errors
                 */
    
                /**
                 * Constructs a new GetNextResultSetSlice_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a GetNextResultSetSlice_out.
                 * @implements IGetNextResultSetSlice_out
                 * @constructor
                 * @param {CS.PROTO.IGetNextResultSetSlice_out=} [properties] Properties to set
                 */
                function GetNextResultSetSlice_out(properties) {
                    this.records = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetNextResultSetSlice_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @instance
                 */
                GetNextResultSetSlice_out.prototype.status = 0;
    
                /**
                 * GetNextResultSetSlice_out records.
                 * @member {Array.<CS.IRecord>} records
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @instance
                 */
                GetNextResultSetSlice_out.prototype.records = $util.emptyArray;
    
                /**
                 * GetNextResultSetSlice_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @instance
                 */
                GetNextResultSetSlice_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new GetNextResultSetSlice_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {CS.PROTO.IGetNextResultSetSlice_out=} [properties] Properties to set
                 * @returns {CS.PROTO.GetNextResultSetSlice_out} GetNextResultSetSlice_out instance
                 */
                GetNextResultSetSlice_out.create = function create(properties) {
                    return new GetNextResultSetSlice_out(properties);
                };
    
                /**
                 * Encodes the specified GetNextResultSetSlice_out message. Does not implicitly {@link CS.PROTO.GetNextResultSetSlice_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {CS.PROTO.IGetNextResultSetSlice_out} message GetNextResultSetSlice_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNextResultSetSlice_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.records != null && message.records.length)
                        for (var i = 0; i < message.records.length; ++i)
                            $root.CS.Record.encode(message.records[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GetNextResultSetSlice_out message, length delimited. Does not implicitly {@link CS.PROTO.GetNextResultSetSlice_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {CS.PROTO.IGetNextResultSetSlice_out} message GetNextResultSetSlice_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNextResultSetSlice_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GetNextResultSetSlice_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.GetNextResultSetSlice_out} GetNextResultSetSlice_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNextResultSetSlice_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.GetNextResultSetSlice_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.records && message.records.length))
                                message.records = [];
                            message.records.push($root.CS.Record.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GetNextResultSetSlice_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.GetNextResultSetSlice_out} GetNextResultSetSlice_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNextResultSetSlice_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GetNextResultSetSlice_out message.
                 * @function verify
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetNextResultSetSlice_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.records != null && message.hasOwnProperty("records")) {
                        if (!Array.isArray(message.records))
                            return "records: array expected";
                        for (var i = 0; i < message.records.length; ++i) {
                            var error = $root.CS.Record.verify(message.records[i]);
                            if (error)
                                return "records." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GetNextResultSetSlice_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.GetNextResultSetSlice_out} GetNextResultSetSlice_out
                 */
                GetNextResultSetSlice_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.GetNextResultSetSlice_out)
                        return object;
                    var message = new $root.CS.PROTO.GetNextResultSetSlice_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.records) {
                        if (!Array.isArray(object.records))
                            throw TypeError(".CS.PROTO.GetNextResultSetSlice_out.records: array expected");
                        message.records = [];
                        for (var i = 0; i < object.records.length; ++i) {
                            if (typeof object.records[i] !== "object")
                                throw TypeError(".CS.PROTO.GetNextResultSetSlice_out.records: object expected");
                            message.records[i] = $root.CS.Record.fromObject(object.records[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.GetNextResultSetSlice_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.GetNextResultSetSlice_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GetNextResultSetSlice_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @static
                 * @param {CS.PROTO.GetNextResultSetSlice_out} message GetNextResultSetSlice_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetNextResultSetSlice_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.records = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.records && message.records.length) {
                        object.records = [];
                        for (var j = 0; j < message.records.length; ++j)
                            object.records[j] = $root.CS.Record.toObject(message.records[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GetNextResultSetSlice_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.GetNextResultSetSlice_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetNextResultSetSlice_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GetNextResultSetSlice_out;
            })();
    
            PROTO.DataStreamingService = (function() {
    
                /**
                 * Constructs a new DataStreamingService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a DataStreamingService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function DataStreamingService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (DataStreamingService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DataStreamingService;
    
                /**
                 * Creates new DataStreamingService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.DataStreamingService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {DataStreamingService} RPC service. Useful where requests and/or responses are streamed.
                 */
                DataStreamingService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.DataStreamingService#getNextResultSetSlice}.
                 * @memberof CS.PROTO.DataStreamingService
                 * @typedef GetNextResultSetSliceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.GetNextResultSetSlice_out} [response] GetNextResultSetSlice_out
                 */
    
                /**
                 * Calls GetNextResultSetSlice.
                 * @function getNextResultSetSlice
                 * @memberof CS.PROTO.DataStreamingService
                 * @instance
                 * @param {CS.PROTO.IGetNextResultSetSlice_in} request GetNextResultSetSlice_in message or plain object
                 * @param {CS.PROTO.DataStreamingService.GetNextResultSetSliceCallback} callback Node-style callback called with the error, if any, and GetNextResultSetSlice_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DataStreamingService.prototype.getNextResultSetSlice = function getNextResultSetSlice(request, callback) {
                    return this.rpcCall(getNextResultSetSlice, $root.CS.PROTO.GetNextResultSetSlice_in, $root.CS.PROTO.GetNextResultSetSlice_out, request, callback);
                }, "name", { value: "GetNextResultSetSlice" });
    
                /**
                 * Calls GetNextResultSetSlice.
                 * @function getNextResultSetSlice
                 * @memberof CS.PROTO.DataStreamingService
                 * @instance
                 * @param {CS.PROTO.IGetNextResultSetSlice_in} request GetNextResultSetSlice_in message or plain object
                 * @returns {Promise<CS.PROTO.GetNextResultSetSlice_out>} Promise
                 * @variation 2
                 */
    
                return DataStreamingService;
            })();
    
            PROTO.HealthReport = (function() {
    
                /**
                 * Properties of a HealthReport.
                 * @memberof CS.PROTO
                 * @interface IHealthReport
                 * @property {string|null} [session] HealthReport session
                 * @property {number|Long|null} [lastAccessTime] HealthReport lastAccessTime
                 * @property {number|null} [objId] HealthReport objId
                 * @property {string|null} [objType] HealthReport objType
                 */
    
                /**
                 * Constructs a new HealthReport.
                 * @memberof CS.PROTO
                 * @classdesc Represents a HealthReport.
                 * @implements IHealthReport
                 * @constructor
                 * @param {CS.PROTO.IHealthReport=} [properties] Properties to set
                 */
                function HealthReport(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * HealthReport session.
                 * @member {string} session
                 * @memberof CS.PROTO.HealthReport
                 * @instance
                 */
                HealthReport.prototype.session = "";
    
                /**
                 * HealthReport lastAccessTime.
                 * @member {number|Long} lastAccessTime
                 * @memberof CS.PROTO.HealthReport
                 * @instance
                 */
                HealthReport.prototype.lastAccessTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * HealthReport objId.
                 * @member {number} objId
                 * @memberof CS.PROTO.HealthReport
                 * @instance
                 */
                HealthReport.prototype.objId = 0;
    
                /**
                 * HealthReport objType.
                 * @member {string} objType
                 * @memberof CS.PROTO.HealthReport
                 * @instance
                 */
                HealthReport.prototype.objType = "";
    
                /**
                 * Creates a new HealthReport instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {CS.PROTO.IHealthReport=} [properties] Properties to set
                 * @returns {CS.PROTO.HealthReport} HealthReport instance
                 */
                HealthReport.create = function create(properties) {
                    return new HealthReport(properties);
                };
    
                /**
                 * Encodes the specified HealthReport message. Does not implicitly {@link CS.PROTO.HealthReport.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {CS.PROTO.IHealthReport} message HealthReport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthReport.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.session);
                    if (message.lastAccessTime != null && Object.hasOwnProperty.call(message, "lastAccessTime"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastAccessTime);
                    if (message.objId != null && Object.hasOwnProperty.call(message, "objId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.objId);
                    if (message.objType != null && Object.hasOwnProperty.call(message, "objType"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.objType);
                    return writer;
                };
    
                /**
                 * Encodes the specified HealthReport message, length delimited. Does not implicitly {@link CS.PROTO.HealthReport.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {CS.PROTO.IHealthReport} message HealthReport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthReport.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a HealthReport message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.HealthReport} HealthReport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthReport.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.HealthReport();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.session = reader.string();
                            break;
                        case 2:
                            message.lastAccessTime = reader.uint64();
                            break;
                        case 3:
                            message.objId = reader.uint32();
                            break;
                        case 4:
                            message.objType = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a HealthReport message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.HealthReport} HealthReport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthReport.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a HealthReport message.
                 * @function verify
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HealthReport.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.session != null && message.hasOwnProperty("session"))
                        if (!$util.isString(message.session))
                            return "session: string expected";
                    if (message.lastAccessTime != null && message.hasOwnProperty("lastAccessTime"))
                        if (!$util.isInteger(message.lastAccessTime) && !(message.lastAccessTime && $util.isInteger(message.lastAccessTime.low) && $util.isInteger(message.lastAccessTime.high)))
                            return "lastAccessTime: integer|Long expected";
                    if (message.objId != null && message.hasOwnProperty("objId"))
                        if (!$util.isInteger(message.objId))
                            return "objId: integer expected";
                    if (message.objType != null && message.hasOwnProperty("objType"))
                        if (!$util.isString(message.objType))
                            return "objType: string expected";
                    return null;
                };
    
                /**
                 * Creates a HealthReport message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.HealthReport} HealthReport
                 */
                HealthReport.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.HealthReport)
                        return object;
                    var message = new $root.CS.PROTO.HealthReport();
                    if (object.session != null)
                        message.session = String(object.session);
                    if (object.lastAccessTime != null)
                        if ($util.Long)
                            (message.lastAccessTime = $util.Long.fromValue(object.lastAccessTime)).unsigned = true;
                        else if (typeof object.lastAccessTime === "string")
                            message.lastAccessTime = parseInt(object.lastAccessTime, 10);
                        else if (typeof object.lastAccessTime === "number")
                            message.lastAccessTime = object.lastAccessTime;
                        else if (typeof object.lastAccessTime === "object")
                            message.lastAccessTime = new $util.LongBits(object.lastAccessTime.low >>> 0, object.lastAccessTime.high >>> 0).toNumber(true);
                    if (object.objId != null)
                        message.objId = object.objId >>> 0;
                    if (object.objType != null)
                        message.objType = String(object.objType);
                    return message;
                };
    
                /**
                 * Creates a plain object from a HealthReport message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.HealthReport
                 * @static
                 * @param {CS.PROTO.HealthReport} message HealthReport
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthReport.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.session = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.lastAccessTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lastAccessTime = options.longs === String ? "0" : 0;
                        object.objId = 0;
                        object.objType = "";
                    }
                    if (message.session != null && message.hasOwnProperty("session"))
                        object.session = message.session;
                    if (message.lastAccessTime != null && message.hasOwnProperty("lastAccessTime"))
                        if (typeof message.lastAccessTime === "number")
                            object.lastAccessTime = options.longs === String ? String(message.lastAccessTime) : message.lastAccessTime;
                        else
                            object.lastAccessTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastAccessTime) : options.longs === Number ? new $util.LongBits(message.lastAccessTime.low >>> 0, message.lastAccessTime.high >>> 0).toNumber(true) : message.lastAccessTime;
                    if (message.objId != null && message.hasOwnProperty("objId"))
                        object.objId = message.objId;
                    if (message.objType != null && message.hasOwnProperty("objType"))
                        object.objType = message.objType;
                    return object;
                };
    
                /**
                 * Converts this HealthReport to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.HealthReport
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthReport.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return HealthReport;
            })();
    
            PROTO.HealthReport_in = (function() {
    
                /**
                 * Properties of a HealthReport_in.
                 * @memberof CS.PROTO
                 * @interface IHealthReport_in
                 * @property {CS.PROTO.IAPIService|null} [control] HealthReport_in control
                 * @property {Array.<string>|null} [sessions] HealthReport_in sessions
                 */
    
                /**
                 * Constructs a new HealthReport_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a HealthReport_in.
                 * @implements IHealthReport_in
                 * @constructor
                 * @param {CS.PROTO.IHealthReport_in=} [properties] Properties to set
                 */
                function HealthReport_in(properties) {
                    this.sessions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * HealthReport_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.HealthReport_in
                 * @instance
                 */
                HealthReport_in.prototype.control = null;
    
                /**
                 * HealthReport_in sessions.
                 * @member {Array.<string>} sessions
                 * @memberof CS.PROTO.HealthReport_in
                 * @instance
                 */
                HealthReport_in.prototype.sessions = $util.emptyArray;
    
                /**
                 * Creates a new HealthReport_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {CS.PROTO.IHealthReport_in=} [properties] Properties to set
                 * @returns {CS.PROTO.HealthReport_in} HealthReport_in instance
                 */
                HealthReport_in.create = function create(properties) {
                    return new HealthReport_in(properties);
                };
    
                /**
                 * Encodes the specified HealthReport_in message. Does not implicitly {@link CS.PROTO.HealthReport_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {CS.PROTO.IHealthReport_in} message HealthReport_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthReport_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.sessions != null && message.sessions.length)
                        for (var i = 0; i < message.sessions.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessions[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified HealthReport_in message, length delimited. Does not implicitly {@link CS.PROTO.HealthReport_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {CS.PROTO.IHealthReport_in} message HealthReport_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthReport_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a HealthReport_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.HealthReport_in} HealthReport_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthReport_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.HealthReport_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.sessions && message.sessions.length))
                                message.sessions = [];
                            message.sessions.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a HealthReport_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.HealthReport_in} HealthReport_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthReport_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a HealthReport_in message.
                 * @function verify
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HealthReport_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.sessions != null && message.hasOwnProperty("sessions")) {
                        if (!Array.isArray(message.sessions))
                            return "sessions: array expected";
                        for (var i = 0; i < message.sessions.length; ++i)
                            if (!$util.isString(message.sessions[i]))
                                return "sessions: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a HealthReport_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.HealthReport_in} HealthReport_in
                 */
                HealthReport_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.HealthReport_in)
                        return object;
                    var message = new $root.CS.PROTO.HealthReport_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.HealthReport_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.sessions) {
                        if (!Array.isArray(object.sessions))
                            throw TypeError(".CS.PROTO.HealthReport_in.sessions: array expected");
                        message.sessions = [];
                        for (var i = 0; i < object.sessions.length; ++i)
                            message.sessions[i] = String(object.sessions[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a HealthReport_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.HealthReport_in
                 * @static
                 * @param {CS.PROTO.HealthReport_in} message HealthReport_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthReport_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.sessions = [];
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.sessions && message.sessions.length) {
                        object.sessions = [];
                        for (var j = 0; j < message.sessions.length; ++j)
                            object.sessions[j] = message.sessions[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this HealthReport_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.HealthReport_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthReport_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return HealthReport_in;
            })();
    
            PROTO.HealthReport_out = (function() {
    
                /**
                 * Properties of a HealthReport_out.
                 * @memberof CS.PROTO
                 * @interface IHealthReport_out
                 * @property {CS.Status|null} [status] HealthReport_out status
                 * @property {Array.<CS.PROTO.IHealthReport>|null} [report] HealthReport_out report
                 * @property {Array.<CS.IError>|null} [errors] HealthReport_out errors
                 */
    
                /**
                 * Constructs a new HealthReport_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a HealthReport_out.
                 * @implements IHealthReport_out
                 * @constructor
                 * @param {CS.PROTO.IHealthReport_out=} [properties] Properties to set
                 */
                function HealthReport_out(properties) {
                    this.report = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * HealthReport_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.HealthReport_out
                 * @instance
                 */
                HealthReport_out.prototype.status = 0;
    
                /**
                 * HealthReport_out report.
                 * @member {Array.<CS.PROTO.IHealthReport>} report
                 * @memberof CS.PROTO.HealthReport_out
                 * @instance
                 */
                HealthReport_out.prototype.report = $util.emptyArray;
    
                /**
                 * HealthReport_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.HealthReport_out
                 * @instance
                 */
                HealthReport_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new HealthReport_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {CS.PROTO.IHealthReport_out=} [properties] Properties to set
                 * @returns {CS.PROTO.HealthReport_out} HealthReport_out instance
                 */
                HealthReport_out.create = function create(properties) {
                    return new HealthReport_out(properties);
                };
    
                /**
                 * Encodes the specified HealthReport_out message. Does not implicitly {@link CS.PROTO.HealthReport_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {CS.PROTO.IHealthReport_out} message HealthReport_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthReport_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.report != null && message.report.length)
                        for (var i = 0; i < message.report.length; ++i)
                            $root.CS.PROTO.HealthReport.encode(message.report[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified HealthReport_out message, length delimited. Does not implicitly {@link CS.PROTO.HealthReport_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {CS.PROTO.IHealthReport_out} message HealthReport_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthReport_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a HealthReport_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.HealthReport_out} HealthReport_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthReport_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.HealthReport_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.report && message.report.length))
                                message.report = [];
                            message.report.push($root.CS.PROTO.HealthReport.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a HealthReport_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.HealthReport_out} HealthReport_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthReport_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a HealthReport_out message.
                 * @function verify
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HealthReport_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.report != null && message.hasOwnProperty("report")) {
                        if (!Array.isArray(message.report))
                            return "report: array expected";
                        for (var i = 0; i < message.report.length; ++i) {
                            var error = $root.CS.PROTO.HealthReport.verify(message.report[i]);
                            if (error)
                                return "report." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a HealthReport_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.HealthReport_out} HealthReport_out
                 */
                HealthReport_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.HealthReport_out)
                        return object;
                    var message = new $root.CS.PROTO.HealthReport_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.report) {
                        if (!Array.isArray(object.report))
                            throw TypeError(".CS.PROTO.HealthReport_out.report: array expected");
                        message.report = [];
                        for (var i = 0; i < object.report.length; ++i) {
                            if (typeof object.report[i] !== "object")
                                throw TypeError(".CS.PROTO.HealthReport_out.report: object expected");
                            message.report[i] = $root.CS.PROTO.HealthReport.fromObject(object.report[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.HealthReport_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.HealthReport_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a HealthReport_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.HealthReport_out
                 * @static
                 * @param {CS.PROTO.HealthReport_out} message HealthReport_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthReport_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.report = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.report && message.report.length) {
                        object.report = [];
                        for (var j = 0; j < message.report.length; ++j)
                            object.report[j] = $root.CS.PROTO.HealthReport.toObject(message.report[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this HealthReport_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.HealthReport_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthReport_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return HealthReport_out;
            })();
    
            PROTO.CloseManagedSession_in = (function() {
    
                /**
                 * Properties of a CloseManagedSession_in.
                 * @memberof CS.PROTO
                 * @interface ICloseManagedSession_in
                 * @property {CS.PROTO.IAPIService|null} [control] CloseManagedSession_in control
                 * @property {Array.<string>|null} [sessions] CloseManagedSession_in sessions
                 */
    
                /**
                 * Constructs a new CloseManagedSession_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CloseManagedSession_in.
                 * @implements ICloseManagedSession_in
                 * @constructor
                 * @param {CS.PROTO.ICloseManagedSession_in=} [properties] Properties to set
                 */
                function CloseManagedSession_in(properties) {
                    this.sessions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CloseManagedSession_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @instance
                 */
                CloseManagedSession_in.prototype.control = null;
    
                /**
                 * CloseManagedSession_in sessions.
                 * @member {Array.<string>} sessions
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @instance
                 */
                CloseManagedSession_in.prototype.sessions = $util.emptyArray;
    
                /**
                 * Creates a new CloseManagedSession_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {CS.PROTO.ICloseManagedSession_in=} [properties] Properties to set
                 * @returns {CS.PROTO.CloseManagedSession_in} CloseManagedSession_in instance
                 */
                CloseManagedSession_in.create = function create(properties) {
                    return new CloseManagedSession_in(properties);
                };
    
                /**
                 * Encodes the specified CloseManagedSession_in message. Does not implicitly {@link CS.PROTO.CloseManagedSession_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {CS.PROTO.ICloseManagedSession_in} message CloseManagedSession_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseManagedSession_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.sessions != null && message.sessions.length)
                        for (var i = 0; i < message.sessions.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessions[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified CloseManagedSession_in message, length delimited. Does not implicitly {@link CS.PROTO.CloseManagedSession_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {CS.PROTO.ICloseManagedSession_in} message CloseManagedSession_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseManagedSession_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CloseManagedSession_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CloseManagedSession_in} CloseManagedSession_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseManagedSession_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CloseManagedSession_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.sessions && message.sessions.length))
                                message.sessions = [];
                            message.sessions.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CloseManagedSession_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CloseManagedSession_in} CloseManagedSession_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseManagedSession_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CloseManagedSession_in message.
                 * @function verify
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CloseManagedSession_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.sessions != null && message.hasOwnProperty("sessions")) {
                        if (!Array.isArray(message.sessions))
                            return "sessions: array expected";
                        for (var i = 0; i < message.sessions.length; ++i)
                            if (!$util.isString(message.sessions[i]))
                                return "sessions: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a CloseManagedSession_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CloseManagedSession_in} CloseManagedSession_in
                 */
                CloseManagedSession_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CloseManagedSession_in)
                        return object;
                    var message = new $root.CS.PROTO.CloseManagedSession_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.CloseManagedSession_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.sessions) {
                        if (!Array.isArray(object.sessions))
                            throw TypeError(".CS.PROTO.CloseManagedSession_in.sessions: array expected");
                        message.sessions = [];
                        for (var i = 0; i < object.sessions.length; ++i)
                            message.sessions[i] = String(object.sessions[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CloseManagedSession_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @static
                 * @param {CS.PROTO.CloseManagedSession_in} message CloseManagedSession_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CloseManagedSession_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.sessions = [];
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.sessions && message.sessions.length) {
                        object.sessions = [];
                        for (var j = 0; j < message.sessions.length; ++j)
                            object.sessions[j] = message.sessions[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this CloseManagedSession_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CloseManagedSession_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CloseManagedSession_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CloseManagedSession_in;
            })();
    
            PROTO.CloseManagedSession_out = (function() {
    
                /**
                 * Properties of a CloseManagedSession_out.
                 * @memberof CS.PROTO
                 * @interface ICloseManagedSession_out
                 * @property {CS.Status|null} [status] CloseManagedSession_out status
                 * @property {Array.<CS.IError>|null} [errors] CloseManagedSession_out errors
                 */
    
                /**
                 * Constructs a new CloseManagedSession_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a CloseManagedSession_out.
                 * @implements ICloseManagedSession_out
                 * @constructor
                 * @param {CS.PROTO.ICloseManagedSession_out=} [properties] Properties to set
                 */
                function CloseManagedSession_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CloseManagedSession_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @instance
                 */
                CloseManagedSession_out.prototype.status = 0;
    
                /**
                 * CloseManagedSession_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @instance
                 */
                CloseManagedSession_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new CloseManagedSession_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {CS.PROTO.ICloseManagedSession_out=} [properties] Properties to set
                 * @returns {CS.PROTO.CloseManagedSession_out} CloseManagedSession_out instance
                 */
                CloseManagedSession_out.create = function create(properties) {
                    return new CloseManagedSession_out(properties);
                };
    
                /**
                 * Encodes the specified CloseManagedSession_out message. Does not implicitly {@link CS.PROTO.CloseManagedSession_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {CS.PROTO.ICloseManagedSession_out} message CloseManagedSession_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseManagedSession_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CloseManagedSession_out message, length delimited. Does not implicitly {@link CS.PROTO.CloseManagedSession_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {CS.PROTO.ICloseManagedSession_out} message CloseManagedSession_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CloseManagedSession_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CloseManagedSession_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.CloseManagedSession_out} CloseManagedSession_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseManagedSession_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.CloseManagedSession_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CloseManagedSession_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.CloseManagedSession_out} CloseManagedSession_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CloseManagedSession_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CloseManagedSession_out message.
                 * @function verify
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CloseManagedSession_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CloseManagedSession_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.CloseManagedSession_out} CloseManagedSession_out
                 */
                CloseManagedSession_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.CloseManagedSession_out)
                        return object;
                    var message = new $root.CS.PROTO.CloseManagedSession_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.CloseManagedSession_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.CloseManagedSession_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CloseManagedSession_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @static
                 * @param {CS.PROTO.CloseManagedSession_out} message CloseManagedSession_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CloseManagedSession_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CloseManagedSession_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.CloseManagedSession_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CloseManagedSession_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CloseManagedSession_out;
            })();
    
            PROTO.Shutdown_in = (function() {
    
                /**
                 * Properties of a Shutdown_in.
                 * @memberof CS.PROTO
                 * @interface IShutdown_in
                 * @property {CS.PROTO.IAPIService|null} [control] Shutdown_in control
                 */
    
                /**
                 * Constructs a new Shutdown_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Shutdown_in.
                 * @implements IShutdown_in
                 * @constructor
                 * @param {CS.PROTO.IShutdown_in=} [properties] Properties to set
                 */
                function Shutdown_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Shutdown_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Shutdown_in
                 * @instance
                 */
                Shutdown_in.prototype.control = null;
    
                /**
                 * Creates a new Shutdown_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {CS.PROTO.IShutdown_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Shutdown_in} Shutdown_in instance
                 */
                Shutdown_in.create = function create(properties) {
                    return new Shutdown_in(properties);
                };
    
                /**
                 * Encodes the specified Shutdown_in message. Does not implicitly {@link CS.PROTO.Shutdown_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {CS.PROTO.IShutdown_in} message Shutdown_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shutdown_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Shutdown_in message, length delimited. Does not implicitly {@link CS.PROTO.Shutdown_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {CS.PROTO.IShutdown_in} message Shutdown_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shutdown_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Shutdown_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Shutdown_in} Shutdown_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shutdown_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Shutdown_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Shutdown_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Shutdown_in} Shutdown_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shutdown_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Shutdown_in message.
                 * @function verify
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Shutdown_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Shutdown_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Shutdown_in} Shutdown_in
                 */
                Shutdown_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Shutdown_in)
                        return object;
                    var message = new $root.CS.PROTO.Shutdown_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Shutdown_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Shutdown_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Shutdown_in
                 * @static
                 * @param {CS.PROTO.Shutdown_in} message Shutdown_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Shutdown_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this Shutdown_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Shutdown_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Shutdown_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Shutdown_in;
            })();
    
            PROTO.Shutdown_out = (function() {
    
                /**
                 * Properties of a Shutdown_out.
                 * @memberof CS.PROTO
                 * @interface IShutdown_out
                 * @property {CS.Status|null} [status] Shutdown_out status
                 * @property {Array.<CS.IError>|null} [errors] Shutdown_out errors
                 */
    
                /**
                 * Constructs a new Shutdown_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Shutdown_out.
                 * @implements IShutdown_out
                 * @constructor
                 * @param {CS.PROTO.IShutdown_out=} [properties] Properties to set
                 */
                function Shutdown_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Shutdown_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Shutdown_out
                 * @instance
                 */
                Shutdown_out.prototype.status = 0;
    
                /**
                 * Shutdown_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Shutdown_out
                 * @instance
                 */
                Shutdown_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Shutdown_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {CS.PROTO.IShutdown_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Shutdown_out} Shutdown_out instance
                 */
                Shutdown_out.create = function create(properties) {
                    return new Shutdown_out(properties);
                };
    
                /**
                 * Encodes the specified Shutdown_out message. Does not implicitly {@link CS.PROTO.Shutdown_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {CS.PROTO.IShutdown_out} message Shutdown_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shutdown_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Shutdown_out message, length delimited. Does not implicitly {@link CS.PROTO.Shutdown_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {CS.PROTO.IShutdown_out} message Shutdown_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shutdown_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Shutdown_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Shutdown_out} Shutdown_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shutdown_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Shutdown_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Shutdown_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Shutdown_out} Shutdown_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shutdown_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Shutdown_out message.
                 * @function verify
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Shutdown_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Shutdown_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Shutdown_out} Shutdown_out
                 */
                Shutdown_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Shutdown_out)
                        return object;
                    var message = new $root.CS.PROTO.Shutdown_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Shutdown_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Shutdown_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Shutdown_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Shutdown_out
                 * @static
                 * @param {CS.PROTO.Shutdown_out} message Shutdown_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Shutdown_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Shutdown_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Shutdown_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Shutdown_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Shutdown_out;
            })();
    
            PROTO.ManagementService = (function() {
    
                /**
                 * Constructs a new ManagementService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ManagementService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ManagementService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (ManagementService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ManagementService;
    
                /**
                 * Creates new ManagementService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.ManagementService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {ManagementService} RPC service. Useful where requests and/or responses are streamed.
                 */
                ManagementService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.ManagementService#healthReport}.
                 * @memberof CS.PROTO.ManagementService
                 * @typedef HealthReportCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.HealthReport_out} [response] HealthReport_out
                 */
    
                /**
                 * Calls HealthReport.
                 * @function healthReport
                 * @memberof CS.PROTO.ManagementService
                 * @instance
                 * @param {CS.PROTO.IHealthReport_in} request HealthReport_in message or plain object
                 * @param {CS.PROTO.ManagementService.HealthReportCallback} callback Node-style callback called with the error, if any, and HealthReport_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ManagementService.prototype.healthReport = function healthReport(request, callback) {
                    return this.rpcCall(healthReport, $root.CS.PROTO.HealthReport_in, $root.CS.PROTO.HealthReport_out, request, callback);
                }, "name", { value: "HealthReport" });
    
                /**
                 * Calls HealthReport.
                 * @function healthReport
                 * @memberof CS.PROTO.ManagementService
                 * @instance
                 * @param {CS.PROTO.IHealthReport_in} request HealthReport_in message or plain object
                 * @returns {Promise<CS.PROTO.HealthReport_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ManagementService#closeManagedSession}.
                 * @memberof CS.PROTO.ManagementService
                 * @typedef CloseManagedSessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.CloseManagedSession_out} [response] CloseManagedSession_out
                 */
    
                /**
                 * Calls CloseManagedSession.
                 * @function closeManagedSession
                 * @memberof CS.PROTO.ManagementService
                 * @instance
                 * @param {CS.PROTO.ICloseManagedSession_in} request CloseManagedSession_in message or plain object
                 * @param {CS.PROTO.ManagementService.CloseManagedSessionCallback} callback Node-style callback called with the error, if any, and CloseManagedSession_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ManagementService.prototype.closeManagedSession = function closeManagedSession(request, callback) {
                    return this.rpcCall(closeManagedSession, $root.CS.PROTO.CloseManagedSession_in, $root.CS.PROTO.CloseManagedSession_out, request, callback);
                }, "name", { value: "CloseManagedSession" });
    
                /**
                 * Calls CloseManagedSession.
                 * @function closeManagedSession
                 * @memberof CS.PROTO.ManagementService
                 * @instance
                 * @param {CS.PROTO.ICloseManagedSession_in} request CloseManagedSession_in message or plain object
                 * @returns {Promise<CS.PROTO.CloseManagedSession_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.ManagementService#shutdown}.
                 * @memberof CS.PROTO.ManagementService
                 * @typedef ShutdownCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Shutdown_out} [response] Shutdown_out
                 */
    
                /**
                 * Calls Shutdown.
                 * @function shutdown
                 * @memberof CS.PROTO.ManagementService
                 * @instance
                 * @param {CS.PROTO.IShutdown_in} request Shutdown_in message or plain object
                 * @param {CS.PROTO.ManagementService.ShutdownCallback} callback Node-style callback called with the error, if any, and Shutdown_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ManagementService.prototype.shutdown = function shutdown(request, callback) {
                    return this.rpcCall(shutdown, $root.CS.PROTO.Shutdown_in, $root.CS.PROTO.Shutdown_out, request, callback);
                }, "name", { value: "Shutdown" });
    
                /**
                 * Calls Shutdown.
                 * @function shutdown
                 * @memberof CS.PROTO.ManagementService
                 * @instance
                 * @param {CS.PROTO.IShutdown_in} request Shutdown_in message or plain object
                 * @returns {Promise<CS.PROTO.Shutdown_out>} Promise
                 * @variation 2
                 */
    
                return ManagementService;
            })();
    
            /**
             * InternalOwnerQualifier_call enum.
             * @name CS.PROTO.InternalOwnerQualifier_call
             * @enum {number}
             * @property {number} Unknown_InternalOwnerQualifier_call=0 Unknown_InternalOwnerQualifier_call value
             * @property {number} InternalOwnerQualifier_call_CO=1 InternalOwnerQualifier_call_CO value
             * @property {number} InternalOwnerQualifier_call_CQ=2 InternalOwnerQualifier_call_CQ value
             * @property {number} InternalOwnerQualifier_call_O=3 InternalOwnerQualifier_call_O value
             * @property {number} InternalOwnerQualifier_call_OQ=4 InternalOwnerQualifier_call_OQ value
             * @property {number} InternalOwnerQualifier_call_Q=5 InternalOwnerQualifier_call_Q value
             */
            PROTO.InternalOwnerQualifier_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_InternalOwnerQualifier_call"] = 0;
                values[valuesById[1] = "InternalOwnerQualifier_call_CO"] = 1;
                values[valuesById[2] = "InternalOwnerQualifier_call_CQ"] = 2;
                values[valuesById[3] = "InternalOwnerQualifier_call_O"] = 3;
                values[valuesById[4] = "InternalOwnerQualifier_call_OQ"] = 4;
                values[valuesById[5] = "InternalOwnerQualifier_call_Q"] = 5;
                return values;
            })();
    
            PROTO.InternalOwnerQualifier_in = (function() {
    
                /**
                 * Properties of an InternalOwnerQualifier_in.
                 * @memberof CS.PROTO
                 * @interface IInternalOwnerQualifier_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalOwnerQualifier_in control
                 * @property {CS.PROTO.InternalOwnerQualifier_call|null} [method] InternalOwnerQualifier_in method
                 * @property {string|null} [qualifier] InternalOwnerQualifier_in qualifier
                 */
    
                /**
                 * Constructs a new InternalOwnerQualifier_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalOwnerQualifier_in.
                 * @implements IInternalOwnerQualifier_in
                 * @constructor
                 * @param {CS.PROTO.IInternalOwnerQualifier_in=} [properties] Properties to set
                 */
                function InternalOwnerQualifier_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalOwnerQualifier_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @instance
                 */
                InternalOwnerQualifier_in.prototype.control = null;
    
                /**
                 * InternalOwnerQualifier_in method.
                 * @member {CS.PROTO.InternalOwnerQualifier_call} method
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @instance
                 */
                InternalOwnerQualifier_in.prototype.method = 0;
    
                /**
                 * InternalOwnerQualifier_in qualifier.
                 * @member {string} qualifier
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @instance
                 */
                InternalOwnerQualifier_in.prototype.qualifier = "";
    
                /**
                 * Creates a new InternalOwnerQualifier_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {CS.PROTO.IInternalOwnerQualifier_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalOwnerQualifier_in} InternalOwnerQualifier_in instance
                 */
                InternalOwnerQualifier_in.create = function create(properties) {
                    return new InternalOwnerQualifier_in(properties);
                };
    
                /**
                 * Encodes the specified InternalOwnerQualifier_in message. Does not implicitly {@link CS.PROTO.InternalOwnerQualifier_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {CS.PROTO.IInternalOwnerQualifier_in} message InternalOwnerQualifier_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalOwnerQualifier_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.qualifier != null && Object.hasOwnProperty.call(message, "qualifier"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.qualifier);
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalOwnerQualifier_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalOwnerQualifier_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {CS.PROTO.IInternalOwnerQualifier_in} message InternalOwnerQualifier_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalOwnerQualifier_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalOwnerQualifier_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalOwnerQualifier_in} InternalOwnerQualifier_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalOwnerQualifier_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalOwnerQualifier_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.qualifier = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalOwnerQualifier_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalOwnerQualifier_in} InternalOwnerQualifier_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalOwnerQualifier_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalOwnerQualifier_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalOwnerQualifier_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        if (!$util.isString(message.qualifier))
                            return "qualifier: string expected";
                    return null;
                };
    
                /**
                 * Creates an InternalOwnerQualifier_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalOwnerQualifier_in} InternalOwnerQualifier_in
                 */
                InternalOwnerQualifier_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalOwnerQualifier_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalOwnerQualifier_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalOwnerQualifier_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_InternalOwnerQualifier_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "InternalOwnerQualifier_call_CO":
                    case 1:
                        message.method = 1;
                        break;
                    case "InternalOwnerQualifier_call_CQ":
                    case 2:
                        message.method = 2;
                        break;
                    case "InternalOwnerQualifier_call_O":
                    case 3:
                        message.method = 3;
                        break;
                    case "InternalOwnerQualifier_call_OQ":
                    case 4:
                        message.method = 4;
                        break;
                    case "InternalOwnerQualifier_call_Q":
                    case 5:
                        message.method = 5;
                        break;
                    }
                    if (object.qualifier != null)
                        message.qualifier = String(object.qualifier);
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalOwnerQualifier_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @static
                 * @param {CS.PROTO.InternalOwnerQualifier_in} message InternalOwnerQualifier_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalOwnerQualifier_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_InternalOwnerQualifier_call" : 0;
                        object.qualifier = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.InternalOwnerQualifier_call[message.method] : message.method;
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        object.qualifier = message.qualifier;
                    return object;
                };
    
                /**
                 * Converts this InternalOwnerQualifier_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalOwnerQualifier_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalOwnerQualifier_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalOwnerQualifier_in;
            })();
    
            PROTO.InternalOwnerQualifier_out = (function() {
    
                /**
                 * Properties of an InternalOwnerQualifier_out.
                 * @memberof CS.PROTO
                 * @interface IInternalOwnerQualifier_out
                 * @property {CS.Status|null} [status] InternalOwnerQualifier_out status
                 * @property {Array.<string>|null} [values] InternalOwnerQualifier_out values
                 * @property {Array.<CS.IError>|null} [errors] InternalOwnerQualifier_out errors
                 */
    
                /**
                 * Constructs a new InternalOwnerQualifier_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalOwnerQualifier_out.
                 * @implements IInternalOwnerQualifier_out
                 * @constructor
                 * @param {CS.PROTO.IInternalOwnerQualifier_out=} [properties] Properties to set
                 */
                function InternalOwnerQualifier_out(properties) {
                    this.values = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalOwnerQualifier_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @instance
                 */
                InternalOwnerQualifier_out.prototype.status = 0;
    
                /**
                 * InternalOwnerQualifier_out values.
                 * @member {Array.<string>} values
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @instance
                 */
                InternalOwnerQualifier_out.prototype.values = $util.emptyArray;
    
                /**
                 * InternalOwnerQualifier_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @instance
                 */
                InternalOwnerQualifier_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalOwnerQualifier_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {CS.PROTO.IInternalOwnerQualifier_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalOwnerQualifier_out} InternalOwnerQualifier_out instance
                 */
                InternalOwnerQualifier_out.create = function create(properties) {
                    return new InternalOwnerQualifier_out(properties);
                };
    
                /**
                 * Encodes the specified InternalOwnerQualifier_out message. Does not implicitly {@link CS.PROTO.InternalOwnerQualifier_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {CS.PROTO.IInternalOwnerQualifier_out} message InternalOwnerQualifier_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalOwnerQualifier_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.values != null && message.values.length)
                        for (var i = 0; i < message.values.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.values[i]);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalOwnerQualifier_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalOwnerQualifier_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {CS.PROTO.IInternalOwnerQualifier_out} message InternalOwnerQualifier_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalOwnerQualifier_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalOwnerQualifier_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalOwnerQualifier_out} InternalOwnerQualifier_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalOwnerQualifier_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalOwnerQualifier_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push(reader.string());
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalOwnerQualifier_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalOwnerQualifier_out} InternalOwnerQualifier_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalOwnerQualifier_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalOwnerQualifier_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalOwnerQualifier_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i)
                            if (!$util.isString(message.values[i]))
                                return "values: string[] expected";
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalOwnerQualifier_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalOwnerQualifier_out} InternalOwnerQualifier_out
                 */
                InternalOwnerQualifier_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalOwnerQualifier_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalOwnerQualifier_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".CS.PROTO.InternalOwnerQualifier_out.values: array expected");
                        message.values = [];
                        for (var i = 0; i < object.values.length; ++i)
                            message.values[i] = String(object.values[i]);
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalOwnerQualifier_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalOwnerQualifier_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalOwnerQualifier_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @static
                 * @param {CS.PROTO.InternalOwnerQualifier_out} message InternalOwnerQualifier_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalOwnerQualifier_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.values = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (var j = 0; j < message.values.length; ++j)
                            object.values[j] = message.values[j];
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalOwnerQualifier_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalOwnerQualifier_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalOwnerQualifier_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalOwnerQualifier_out;
            })();
    
            /**
             * InternalTables_call enum.
             * @name CS.PROTO.InternalTables_call
             * @enum {number}
             * @property {number} Unknown_InternalTables_call=0 Unknown_InternalTables_call value
             * @property {number} InternalTables_call_=1 InternalTables_call_ value
             * @property {number} InternalTables_call_O=2 InternalTables_call_O value
             * @property {number} InternalTables_call_Q=3 InternalTables_call_Q value
             * @property {number} InternalTables_call_QO=4 InternalTables_call_QO value
             * @property {number} InternalTables_call_QOSC=5 InternalTables_call_QOSC value
             * @property {number} InternalTables_call_SC=6 InternalTables_call_SC value
             */
            PROTO.InternalTables_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_InternalTables_call"] = 0;
                values[valuesById[1] = "InternalTables_call_"] = 1;
                values[valuesById[2] = "InternalTables_call_O"] = 2;
                values[valuesById[3] = "InternalTables_call_Q"] = 3;
                values[valuesById[4] = "InternalTables_call_QO"] = 4;
                values[valuesById[5] = "InternalTables_call_QOSC"] = 5;
                values[valuesById[6] = "InternalTables_call_SC"] = 6;
                return values;
            })();
    
            PROTO.InternalTables_in = (function() {
    
                /**
                 * Properties of an InternalTables_in.
                 * @memberof CS.PROTO
                 * @interface IInternalTables_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalTables_in control
                 * @property {CS.PROTO.InternalTables_call|null} [method] InternalTables_in method
                 * @property {string|null} [owner] InternalTables_in owner
                 * @property {string|null} [qualifier] InternalTables_in qualifier
                 * @property {string|null} [pattern] InternalTables_in pattern
                 * @property {Array.<string>|null} [types] InternalTables_in types
                 */
    
                /**
                 * Constructs a new InternalTables_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalTables_in.
                 * @implements IInternalTables_in
                 * @constructor
                 * @param {CS.PROTO.IInternalTables_in=} [properties] Properties to set
                 */
                function InternalTables_in(properties) {
                    this.types = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalTables_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalTables_in
                 * @instance
                 */
                InternalTables_in.prototype.control = null;
    
                /**
                 * InternalTables_in method.
                 * @member {CS.PROTO.InternalTables_call} method
                 * @memberof CS.PROTO.InternalTables_in
                 * @instance
                 */
                InternalTables_in.prototype.method = 0;
    
                /**
                 * InternalTables_in owner.
                 * @member {string} owner
                 * @memberof CS.PROTO.InternalTables_in
                 * @instance
                 */
                InternalTables_in.prototype.owner = "";
    
                /**
                 * InternalTables_in qualifier.
                 * @member {string} qualifier
                 * @memberof CS.PROTO.InternalTables_in
                 * @instance
                 */
                InternalTables_in.prototype.qualifier = "";
    
                /**
                 * InternalTables_in pattern.
                 * @member {string} pattern
                 * @memberof CS.PROTO.InternalTables_in
                 * @instance
                 */
                InternalTables_in.prototype.pattern = "";
    
                /**
                 * InternalTables_in types.
                 * @member {Array.<string>} types
                 * @memberof CS.PROTO.InternalTables_in
                 * @instance
                 */
                InternalTables_in.prototype.types = $util.emptyArray;
    
                /**
                 * Creates a new InternalTables_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {CS.PROTO.IInternalTables_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalTables_in} InternalTables_in instance
                 */
                InternalTables_in.create = function create(properties) {
                    return new InternalTables_in(properties);
                };
    
                /**
                 * Encodes the specified InternalTables_in message. Does not implicitly {@link CS.PROTO.InternalTables_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {CS.PROTO.IInternalTables_in} message InternalTables_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalTables_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.owner);
                    if (message.qualifier != null && Object.hasOwnProperty.call(message, "qualifier"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.qualifier);
                    if (message.pattern != null && Object.hasOwnProperty.call(message, "pattern"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.pattern);
                    if (message.types != null && message.types.length)
                        for (var i = 0; i < message.types.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.types[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalTables_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalTables_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {CS.PROTO.IInternalTables_in} message InternalTables_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalTables_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalTables_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalTables_in} InternalTables_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalTables_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalTables_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.owner = reader.string();
                            break;
                        case 4:
                            message.qualifier = reader.string();
                            break;
                        case 5:
                            message.pattern = reader.string();
                            break;
                        case 6:
                            if (!(message.types && message.types.length))
                                message.types = [];
                            message.types.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalTables_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalTables_in} InternalTables_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalTables_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalTables_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalTables_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        if (!$util.isString(message.qualifier))
                            return "qualifier: string expected";
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        if (!$util.isString(message.pattern))
                            return "pattern: string expected";
                    if (message.types != null && message.hasOwnProperty("types")) {
                        if (!Array.isArray(message.types))
                            return "types: array expected";
                        for (var i = 0; i < message.types.length; ++i)
                            if (!$util.isString(message.types[i]))
                                return "types: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalTables_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalTables_in} InternalTables_in
                 */
                InternalTables_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalTables_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalTables_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalTables_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_InternalTables_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "InternalTables_call_":
                    case 1:
                        message.method = 1;
                        break;
                    case "InternalTables_call_O":
                    case 2:
                        message.method = 2;
                        break;
                    case "InternalTables_call_Q":
                    case 3:
                        message.method = 3;
                        break;
                    case "InternalTables_call_QO":
                    case 4:
                        message.method = 4;
                        break;
                    case "InternalTables_call_QOSC":
                    case 5:
                        message.method = 5;
                        break;
                    case "InternalTables_call_SC":
                    case 6:
                        message.method = 6;
                        break;
                    }
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.qualifier != null)
                        message.qualifier = String(object.qualifier);
                    if (object.pattern != null)
                        message.pattern = String(object.pattern);
                    if (object.types) {
                        if (!Array.isArray(object.types))
                            throw TypeError(".CS.PROTO.InternalTables_in.types: array expected");
                        message.types = [];
                        for (var i = 0; i < object.types.length; ++i)
                            message.types[i] = String(object.types[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalTables_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalTables_in
                 * @static
                 * @param {CS.PROTO.InternalTables_in} message InternalTables_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalTables_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.types = [];
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_InternalTables_call" : 0;
                        object.owner = "";
                        object.qualifier = "";
                        object.pattern = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.InternalTables_call[message.method] : message.method;
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        object.qualifier = message.qualifier;
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        object.pattern = message.pattern;
                    if (message.types && message.types.length) {
                        object.types = [];
                        for (var j = 0; j < message.types.length; ++j)
                            object.types[j] = message.types[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalTables_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalTables_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalTables_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalTables_in;
            })();
    
            PROTO.InternalTables_out = (function() {
    
                /**
                 * Properties of an InternalTables_out.
                 * @memberof CS.PROTO
                 * @interface IInternalTables_out
                 * @property {CS.Status|null} [status] InternalTables_out status
                 * @property {Array.<CS.IDBObject>|null} [tables] InternalTables_out tables
                 * @property {Array.<CS.IError>|null} [errors] InternalTables_out errors
                 */
    
                /**
                 * Constructs a new InternalTables_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalTables_out.
                 * @implements IInternalTables_out
                 * @constructor
                 * @param {CS.PROTO.IInternalTables_out=} [properties] Properties to set
                 */
                function InternalTables_out(properties) {
                    this.tables = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalTables_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalTables_out
                 * @instance
                 */
                InternalTables_out.prototype.status = 0;
    
                /**
                 * InternalTables_out tables.
                 * @member {Array.<CS.IDBObject>} tables
                 * @memberof CS.PROTO.InternalTables_out
                 * @instance
                 */
                InternalTables_out.prototype.tables = $util.emptyArray;
    
                /**
                 * InternalTables_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalTables_out
                 * @instance
                 */
                InternalTables_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalTables_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {CS.PROTO.IInternalTables_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalTables_out} InternalTables_out instance
                 */
                InternalTables_out.create = function create(properties) {
                    return new InternalTables_out(properties);
                };
    
                /**
                 * Encodes the specified InternalTables_out message. Does not implicitly {@link CS.PROTO.InternalTables_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {CS.PROTO.IInternalTables_out} message InternalTables_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalTables_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.tables != null && message.tables.length)
                        for (var i = 0; i < message.tables.length; ++i)
                            $root.CS.DBObject.encode(message.tables[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalTables_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalTables_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {CS.PROTO.IInternalTables_out} message InternalTables_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalTables_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalTables_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalTables_out} InternalTables_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalTables_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalTables_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.tables && message.tables.length))
                                message.tables = [];
                            message.tables.push($root.CS.DBObject.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalTables_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalTables_out} InternalTables_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalTables_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalTables_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalTables_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.tables != null && message.hasOwnProperty("tables")) {
                        if (!Array.isArray(message.tables))
                            return "tables: array expected";
                        for (var i = 0; i < message.tables.length; ++i) {
                            var error = $root.CS.DBObject.verify(message.tables[i]);
                            if (error)
                                return "tables." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalTables_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalTables_out} InternalTables_out
                 */
                InternalTables_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalTables_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalTables_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.tables) {
                        if (!Array.isArray(object.tables))
                            throw TypeError(".CS.PROTO.InternalTables_out.tables: array expected");
                        message.tables = [];
                        for (var i = 0; i < object.tables.length; ++i) {
                            if (typeof object.tables[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalTables_out.tables: object expected");
                            message.tables[i] = $root.CS.DBObject.fromObject(object.tables[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalTables_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalTables_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalTables_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalTables_out
                 * @static
                 * @param {CS.PROTO.InternalTables_out} message InternalTables_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalTables_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.tables = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.tables && message.tables.length) {
                        object.tables = [];
                        for (var j = 0; j < message.tables.length; ++j)
                            object.tables[j] = $root.CS.DBObject.toObject(message.tables[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalTables_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalTables_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalTables_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalTables_out;
            })();
    
            /**
             * InternalColumns_call enum.
             * @name CS.PROTO.InternalColumns_call
             * @enum {number}
             * @property {number} Unknown_InternalColumns_call=0 Unknown_InternalColumns_call value
             * @property {number} InternalColumns_SSS=1 InternalColumns_SSS value
             * @property {number} InternalColumns_T=2 InternalColumns_T value
             */
            PROTO.InternalColumns_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_InternalColumns_call"] = 0;
                values[valuesById[1] = "InternalColumns_SSS"] = 1;
                values[valuesById[2] = "InternalColumns_T"] = 2;
                return values;
            })();
    
            PROTO.InternalColumns_in = (function() {
    
                /**
                 * Properties of an InternalColumns_in.
                 * @memberof CS.PROTO
                 * @interface IInternalColumns_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalColumns_in control
                 * @property {CS.PROTO.InternalColumns_call|null} [method] InternalColumns_in method
                 * @property {string|null} [owner] InternalColumns_in owner
                 * @property {string|null} [qualifier] InternalColumns_in qualifier
                 * @property {string|null} [tablename] InternalColumns_in tablename
                 * @property {CS.IDBObject|null} [table] InternalColumns_in table
                 */
    
                /**
                 * Constructs a new InternalColumns_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalColumns_in.
                 * @implements IInternalColumns_in
                 * @constructor
                 * @param {CS.PROTO.IInternalColumns_in=} [properties] Properties to set
                 */
                function InternalColumns_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalColumns_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalColumns_in
                 * @instance
                 */
                InternalColumns_in.prototype.control = null;
    
                /**
                 * InternalColumns_in method.
                 * @member {CS.PROTO.InternalColumns_call} method
                 * @memberof CS.PROTO.InternalColumns_in
                 * @instance
                 */
                InternalColumns_in.prototype.method = 0;
    
                /**
                 * InternalColumns_in owner.
                 * @member {string} owner
                 * @memberof CS.PROTO.InternalColumns_in
                 * @instance
                 */
                InternalColumns_in.prototype.owner = "";
    
                /**
                 * InternalColumns_in qualifier.
                 * @member {string} qualifier
                 * @memberof CS.PROTO.InternalColumns_in
                 * @instance
                 */
                InternalColumns_in.prototype.qualifier = "";
    
                /**
                 * InternalColumns_in tablename.
                 * @member {string} tablename
                 * @memberof CS.PROTO.InternalColumns_in
                 * @instance
                 */
                InternalColumns_in.prototype.tablename = "";
    
                /**
                 * InternalColumns_in table.
                 * @member {CS.IDBObject|null|undefined} table
                 * @memberof CS.PROTO.InternalColumns_in
                 * @instance
                 */
                InternalColumns_in.prototype.table = null;
    
                /**
                 * Creates a new InternalColumns_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {CS.PROTO.IInternalColumns_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalColumns_in} InternalColumns_in instance
                 */
                InternalColumns_in.create = function create(properties) {
                    return new InternalColumns_in(properties);
                };
    
                /**
                 * Encodes the specified InternalColumns_in message. Does not implicitly {@link CS.PROTO.InternalColumns_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {CS.PROTO.IInternalColumns_in} message InternalColumns_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalColumns_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.owner);
                    if (message.qualifier != null && Object.hasOwnProperty.call(message, "qualifier"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.qualifier);
                    if (message.tablename != null && Object.hasOwnProperty.call(message, "tablename"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.tablename);
                    if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                        $root.CS.DBObject.encode(message.table, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalColumns_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalColumns_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {CS.PROTO.IInternalColumns_in} message InternalColumns_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalColumns_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalColumns_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalColumns_in} InternalColumns_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalColumns_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalColumns_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.owner = reader.string();
                            break;
                        case 4:
                            message.qualifier = reader.string();
                            break;
                        case 5:
                            message.tablename = reader.string();
                            break;
                        case 6:
                            message.table = $root.CS.DBObject.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalColumns_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalColumns_in} InternalColumns_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalColumns_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalColumns_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalColumns_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        if (!$util.isString(message.qualifier))
                            return "qualifier: string expected";
                    if (message.tablename != null && message.hasOwnProperty("tablename"))
                        if (!$util.isString(message.tablename))
                            return "tablename: string expected";
                    if (message.table != null && message.hasOwnProperty("table")) {
                        var error = $root.CS.DBObject.verify(message.table);
                        if (error)
                            return "table." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalColumns_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalColumns_in} InternalColumns_in
                 */
                InternalColumns_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalColumns_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalColumns_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalColumns_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_InternalColumns_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "InternalColumns_SSS":
                    case 1:
                        message.method = 1;
                        break;
                    case "InternalColumns_T":
                    case 2:
                        message.method = 2;
                        break;
                    }
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.qualifier != null)
                        message.qualifier = String(object.qualifier);
                    if (object.tablename != null)
                        message.tablename = String(object.tablename);
                    if (object.table != null) {
                        if (typeof object.table !== "object")
                            throw TypeError(".CS.PROTO.InternalColumns_in.table: object expected");
                        message.table = $root.CS.DBObject.fromObject(object.table);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalColumns_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalColumns_in
                 * @static
                 * @param {CS.PROTO.InternalColumns_in} message InternalColumns_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalColumns_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_InternalColumns_call" : 0;
                        object.owner = "";
                        object.qualifier = "";
                        object.tablename = "";
                        object.table = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.InternalColumns_call[message.method] : message.method;
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        object.qualifier = message.qualifier;
                    if (message.tablename != null && message.hasOwnProperty("tablename"))
                        object.tablename = message.tablename;
                    if (message.table != null && message.hasOwnProperty("table"))
                        object.table = $root.CS.DBObject.toObject(message.table, options);
                    return object;
                };
    
                /**
                 * Converts this InternalColumns_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalColumns_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalColumns_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalColumns_in;
            })();
    
            PROTO.InternalColumns_out = (function() {
    
                /**
                 * Properties of an InternalColumns_out.
                 * @memberof CS.PROTO
                 * @interface IInternalColumns_out
                 * @property {CS.Status|null} [status] InternalColumns_out status
                 * @property {Array.<CS.IColumnInfo>|null} [columns] InternalColumns_out columns
                 * @property {Array.<CS.IError>|null} [errors] InternalColumns_out errors
                 */
    
                /**
                 * Constructs a new InternalColumns_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalColumns_out.
                 * @implements IInternalColumns_out
                 * @constructor
                 * @param {CS.PROTO.IInternalColumns_out=} [properties] Properties to set
                 */
                function InternalColumns_out(properties) {
                    this.columns = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalColumns_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalColumns_out
                 * @instance
                 */
                InternalColumns_out.prototype.status = 0;
    
                /**
                 * InternalColumns_out columns.
                 * @member {Array.<CS.IColumnInfo>} columns
                 * @memberof CS.PROTO.InternalColumns_out
                 * @instance
                 */
                InternalColumns_out.prototype.columns = $util.emptyArray;
    
                /**
                 * InternalColumns_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalColumns_out
                 * @instance
                 */
                InternalColumns_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalColumns_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {CS.PROTO.IInternalColumns_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalColumns_out} InternalColumns_out instance
                 */
                InternalColumns_out.create = function create(properties) {
                    return new InternalColumns_out(properties);
                };
    
                /**
                 * Encodes the specified InternalColumns_out message. Does not implicitly {@link CS.PROTO.InternalColumns_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {CS.PROTO.IInternalColumns_out} message InternalColumns_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalColumns_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.columns != null && message.columns.length)
                        for (var i = 0; i < message.columns.length; ++i)
                            $root.CS.ColumnInfo.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalColumns_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalColumns_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {CS.PROTO.IInternalColumns_out} message InternalColumns_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalColumns_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalColumns_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalColumns_out} InternalColumns_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalColumns_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalColumns_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.CS.ColumnInfo.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalColumns_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalColumns_out} InternalColumns_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalColumns_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalColumns_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalColumns_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.columns != null && message.hasOwnProperty("columns")) {
                        if (!Array.isArray(message.columns))
                            return "columns: array expected";
                        for (var i = 0; i < message.columns.length; ++i) {
                            var error = $root.CS.ColumnInfo.verify(message.columns[i]);
                            if (error)
                                return "columns." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalColumns_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalColumns_out} InternalColumns_out
                 */
                InternalColumns_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalColumns_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalColumns_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.columns) {
                        if (!Array.isArray(object.columns))
                            throw TypeError(".CS.PROTO.InternalColumns_out.columns: array expected");
                        message.columns = [];
                        for (var i = 0; i < object.columns.length; ++i) {
                            if (typeof object.columns[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalColumns_out.columns: object expected");
                            message.columns[i] = $root.CS.ColumnInfo.fromObject(object.columns[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalColumns_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalColumns_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalColumns_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalColumns_out
                 * @static
                 * @param {CS.PROTO.InternalColumns_out} message InternalColumns_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalColumns_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.columns = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.columns && message.columns.length) {
                        object.columns = [];
                        for (var j = 0; j < message.columns.length; ++j)
                            object.columns[j] = $root.CS.ColumnInfo.toObject(message.columns[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalColumns_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalColumns_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalColumns_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalColumns_out;
            })();
    
            /**
             * InternalProcedures_call enum.
             * @name CS.PROTO.InternalProcedures_call
             * @enum {number}
             * @property {number} Unknown_InternalProcedures_call=0 Unknown_InternalProcedures_call value
             * @property {number} InternalProcedures_call_=1 InternalProcedures_call_ value
             * @property {number} InternalProcedures_call_O=2 InternalProcedures_call_O value
             * @property {number} InternalProcedures_call_Q=3 InternalProcedures_call_Q value
             * @property {number} InternalProcedures_call_QO=4 InternalProcedures_call_QO value
             */
            PROTO.InternalProcedures_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_InternalProcedures_call"] = 0;
                values[valuesById[1] = "InternalProcedures_call_"] = 1;
                values[valuesById[2] = "InternalProcedures_call_O"] = 2;
                values[valuesById[3] = "InternalProcedures_call_Q"] = 3;
                values[valuesById[4] = "InternalProcedures_call_QO"] = 4;
                return values;
            })();
    
            PROTO.InternalProcedures_in = (function() {
    
                /**
                 * Properties of an InternalProcedures_in.
                 * @memberof CS.PROTO
                 * @interface IInternalProcedures_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalProcedures_in control
                 * @property {CS.PROTO.InternalProcedures_call|null} [method] InternalProcedures_in method
                 * @property {string|null} [owner] InternalProcedures_in owner
                 * @property {string|null} [qualifier] InternalProcedures_in qualifier
                 */
    
                /**
                 * Constructs a new InternalProcedures_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalProcedures_in.
                 * @implements IInternalProcedures_in
                 * @constructor
                 * @param {CS.PROTO.IInternalProcedures_in=} [properties] Properties to set
                 */
                function InternalProcedures_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalProcedures_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @instance
                 */
                InternalProcedures_in.prototype.control = null;
    
                /**
                 * InternalProcedures_in method.
                 * @member {CS.PROTO.InternalProcedures_call} method
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @instance
                 */
                InternalProcedures_in.prototype.method = 0;
    
                /**
                 * InternalProcedures_in owner.
                 * @member {string} owner
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @instance
                 */
                InternalProcedures_in.prototype.owner = "";
    
                /**
                 * InternalProcedures_in qualifier.
                 * @member {string} qualifier
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @instance
                 */
                InternalProcedures_in.prototype.qualifier = "";
    
                /**
                 * Creates a new InternalProcedures_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {CS.PROTO.IInternalProcedures_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalProcedures_in} InternalProcedures_in instance
                 */
                InternalProcedures_in.create = function create(properties) {
                    return new InternalProcedures_in(properties);
                };
    
                /**
                 * Encodes the specified InternalProcedures_in message. Does not implicitly {@link CS.PROTO.InternalProcedures_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {CS.PROTO.IInternalProcedures_in} message InternalProcedures_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalProcedures_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.owner);
                    if (message.qualifier != null && Object.hasOwnProperty.call(message, "qualifier"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.qualifier);
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalProcedures_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalProcedures_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {CS.PROTO.IInternalProcedures_in} message InternalProcedures_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalProcedures_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalProcedures_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalProcedures_in} InternalProcedures_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalProcedures_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalProcedures_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.owner = reader.string();
                            break;
                        case 4:
                            message.qualifier = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalProcedures_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalProcedures_in} InternalProcedures_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalProcedures_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalProcedures_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalProcedures_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        if (!$util.isString(message.qualifier))
                            return "qualifier: string expected";
                    return null;
                };
    
                /**
                 * Creates an InternalProcedures_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalProcedures_in} InternalProcedures_in
                 */
                InternalProcedures_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalProcedures_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalProcedures_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalProcedures_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_InternalProcedures_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "InternalProcedures_call_":
                    case 1:
                        message.method = 1;
                        break;
                    case "InternalProcedures_call_O":
                    case 2:
                        message.method = 2;
                        break;
                    case "InternalProcedures_call_Q":
                    case 3:
                        message.method = 3;
                        break;
                    case "InternalProcedures_call_QO":
                    case 4:
                        message.method = 4;
                        break;
                    }
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.qualifier != null)
                        message.qualifier = String(object.qualifier);
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalProcedures_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @static
                 * @param {CS.PROTO.InternalProcedures_in} message InternalProcedures_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalProcedures_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_InternalProcedures_call" : 0;
                        object.owner = "";
                        object.qualifier = "";
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.InternalProcedures_call[message.method] : message.method;
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.qualifier != null && message.hasOwnProperty("qualifier"))
                        object.qualifier = message.qualifier;
                    return object;
                };
    
                /**
                 * Converts this InternalProcedures_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalProcedures_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalProcedures_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalProcedures_in;
            })();
    
            PROTO.InternalProcedures_out = (function() {
    
                /**
                 * Properties of an InternalProcedures_out.
                 * @memberof CS.PROTO
                 * @interface IInternalProcedures_out
                 * @property {CS.Status|null} [status] InternalProcedures_out status
                 * @property {Array.<CS.IDBObject>|null} [procedures] InternalProcedures_out procedures
                 * @property {Array.<CS.IError>|null} [errors] InternalProcedures_out errors
                 */
    
                /**
                 * Constructs a new InternalProcedures_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalProcedures_out.
                 * @implements IInternalProcedures_out
                 * @constructor
                 * @param {CS.PROTO.IInternalProcedures_out=} [properties] Properties to set
                 */
                function InternalProcedures_out(properties) {
                    this.procedures = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalProcedures_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @instance
                 */
                InternalProcedures_out.prototype.status = 0;
    
                /**
                 * InternalProcedures_out procedures.
                 * @member {Array.<CS.IDBObject>} procedures
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @instance
                 */
                InternalProcedures_out.prototype.procedures = $util.emptyArray;
    
                /**
                 * InternalProcedures_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @instance
                 */
                InternalProcedures_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalProcedures_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {CS.PROTO.IInternalProcedures_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalProcedures_out} InternalProcedures_out instance
                 */
                InternalProcedures_out.create = function create(properties) {
                    return new InternalProcedures_out(properties);
                };
    
                /**
                 * Encodes the specified InternalProcedures_out message. Does not implicitly {@link CS.PROTO.InternalProcedures_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {CS.PROTO.IInternalProcedures_out} message InternalProcedures_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalProcedures_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.procedures != null && message.procedures.length)
                        for (var i = 0; i < message.procedures.length; ++i)
                            $root.CS.DBObject.encode(message.procedures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalProcedures_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalProcedures_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {CS.PROTO.IInternalProcedures_out} message InternalProcedures_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalProcedures_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalProcedures_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalProcedures_out} InternalProcedures_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalProcedures_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalProcedures_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.procedures && message.procedures.length))
                                message.procedures = [];
                            message.procedures.push($root.CS.DBObject.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalProcedures_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalProcedures_out} InternalProcedures_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalProcedures_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalProcedures_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalProcedures_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.procedures != null && message.hasOwnProperty("procedures")) {
                        if (!Array.isArray(message.procedures))
                            return "procedures: array expected";
                        for (var i = 0; i < message.procedures.length; ++i) {
                            var error = $root.CS.DBObject.verify(message.procedures[i]);
                            if (error)
                                return "procedures." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalProcedures_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalProcedures_out} InternalProcedures_out
                 */
                InternalProcedures_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalProcedures_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalProcedures_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.procedures) {
                        if (!Array.isArray(object.procedures))
                            throw TypeError(".CS.PROTO.InternalProcedures_out.procedures: array expected");
                        message.procedures = [];
                        for (var i = 0; i < object.procedures.length; ++i) {
                            if (typeof object.procedures[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalProcedures_out.procedures: object expected");
                            message.procedures[i] = $root.CS.DBObject.fromObject(object.procedures[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalProcedures_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalProcedures_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalProcedures_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @static
                 * @param {CS.PROTO.InternalProcedures_out} message InternalProcedures_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalProcedures_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.procedures = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.procedures && message.procedures.length) {
                        object.procedures = [];
                        for (var j = 0; j < message.procedures.length; ++j)
                            object.procedures[j] = $root.CS.DBObject.toObject(message.procedures[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalProcedures_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalProcedures_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalProcedures_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalProcedures_out;
            })();
    
            PROTO.ProcedureParams_in = (function() {
    
                /**
                 * Properties of a ProcedureParams_in.
                 * @memberof CS.PROTO
                 * @interface IProcedureParams_in
                 * @property {CS.PROTO.IAPIService|null} [control] ProcedureParams_in control
                 * @property {CS.IDBObject|null} [procedure] ProcedureParams_in procedure
                 */
    
                /**
                 * Constructs a new ProcedureParams_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ProcedureParams_in.
                 * @implements IProcedureParams_in
                 * @constructor
                 * @param {CS.PROTO.IProcedureParams_in=} [properties] Properties to set
                 */
                function ProcedureParams_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProcedureParams_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @instance
                 */
                ProcedureParams_in.prototype.control = null;
    
                /**
                 * ProcedureParams_in procedure.
                 * @member {CS.IDBObject|null|undefined} procedure
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @instance
                 */
                ProcedureParams_in.prototype.procedure = null;
    
                /**
                 * Creates a new ProcedureParams_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {CS.PROTO.IProcedureParams_in=} [properties] Properties to set
                 * @returns {CS.PROTO.ProcedureParams_in} ProcedureParams_in instance
                 */
                ProcedureParams_in.create = function create(properties) {
                    return new ProcedureParams_in(properties);
                };
    
                /**
                 * Encodes the specified ProcedureParams_in message. Does not implicitly {@link CS.PROTO.ProcedureParams_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {CS.PROTO.IProcedureParams_in} message ProcedureParams_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProcedureParams_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.procedure != null && Object.hasOwnProperty.call(message, "procedure"))
                        $root.CS.DBObject.encode(message.procedure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ProcedureParams_in message, length delimited. Does not implicitly {@link CS.PROTO.ProcedureParams_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {CS.PROTO.IProcedureParams_in} message ProcedureParams_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProcedureParams_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ProcedureParams_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ProcedureParams_in} ProcedureParams_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProcedureParams_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ProcedureParams_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.procedure = $root.CS.DBObject.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ProcedureParams_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ProcedureParams_in} ProcedureParams_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProcedureParams_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ProcedureParams_in message.
                 * @function verify
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProcedureParams_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.procedure != null && message.hasOwnProperty("procedure")) {
                        var error = $root.CS.DBObject.verify(message.procedure);
                        if (error)
                            return "procedure." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ProcedureParams_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ProcedureParams_in} ProcedureParams_in
                 */
                ProcedureParams_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ProcedureParams_in)
                        return object;
                    var message = new $root.CS.PROTO.ProcedureParams_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.ProcedureParams_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.procedure != null) {
                        if (typeof object.procedure !== "object")
                            throw TypeError(".CS.PROTO.ProcedureParams_in.procedure: object expected");
                        message.procedure = $root.CS.DBObject.fromObject(object.procedure);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ProcedureParams_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @static
                 * @param {CS.PROTO.ProcedureParams_in} message ProcedureParams_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProcedureParams_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.procedure = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.procedure != null && message.hasOwnProperty("procedure"))
                        object.procedure = $root.CS.DBObject.toObject(message.procedure, options);
                    return object;
                };
    
                /**
                 * Converts this ProcedureParams_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ProcedureParams_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProcedureParams_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ProcedureParams_in;
            })();
    
            PROTO.ProcedureParams_out = (function() {
    
                /**
                 * Properties of a ProcedureParams_out.
                 * @memberof CS.PROTO
                 * @interface IProcedureParams_out
                 * @property {CS.Status|null} [status] ProcedureParams_out status
                 * @property {Array.<CS.IProcedureParamInfo>|null} [params] ProcedureParams_out params
                 * @property {Array.<CS.IError>|null} [errors] ProcedureParams_out errors
                 */
    
                /**
                 * Constructs a new ProcedureParams_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ProcedureParams_out.
                 * @implements IProcedureParams_out
                 * @constructor
                 * @param {CS.PROTO.IProcedureParams_out=} [properties] Properties to set
                 */
                function ProcedureParams_out(properties) {
                    this.params = [];
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ProcedureParams_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @instance
                 */
                ProcedureParams_out.prototype.status = 0;
    
                /**
                 * ProcedureParams_out params.
                 * @member {Array.<CS.IProcedureParamInfo>} params
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @instance
                 */
                ProcedureParams_out.prototype.params = $util.emptyArray;
    
                /**
                 * ProcedureParams_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @instance
                 */
                ProcedureParams_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new ProcedureParams_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {CS.PROTO.IProcedureParams_out=} [properties] Properties to set
                 * @returns {CS.PROTO.ProcedureParams_out} ProcedureParams_out instance
                 */
                ProcedureParams_out.create = function create(properties) {
                    return new ProcedureParams_out(properties);
                };
    
                /**
                 * Encodes the specified ProcedureParams_out message. Does not implicitly {@link CS.PROTO.ProcedureParams_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {CS.PROTO.IProcedureParams_out} message ProcedureParams_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProcedureParams_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.params != null && message.params.length)
                        for (var i = 0; i < message.params.length; ++i)
                            $root.CS.ProcedureParamInfo.encode(message.params[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ProcedureParams_out message, length delimited. Does not implicitly {@link CS.PROTO.ProcedureParams_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {CS.PROTO.IProcedureParams_out} message ProcedureParams_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProcedureParams_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ProcedureParams_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ProcedureParams_out} ProcedureParams_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProcedureParams_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ProcedureParams_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push($root.CS.ProcedureParamInfo.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ProcedureParams_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ProcedureParams_out} ProcedureParams_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProcedureParams_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ProcedureParams_out message.
                 * @function verify
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProcedureParams_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.params != null && message.hasOwnProperty("params")) {
                        if (!Array.isArray(message.params))
                            return "params: array expected";
                        for (var i = 0; i < message.params.length; ++i) {
                            var error = $root.CS.ProcedureParamInfo.verify(message.params[i]);
                            if (error)
                                return "params." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ProcedureParams_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ProcedureParams_out} ProcedureParams_out
                 */
                ProcedureParams_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ProcedureParams_out)
                        return object;
                    var message = new $root.CS.PROTO.ProcedureParams_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.params) {
                        if (!Array.isArray(object.params))
                            throw TypeError(".CS.PROTO.ProcedureParams_out.params: array expected");
                        message.params = [];
                        for (var i = 0; i < object.params.length; ++i) {
                            if (typeof object.params[i] !== "object")
                                throw TypeError(".CS.PROTO.ProcedureParams_out.params: object expected");
                            message.params[i] = $root.CS.ProcedureParamInfo.fromObject(object.params[i]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.ProcedureParams_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.ProcedureParams_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ProcedureParams_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @static
                 * @param {CS.PROTO.ProcedureParams_out} message ProcedureParams_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProcedureParams_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.params = [];
                        object.errors = [];
                    }
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.params && message.params.length) {
                        object.params = [];
                        for (var j = 0; j < message.params.length; ++j)
                            object.params[j] = $root.CS.ProcedureParamInfo.toObject(message.params[j], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ProcedureParams_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ProcedureParams_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProcedureParams_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ProcedureParams_out;
            })();
    
            PROTO.PrimaryKey_in = (function() {
    
                /**
                 * Properties of a PrimaryKey_in.
                 * @memberof CS.PROTO
                 * @interface IPrimaryKey_in
                 * @property {CS.PROTO.IAPIService|null} [control] PrimaryKey_in control
                 * @property {CS.IDBObject|null} [table] PrimaryKey_in table
                 */
    
                /**
                 * Constructs a new PrimaryKey_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a PrimaryKey_in.
                 * @implements IPrimaryKey_in
                 * @constructor
                 * @param {CS.PROTO.IPrimaryKey_in=} [properties] Properties to set
                 */
                function PrimaryKey_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PrimaryKey_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @instance
                 */
                PrimaryKey_in.prototype.control = null;
    
                /**
                 * PrimaryKey_in table.
                 * @member {CS.IDBObject|null|undefined} table
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @instance
                 */
                PrimaryKey_in.prototype.table = null;
    
                /**
                 * Creates a new PrimaryKey_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {CS.PROTO.IPrimaryKey_in=} [properties] Properties to set
                 * @returns {CS.PROTO.PrimaryKey_in} PrimaryKey_in instance
                 */
                PrimaryKey_in.create = function create(properties) {
                    return new PrimaryKey_in(properties);
                };
    
                /**
                 * Encodes the specified PrimaryKey_in message. Does not implicitly {@link CS.PROTO.PrimaryKey_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {CS.PROTO.IPrimaryKey_in} message PrimaryKey_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrimaryKey_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                        $root.CS.DBObject.encode(message.table, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PrimaryKey_in message, length delimited. Does not implicitly {@link CS.PROTO.PrimaryKey_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {CS.PROTO.IPrimaryKey_in} message PrimaryKey_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrimaryKey_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PrimaryKey_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.PrimaryKey_in} PrimaryKey_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrimaryKey_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.PrimaryKey_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.table = $root.CS.DBObject.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PrimaryKey_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.PrimaryKey_in} PrimaryKey_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrimaryKey_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PrimaryKey_in message.
                 * @function verify
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PrimaryKey_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.table != null && message.hasOwnProperty("table")) {
                        var error = $root.CS.DBObject.verify(message.table);
                        if (error)
                            return "table." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a PrimaryKey_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.PrimaryKey_in} PrimaryKey_in
                 */
                PrimaryKey_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.PrimaryKey_in)
                        return object;
                    var message = new $root.CS.PROTO.PrimaryKey_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.PrimaryKey_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.table != null) {
                        if (typeof object.table !== "object")
                            throw TypeError(".CS.PROTO.PrimaryKey_in.table: object expected");
                        message.table = $root.CS.DBObject.fromObject(object.table);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PrimaryKey_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @static
                 * @param {CS.PROTO.PrimaryKey_in} message PrimaryKey_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PrimaryKey_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.table = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.table != null && message.hasOwnProperty("table"))
                        object.table = $root.CS.DBObject.toObject(message.table, options);
                    return object;
                };
    
                /**
                 * Converts this PrimaryKey_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.PrimaryKey_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PrimaryKey_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PrimaryKey_in;
            })();
    
            PROTO.PrimaryKey_out = (function() {
    
                /**
                 * Properties of a PrimaryKey_out.
                 * @memberof CS.PROTO
                 * @interface IPrimaryKey_out
                 * @property {CS.Status|null} [status] PrimaryKey_out status
                 * @property {number|null} [id] PrimaryKey_out id
                 * @property {CS.IDescriptionSet|null} [desc] PrimaryKey_out desc
                 * @property {number|Long|null} [rowsAffected] PrimaryKey_out rowsAffected
                 * @property {Array.<CS.IError>|null} [errors] PrimaryKey_out errors
                 */
    
                /**
                 * Constructs a new PrimaryKey_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a PrimaryKey_out.
                 * @implements IPrimaryKey_out
                 * @constructor
                 * @param {CS.PROTO.IPrimaryKey_out=} [properties] Properties to set
                 */
                function PrimaryKey_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PrimaryKey_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @instance
                 */
                PrimaryKey_out.prototype.status = 0;
    
                /**
                 * PrimaryKey_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @instance
                 */
                PrimaryKey_out.prototype.id = 0;
    
                /**
                 * PrimaryKey_out desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @instance
                 */
                PrimaryKey_out.prototype.desc = null;
    
                /**
                 * PrimaryKey_out rowsAffected.
                 * @member {number|Long} rowsAffected
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @instance
                 */
                PrimaryKey_out.prototype.rowsAffected = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * PrimaryKey_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @instance
                 */
                PrimaryKey_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new PrimaryKey_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {CS.PROTO.IPrimaryKey_out=} [properties] Properties to set
                 * @returns {CS.PROTO.PrimaryKey_out} PrimaryKey_out instance
                 */
                PrimaryKey_out.create = function create(properties) {
                    return new PrimaryKey_out(properties);
                };
    
                /**
                 * Encodes the specified PrimaryKey_out message. Does not implicitly {@link CS.PROTO.PrimaryKey_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {CS.PROTO.IPrimaryKey_out} message PrimaryKey_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrimaryKey_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.rowsAffected != null && Object.hasOwnProperty.call(message, "rowsAffected"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.rowsAffected);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PrimaryKey_out message, length delimited. Does not implicitly {@link CS.PROTO.PrimaryKey_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {CS.PROTO.IPrimaryKey_out} message PrimaryKey_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrimaryKey_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PrimaryKey_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.PrimaryKey_out} PrimaryKey_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrimaryKey_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.PrimaryKey_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.rowsAffected = reader.uint64();
                            break;
                        case 5:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PrimaryKey_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.PrimaryKey_out} PrimaryKey_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrimaryKey_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PrimaryKey_out message.
                 * @function verify
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PrimaryKey_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (!$util.isInteger(message.rowsAffected) && !(message.rowsAffected && $util.isInteger(message.rowsAffected.low) && $util.isInteger(message.rowsAffected.high)))
                            return "rowsAffected: integer|Long expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a PrimaryKey_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.PrimaryKey_out} PrimaryKey_out
                 */
                PrimaryKey_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.PrimaryKey_out)
                        return object;
                    var message = new $root.CS.PROTO.PrimaryKey_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.PrimaryKey_out.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    if (object.rowsAffected != null)
                        if ($util.Long)
                            (message.rowsAffected = $util.Long.fromValue(object.rowsAffected)).unsigned = true;
                        else if (typeof object.rowsAffected === "string")
                            message.rowsAffected = parseInt(object.rowsAffected, 10);
                        else if (typeof object.rowsAffected === "number")
                            message.rowsAffected = object.rowsAffected;
                        else if (typeof object.rowsAffected === "object")
                            message.rowsAffected = new $util.LongBits(object.rowsAffected.low >>> 0, object.rowsAffected.high >>> 0).toNumber(true);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.PrimaryKey_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.PrimaryKey_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PrimaryKey_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @static
                 * @param {CS.PROTO.PrimaryKey_out} message PrimaryKey_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PrimaryKey_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                        object.desc = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rowsAffected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rowsAffected = options.longs === String ? "0" : 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (typeof message.rowsAffected === "number")
                            object.rowsAffected = options.longs === String ? String(message.rowsAffected) : message.rowsAffected;
                        else
                            object.rowsAffected = options.longs === String ? $util.Long.prototype.toString.call(message.rowsAffected) : options.longs === Number ? new $util.LongBits(message.rowsAffected.low >>> 0, message.rowsAffected.high >>> 0).toNumber(true) : message.rowsAffected;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this PrimaryKey_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.PrimaryKey_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PrimaryKey_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PrimaryKey_out;
            })();
    
            PROTO.ForeignKeys_in = (function() {
    
                /**
                 * Properties of a ForeignKeys_in.
                 * @memberof CS.PROTO
                 * @interface IForeignKeys_in
                 * @property {CS.PROTO.IAPIService|null} [control] ForeignKeys_in control
                 * @property {CS.IDBObject|null} [table] ForeignKeys_in table
                 */
    
                /**
                 * Constructs a new ForeignKeys_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ForeignKeys_in.
                 * @implements IForeignKeys_in
                 * @constructor
                 * @param {CS.PROTO.IForeignKeys_in=} [properties] Properties to set
                 */
                function ForeignKeys_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ForeignKeys_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @instance
                 */
                ForeignKeys_in.prototype.control = null;
    
                /**
                 * ForeignKeys_in table.
                 * @member {CS.IDBObject|null|undefined} table
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @instance
                 */
                ForeignKeys_in.prototype.table = null;
    
                /**
                 * Creates a new ForeignKeys_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {CS.PROTO.IForeignKeys_in=} [properties] Properties to set
                 * @returns {CS.PROTO.ForeignKeys_in} ForeignKeys_in instance
                 */
                ForeignKeys_in.create = function create(properties) {
                    return new ForeignKeys_in(properties);
                };
    
                /**
                 * Encodes the specified ForeignKeys_in message. Does not implicitly {@link CS.PROTO.ForeignKeys_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {CS.PROTO.IForeignKeys_in} message ForeignKeys_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForeignKeys_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                        $root.CS.DBObject.encode(message.table, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ForeignKeys_in message, length delimited. Does not implicitly {@link CS.PROTO.ForeignKeys_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {CS.PROTO.IForeignKeys_in} message ForeignKeys_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForeignKeys_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ForeignKeys_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ForeignKeys_in} ForeignKeys_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForeignKeys_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ForeignKeys_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.table = $root.CS.DBObject.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ForeignKeys_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ForeignKeys_in} ForeignKeys_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForeignKeys_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ForeignKeys_in message.
                 * @function verify
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ForeignKeys_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.table != null && message.hasOwnProperty("table")) {
                        var error = $root.CS.DBObject.verify(message.table);
                        if (error)
                            return "table." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ForeignKeys_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ForeignKeys_in} ForeignKeys_in
                 */
                ForeignKeys_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ForeignKeys_in)
                        return object;
                    var message = new $root.CS.PROTO.ForeignKeys_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.ForeignKeys_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.table != null) {
                        if (typeof object.table !== "object")
                            throw TypeError(".CS.PROTO.ForeignKeys_in.table: object expected");
                        message.table = $root.CS.DBObject.fromObject(object.table);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ForeignKeys_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @static
                 * @param {CS.PROTO.ForeignKeys_in} message ForeignKeys_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ForeignKeys_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.table = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.table != null && message.hasOwnProperty("table"))
                        object.table = $root.CS.DBObject.toObject(message.table, options);
                    return object;
                };
    
                /**
                 * Converts this ForeignKeys_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ForeignKeys_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ForeignKeys_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ForeignKeys_in;
            })();
    
            PROTO.ForeignKeys_out = (function() {
    
                /**
                 * Properties of a ForeignKeys_out.
                 * @memberof CS.PROTO
                 * @interface IForeignKeys_out
                 * @property {CS.Status|null} [status] ForeignKeys_out status
                 * @property {number|null} [id] ForeignKeys_out id
                 * @property {CS.IDescriptionSet|null} [desc] ForeignKeys_out desc
                 * @property {number|Long|null} [rowsAffected] ForeignKeys_out rowsAffected
                 * @property {Array.<CS.IError>|null} [errors] ForeignKeys_out errors
                 */
    
                /**
                 * Constructs a new ForeignKeys_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ForeignKeys_out.
                 * @implements IForeignKeys_out
                 * @constructor
                 * @param {CS.PROTO.IForeignKeys_out=} [properties] Properties to set
                 */
                function ForeignKeys_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ForeignKeys_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @instance
                 */
                ForeignKeys_out.prototype.status = 0;
    
                /**
                 * ForeignKeys_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @instance
                 */
                ForeignKeys_out.prototype.id = 0;
    
                /**
                 * ForeignKeys_out desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @instance
                 */
                ForeignKeys_out.prototype.desc = null;
    
                /**
                 * ForeignKeys_out rowsAffected.
                 * @member {number|Long} rowsAffected
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @instance
                 */
                ForeignKeys_out.prototype.rowsAffected = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * ForeignKeys_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @instance
                 */
                ForeignKeys_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new ForeignKeys_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {CS.PROTO.IForeignKeys_out=} [properties] Properties to set
                 * @returns {CS.PROTO.ForeignKeys_out} ForeignKeys_out instance
                 */
                ForeignKeys_out.create = function create(properties) {
                    return new ForeignKeys_out(properties);
                };
    
                /**
                 * Encodes the specified ForeignKeys_out message. Does not implicitly {@link CS.PROTO.ForeignKeys_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {CS.PROTO.IForeignKeys_out} message ForeignKeys_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForeignKeys_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.rowsAffected != null && Object.hasOwnProperty.call(message, "rowsAffected"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.rowsAffected);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ForeignKeys_out message, length delimited. Does not implicitly {@link CS.PROTO.ForeignKeys_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {CS.PROTO.IForeignKeys_out} message ForeignKeys_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForeignKeys_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ForeignKeys_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ForeignKeys_out} ForeignKeys_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForeignKeys_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ForeignKeys_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.rowsAffected = reader.uint64();
                            break;
                        case 5:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ForeignKeys_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ForeignKeys_out} ForeignKeys_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForeignKeys_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ForeignKeys_out message.
                 * @function verify
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ForeignKeys_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (!$util.isInteger(message.rowsAffected) && !(message.rowsAffected && $util.isInteger(message.rowsAffected.low) && $util.isInteger(message.rowsAffected.high)))
                            return "rowsAffected: integer|Long expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ForeignKeys_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ForeignKeys_out} ForeignKeys_out
                 */
                ForeignKeys_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ForeignKeys_out)
                        return object;
                    var message = new $root.CS.PROTO.ForeignKeys_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.ForeignKeys_out.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    if (object.rowsAffected != null)
                        if ($util.Long)
                            (message.rowsAffected = $util.Long.fromValue(object.rowsAffected)).unsigned = true;
                        else if (typeof object.rowsAffected === "string")
                            message.rowsAffected = parseInt(object.rowsAffected, 10);
                        else if (typeof object.rowsAffected === "number")
                            message.rowsAffected = object.rowsAffected;
                        else if (typeof object.rowsAffected === "object")
                            message.rowsAffected = new $util.LongBits(object.rowsAffected.low >>> 0, object.rowsAffected.high >>> 0).toNumber(true);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.ForeignKeys_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.ForeignKeys_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ForeignKeys_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @static
                 * @param {CS.PROTO.ForeignKeys_out} message ForeignKeys_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ForeignKeys_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                        object.desc = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rowsAffected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rowsAffected = options.longs === String ? "0" : 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (typeof message.rowsAffected === "number")
                            object.rowsAffected = options.longs === String ? String(message.rowsAffected) : message.rowsAffected;
                        else
                            object.rowsAffected = options.longs === String ? $util.Long.prototype.toString.call(message.rowsAffected) : options.longs === Number ? new $util.LongBits(message.rowsAffected.low >>> 0, message.rowsAffected.high >>> 0).toNumber(true) : message.rowsAffected;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ForeignKeys_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ForeignKeys_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ForeignKeys_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ForeignKeys_out;
            })();
    
            PROTO.ReferentialDependencies_in = (function() {
    
                /**
                 * Properties of a ReferentialDependencies_in.
                 * @memberof CS.PROTO
                 * @interface IReferentialDependencies_in
                 * @property {CS.PROTO.IAPIService|null} [control] ReferentialDependencies_in control
                 * @property {CS.IDBObject|null} [table] ReferentialDependencies_in table
                 */
    
                /**
                 * Constructs a new ReferentialDependencies_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ReferentialDependencies_in.
                 * @implements IReferentialDependencies_in
                 * @constructor
                 * @param {CS.PROTO.IReferentialDependencies_in=} [properties] Properties to set
                 */
                function ReferentialDependencies_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ReferentialDependencies_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @instance
                 */
                ReferentialDependencies_in.prototype.control = null;
    
                /**
                 * ReferentialDependencies_in table.
                 * @member {CS.IDBObject|null|undefined} table
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @instance
                 */
                ReferentialDependencies_in.prototype.table = null;
    
                /**
                 * Creates a new ReferentialDependencies_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {CS.PROTO.IReferentialDependencies_in=} [properties] Properties to set
                 * @returns {CS.PROTO.ReferentialDependencies_in} ReferentialDependencies_in instance
                 */
                ReferentialDependencies_in.create = function create(properties) {
                    return new ReferentialDependencies_in(properties);
                };
    
                /**
                 * Encodes the specified ReferentialDependencies_in message. Does not implicitly {@link CS.PROTO.ReferentialDependencies_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {CS.PROTO.IReferentialDependencies_in} message ReferentialDependencies_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReferentialDependencies_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                        $root.CS.DBObject.encode(message.table, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ReferentialDependencies_in message, length delimited. Does not implicitly {@link CS.PROTO.ReferentialDependencies_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {CS.PROTO.IReferentialDependencies_in} message ReferentialDependencies_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReferentialDependencies_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ReferentialDependencies_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ReferentialDependencies_in} ReferentialDependencies_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReferentialDependencies_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ReferentialDependencies_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.table = $root.CS.DBObject.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ReferentialDependencies_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ReferentialDependencies_in} ReferentialDependencies_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReferentialDependencies_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ReferentialDependencies_in message.
                 * @function verify
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReferentialDependencies_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.table != null && message.hasOwnProperty("table")) {
                        var error = $root.CS.DBObject.verify(message.table);
                        if (error)
                            return "table." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ReferentialDependencies_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ReferentialDependencies_in} ReferentialDependencies_in
                 */
                ReferentialDependencies_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ReferentialDependencies_in)
                        return object;
                    var message = new $root.CS.PROTO.ReferentialDependencies_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.ReferentialDependencies_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    if (object.table != null) {
                        if (typeof object.table !== "object")
                            throw TypeError(".CS.PROTO.ReferentialDependencies_in.table: object expected");
                        message.table = $root.CS.DBObject.fromObject(object.table);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ReferentialDependencies_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @static
                 * @param {CS.PROTO.ReferentialDependencies_in} message ReferentialDependencies_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReferentialDependencies_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.table = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.table != null && message.hasOwnProperty("table"))
                        object.table = $root.CS.DBObject.toObject(message.table, options);
                    return object;
                };
    
                /**
                 * Converts this ReferentialDependencies_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ReferentialDependencies_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReferentialDependencies_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ReferentialDependencies_in;
            })();
    
            PROTO.ReferentialDependencies_out = (function() {
    
                /**
                 * Properties of a ReferentialDependencies_out.
                 * @memberof CS.PROTO
                 * @interface IReferentialDependencies_out
                 * @property {CS.Status|null} [status] ReferentialDependencies_out status
                 * @property {number|null} [id] ReferentialDependencies_out id
                 * @property {CS.IDescriptionSet|null} [desc] ReferentialDependencies_out desc
                 * @property {number|Long|null} [rowsAffected] ReferentialDependencies_out rowsAffected
                 * @property {Array.<CS.IError>|null} [errors] ReferentialDependencies_out errors
                 */
    
                /**
                 * Constructs a new ReferentialDependencies_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a ReferentialDependencies_out.
                 * @implements IReferentialDependencies_out
                 * @constructor
                 * @param {CS.PROTO.IReferentialDependencies_out=} [properties] Properties to set
                 */
                function ReferentialDependencies_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ReferentialDependencies_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @instance
                 */
                ReferentialDependencies_out.prototype.status = 0;
    
                /**
                 * ReferentialDependencies_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @instance
                 */
                ReferentialDependencies_out.prototype.id = 0;
    
                /**
                 * ReferentialDependencies_out desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @instance
                 */
                ReferentialDependencies_out.prototype.desc = null;
    
                /**
                 * ReferentialDependencies_out rowsAffected.
                 * @member {number|Long} rowsAffected
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @instance
                 */
                ReferentialDependencies_out.prototype.rowsAffected = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * ReferentialDependencies_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @instance
                 */
                ReferentialDependencies_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new ReferentialDependencies_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {CS.PROTO.IReferentialDependencies_out=} [properties] Properties to set
                 * @returns {CS.PROTO.ReferentialDependencies_out} ReferentialDependencies_out instance
                 */
                ReferentialDependencies_out.create = function create(properties) {
                    return new ReferentialDependencies_out(properties);
                };
    
                /**
                 * Encodes the specified ReferentialDependencies_out message. Does not implicitly {@link CS.PROTO.ReferentialDependencies_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {CS.PROTO.IReferentialDependencies_out} message ReferentialDependencies_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReferentialDependencies_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.rowsAffected != null && Object.hasOwnProperty.call(message, "rowsAffected"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.rowsAffected);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ReferentialDependencies_out message, length delimited. Does not implicitly {@link CS.PROTO.ReferentialDependencies_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {CS.PROTO.IReferentialDependencies_out} message ReferentialDependencies_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReferentialDependencies_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ReferentialDependencies_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.ReferentialDependencies_out} ReferentialDependencies_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReferentialDependencies_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.ReferentialDependencies_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.rowsAffected = reader.uint64();
                            break;
                        case 5:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ReferentialDependencies_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.ReferentialDependencies_out} ReferentialDependencies_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReferentialDependencies_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ReferentialDependencies_out message.
                 * @function verify
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReferentialDependencies_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (!$util.isInteger(message.rowsAffected) && !(message.rowsAffected && $util.isInteger(message.rowsAffected.low) && $util.isInteger(message.rowsAffected.high)))
                            return "rowsAffected: integer|Long expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ReferentialDependencies_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.ReferentialDependencies_out} ReferentialDependencies_out
                 */
                ReferentialDependencies_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.ReferentialDependencies_out)
                        return object;
                    var message = new $root.CS.PROTO.ReferentialDependencies_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.ReferentialDependencies_out.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    if (object.rowsAffected != null)
                        if ($util.Long)
                            (message.rowsAffected = $util.Long.fromValue(object.rowsAffected)).unsigned = true;
                        else if (typeof object.rowsAffected === "string")
                            message.rowsAffected = parseInt(object.rowsAffected, 10);
                        else if (typeof object.rowsAffected === "number")
                            message.rowsAffected = object.rowsAffected;
                        else if (typeof object.rowsAffected === "object")
                            message.rowsAffected = new $util.LongBits(object.rowsAffected.low >>> 0, object.rowsAffected.high >>> 0).toNumber(true);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.ReferentialDependencies_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.ReferentialDependencies_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ReferentialDependencies_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @static
                 * @param {CS.PROTO.ReferentialDependencies_out} message ReferentialDependencies_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReferentialDependencies_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                        object.desc = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rowsAffected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rowsAffected = options.longs === String ? "0" : 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (typeof message.rowsAffected === "number")
                            object.rowsAffected = options.longs === String ? String(message.rowsAffected) : message.rowsAffected;
                        else
                            object.rowsAffected = options.longs === String ? $util.Long.prototype.toString.call(message.rowsAffected) : options.longs === Number ? new $util.LongBits(message.rowsAffected.low >>> 0, message.rowsAffected.high >>> 0).toNumber(true) : message.rowsAffected;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ReferentialDependencies_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.ReferentialDependencies_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReferentialDependencies_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ReferentialDependencies_out;
            })();
    
            PROTO.RDBMSDictionaryService = (function() {
    
                /**
                 * Constructs a new RDBMSDictionaryService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a RDBMSDictionaryService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function RDBMSDictionaryService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (RDBMSDictionaryService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = RDBMSDictionaryService;
    
                /**
                 * Creates new RDBMSDictionaryService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {RDBMSDictionaryService} RPC service. Useful where requests and/or responses are streamed.
                 */
                RDBMSDictionaryService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#setClientInfo}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef SetClientInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.SetClientInfo_out} [response] SetClientInfo_out
                 */
    
                /**
                 * Calls SetClientInfo.
                 * @function setClientInfo
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.ISetClientInfo_in} request SetClientInfo_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.SetClientInfoCallback} callback Node-style callback called with the error, if any, and SetClientInfo_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.setClientInfo = function setClientInfo(request, callback) {
                    return this.rpcCall(setClientInfo, $root.CS.PROTO.SetClientInfo_in, $root.CS.PROTO.SetClientInfo_out, request, callback);
                }, "name", { value: "SetClientInfo" });
    
                /**
                 * Calls SetClientInfo.
                 * @function setClientInfo
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.ISetClientInfo_in} request SetClientInfo_in message or plain object
                 * @returns {Promise<CS.PROTO.SetClientInfo_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#getClientInfo}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef GetClientInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.GetClientInfo_out} [response] GetClientInfo_out
                 */
    
                /**
                 * Calls GetClientInfo.
                 * @function getClientInfo
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IGetClientInfo_in} request GetClientInfo_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.GetClientInfoCallback} callback Node-style callback called with the error, if any, and GetClientInfo_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.getClientInfo = function getClientInfo(request, callback) {
                    return this.rpcCall(getClientInfo, $root.CS.PROTO.GetClientInfo_in, $root.CS.PROTO.GetClientInfo_out, request, callback);
                }, "name", { value: "GetClientInfo" });
    
                /**
                 * Calls GetClientInfo.
                 * @function getClientInfo
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IGetClientInfo_in} request GetClientInfo_in message or plain object
                 * @returns {Promise<CS.PROTO.GetClientInfo_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#internalOwnerQualifier}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef InternalOwnerQualifierCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalOwnerQualifier_out} [response] InternalOwnerQualifier_out
                 */
    
                /**
                 * Calls InternalOwnerQualifier.
                 * @function internalOwnerQualifier
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalOwnerQualifier_in} request InternalOwnerQualifier_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.InternalOwnerQualifierCallback} callback Node-style callback called with the error, if any, and InternalOwnerQualifier_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.internalOwnerQualifier = function internalOwnerQualifier(request, callback) {
                    return this.rpcCall(internalOwnerQualifier, $root.CS.PROTO.InternalOwnerQualifier_in, $root.CS.PROTO.InternalOwnerQualifier_out, request, callback);
                }, "name", { value: "InternalOwnerQualifier" });
    
                /**
                 * Calls InternalOwnerQualifier.
                 * @function internalOwnerQualifier
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalOwnerQualifier_in} request InternalOwnerQualifier_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalOwnerQualifier_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#internalTables}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef InternalTablesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalTables_out} [response] InternalTables_out
                 */
    
                /**
                 * Calls InternalTables.
                 * @function internalTables
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalTables_in} request InternalTables_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.InternalTablesCallback} callback Node-style callback called with the error, if any, and InternalTables_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.internalTables = function internalTables(request, callback) {
                    return this.rpcCall(internalTables, $root.CS.PROTO.InternalTables_in, $root.CS.PROTO.InternalTables_out, request, callback);
                }, "name", { value: "InternalTables" });
    
                /**
                 * Calls InternalTables.
                 * @function internalTables
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalTables_in} request InternalTables_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalTables_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#internalColumns}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef InternalColumnsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalColumns_out} [response] InternalColumns_out
                 */
    
                /**
                 * Calls InternalColumns.
                 * @function internalColumns
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalColumns_in} request InternalColumns_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.InternalColumnsCallback} callback Node-style callback called with the error, if any, and InternalColumns_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.internalColumns = function internalColumns(request, callback) {
                    return this.rpcCall(internalColumns, $root.CS.PROTO.InternalColumns_in, $root.CS.PROTO.InternalColumns_out, request, callback);
                }, "name", { value: "InternalColumns" });
    
                /**
                 * Calls InternalColumns.
                 * @function internalColumns
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalColumns_in} request InternalColumns_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalColumns_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#internalProcedures}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef InternalProceduresCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalProcedures_out} [response] InternalProcedures_out
                 */
    
                /**
                 * Calls InternalProcedures.
                 * @function internalProcedures
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalProcedures_in} request InternalProcedures_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.InternalProceduresCallback} callback Node-style callback called with the error, if any, and InternalProcedures_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.internalProcedures = function internalProcedures(request, callback) {
                    return this.rpcCall(internalProcedures, $root.CS.PROTO.InternalProcedures_in, $root.CS.PROTO.InternalProcedures_out, request, callback);
                }, "name", { value: "InternalProcedures" });
    
                /**
                 * Calls InternalProcedures.
                 * @function internalProcedures
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IInternalProcedures_in} request InternalProcedures_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalProcedures_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#procedureParams}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef ProcedureParamsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.ProcedureParams_out} [response] ProcedureParams_out
                 */
    
                /**
                 * Calls ProcedureParams.
                 * @function procedureParams
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IProcedureParams_in} request ProcedureParams_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.ProcedureParamsCallback} callback Node-style callback called with the error, if any, and ProcedureParams_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.procedureParams = function procedureParams(request, callback) {
                    return this.rpcCall(procedureParams, $root.CS.PROTO.ProcedureParams_in, $root.CS.PROTO.ProcedureParams_out, request, callback);
                }, "name", { value: "ProcedureParams" });
    
                /**
                 * Calls ProcedureParams.
                 * @function procedureParams
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IProcedureParams_in} request ProcedureParams_in message or plain object
                 * @returns {Promise<CS.PROTO.ProcedureParams_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#ping}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef PingCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Ping_out} [response] Ping_out
                 */
    
                /**
                 * Calls Ping.
                 * @function ping
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IPing_in} request Ping_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.PingCallback} callback Node-style callback called with the error, if any, and Ping_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.ping = function ping(request, callback) {
                    return this.rpcCall(ping, $root.CS.PROTO.Ping_in, $root.CS.PROTO.Ping_out, request, callback);
                }, "name", { value: "Ping" });
    
                /**
                 * Calls Ping.
                 * @function ping
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IPing_in} request Ping_in message or plain object
                 * @returns {Promise<CS.PROTO.Ping_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#pingInfo}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef PingInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.PingInfo_out} [response] PingInfo_out
                 */
    
                /**
                 * Calls PingInfo.
                 * @function pingInfo
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IPingInfo_in} request PingInfo_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.PingInfoCallback} callback Node-style callback called with the error, if any, and PingInfo_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.pingInfo = function pingInfo(request, callback) {
                    return this.rpcCall(pingInfo, $root.CS.PROTO.PingInfo_in, $root.CS.PROTO.PingInfo_out, request, callback);
                }, "name", { value: "PingInfo" });
    
                /**
                 * Calls PingInfo.
                 * @function pingInfo
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IPingInfo_in} request PingInfo_in message or plain object
                 * @returns {Promise<CS.PROTO.PingInfo_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#primaryKey}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef PrimaryKeyCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.PrimaryKey_out} [response] PrimaryKey_out
                 */
    
                /**
                 * Calls PrimaryKey.
                 * @function primaryKey
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IPrimaryKey_in} request PrimaryKey_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.PrimaryKeyCallback} callback Node-style callback called with the error, if any, and PrimaryKey_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.primaryKey = function primaryKey(request, callback) {
                    return this.rpcCall(primaryKey, $root.CS.PROTO.PrimaryKey_in, $root.CS.PROTO.PrimaryKey_out, request, callback);
                }, "name", { value: "PrimaryKey" });
    
                /**
                 * Calls PrimaryKey.
                 * @function primaryKey
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IPrimaryKey_in} request PrimaryKey_in message or plain object
                 * @returns {Promise<CS.PROTO.PrimaryKey_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#foreignKeys}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef ForeignKeysCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.ForeignKeys_out} [response] ForeignKeys_out
                 */
    
                /**
                 * Calls ForeignKeys.
                 * @function foreignKeys
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IForeignKeys_in} request ForeignKeys_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.ForeignKeysCallback} callback Node-style callback called with the error, if any, and ForeignKeys_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.foreignKeys = function foreignKeys(request, callback) {
                    return this.rpcCall(foreignKeys, $root.CS.PROTO.ForeignKeys_in, $root.CS.PROTO.ForeignKeys_out, request, callback);
                }, "name", { value: "ForeignKeys" });
    
                /**
                 * Calls ForeignKeys.
                 * @function foreignKeys
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IForeignKeys_in} request ForeignKeys_in message or plain object
                 * @returns {Promise<CS.PROTO.ForeignKeys_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#referentialDependencies}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef ReferentialDependenciesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.ReferentialDependencies_out} [response] ReferentialDependencies_out
                 */
    
                /**
                 * Calls ReferentialDependencies.
                 * @function referentialDependencies
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IReferentialDependencies_in} request ReferentialDependencies_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.ReferentialDependenciesCallback} callback Node-style callback called with the error, if any, and ReferentialDependencies_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.referentialDependencies = function referentialDependencies(request, callback) {
                    return this.rpcCall(referentialDependencies, $root.CS.PROTO.ReferentialDependencies_in, $root.CS.PROTO.ReferentialDependencies_out, request, callback);
                }, "name", { value: "ReferentialDependencies" });
    
                /**
                 * Calls ReferentialDependencies.
                 * @function referentialDependencies
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IReferentialDependencies_in} request ReferentialDependencies_in message or plain object
                 * @returns {Promise<CS.PROTO.ReferentialDependencies_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSDictionaryService#abort}.
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @typedef AbortCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Abort_out} [response] Abort_out
                 */
    
                /**
                 * Calls Abort.
                 * @function abort
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IAbort_in} request Abort_in message or plain object
                 * @param {CS.PROTO.RDBMSDictionaryService.AbortCallback} callback Node-style callback called with the error, if any, and Abort_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSDictionaryService.prototype.abort = function abort(request, callback) {
                    return this.rpcCall(abort, $root.CS.PROTO.Abort_in, $root.CS.PROTO.Abort_out, request, callback);
                }, "name", { value: "Abort" });
    
                /**
                 * Calls Abort.
                 * @function abort
                 * @memberof CS.PROTO.RDBMSDictionaryService
                 * @instance
                 * @param {CS.PROTO.IAbort_in} request Abort_in message or plain object
                 * @returns {Promise<CS.PROTO.Abort_out>} Promise
                 * @variation 2
                 */
    
                return RDBMSDictionaryService;
            })();
    
            /**
             * Describe_call enum.
             * @name CS.PROTO.Describe_call
             * @enum {number}
             * @property {number} Unknown_Describe_call=0 Unknown_Describe_call value
             * @property {number} Describe_call_S=1 Describe_call_S value
             * @property {number} Describe_call_SP=2 Describe_call_SP value
             * @property {number} Describe_call_P=3 Describe_call_P value
             * @property {number} Describe_call_PP=4 Describe_call_PP value
             */
            PROTO.Describe_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_Describe_call"] = 0;
                values[valuesById[1] = "Describe_call_S"] = 1;
                values[valuesById[2] = "Describe_call_SP"] = 2;
                values[valuesById[3] = "Describe_call_P"] = 3;
                values[valuesById[4] = "Describe_call_PP"] = 4;
                return values;
            })();
    
            PROTO.Describe_in = (function() {
    
                /**
                 * Properties of a Describe_in.
                 * @memberof CS.PROTO
                 * @interface IDescribe_in
                 * @property {CS.PROTO.IAPIService|null} [control] Describe_in control
                 * @property {CS.PROTO.Describe_call|null} [method] Describe_in method
                 * @property {string|null} [sql] Describe_in sql
                 * @property {CS.IDBObject|null} [procedure] Describe_in procedure
                 * @property {Array.<CS.IParameter>|null} [parameters] Describe_in parameters
                 */
    
                /**
                 * Constructs a new Describe_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Describe_in.
                 * @implements IDescribe_in
                 * @constructor
                 * @param {CS.PROTO.IDescribe_in=} [properties] Properties to set
                 */
                function Describe_in(properties) {
                    this.parameters = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Describe_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Describe_in
                 * @instance
                 */
                Describe_in.prototype.control = null;
    
                /**
                 * Describe_in method.
                 * @member {CS.PROTO.Describe_call} method
                 * @memberof CS.PROTO.Describe_in
                 * @instance
                 */
                Describe_in.prototype.method = 0;
    
                /**
                 * Describe_in sql.
                 * @member {string} sql
                 * @memberof CS.PROTO.Describe_in
                 * @instance
                 */
                Describe_in.prototype.sql = "";
    
                /**
                 * Describe_in procedure.
                 * @member {CS.IDBObject|null|undefined} procedure
                 * @memberof CS.PROTO.Describe_in
                 * @instance
                 */
                Describe_in.prototype.procedure = null;
    
                /**
                 * Describe_in parameters.
                 * @member {Array.<CS.IParameter>} parameters
                 * @memberof CS.PROTO.Describe_in
                 * @instance
                 */
                Describe_in.prototype.parameters = $util.emptyArray;
    
                /**
                 * Creates a new Describe_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {CS.PROTO.IDescribe_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Describe_in} Describe_in instance
                 */
                Describe_in.create = function create(properties) {
                    return new Describe_in(properties);
                };
    
                /**
                 * Encodes the specified Describe_in message. Does not implicitly {@link CS.PROTO.Describe_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {CS.PROTO.IDescribe_in} message Describe_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Describe_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.sql);
                    if (message.procedure != null && Object.hasOwnProperty.call(message, "procedure"))
                        $root.CS.DBObject.encode(message.procedure, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.parameters != null && message.parameters.length)
                        for (var i = 0; i < message.parameters.length; ++i)
                            $root.CS.Parameter.encode(message.parameters[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Describe_in message, length delimited. Does not implicitly {@link CS.PROTO.Describe_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {CS.PROTO.IDescribe_in} message Describe_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Describe_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Describe_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Describe_in} Describe_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Describe_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Describe_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.sql = reader.string();
                            break;
                        case 4:
                            message.procedure = $root.CS.DBObject.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.parameters && message.parameters.length))
                                message.parameters = [];
                            message.parameters.push($root.CS.Parameter.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Describe_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Describe_in} Describe_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Describe_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Describe_in message.
                 * @function verify
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Describe_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.sql != null && message.hasOwnProperty("sql"))
                        if (!$util.isString(message.sql))
                            return "sql: string expected";
                    if (message.procedure != null && message.hasOwnProperty("procedure")) {
                        var error = $root.CS.DBObject.verify(message.procedure);
                        if (error)
                            return "procedure." + error;
                    }
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!Array.isArray(message.parameters))
                            return "parameters: array expected";
                        for (var i = 0; i < message.parameters.length; ++i) {
                            var error = $root.CS.Parameter.verify(message.parameters[i]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Describe_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Describe_in} Describe_in
                 */
                Describe_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Describe_in)
                        return object;
                    var message = new $root.CS.PROTO.Describe_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Describe_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_Describe_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "Describe_call_S":
                    case 1:
                        message.method = 1;
                        break;
                    case "Describe_call_SP":
                    case 2:
                        message.method = 2;
                        break;
                    case "Describe_call_P":
                    case 3:
                        message.method = 3;
                        break;
                    case "Describe_call_PP":
                    case 4:
                        message.method = 4;
                        break;
                    }
                    if (object.sql != null)
                        message.sql = String(object.sql);
                    if (object.procedure != null) {
                        if (typeof object.procedure !== "object")
                            throw TypeError(".CS.PROTO.Describe_in.procedure: object expected");
                        message.procedure = $root.CS.DBObject.fromObject(object.procedure);
                    }
                    if (object.parameters) {
                        if (!Array.isArray(object.parameters))
                            throw TypeError(".CS.PROTO.Describe_in.parameters: array expected");
                        message.parameters = [];
                        for (var i = 0; i < object.parameters.length; ++i) {
                            if (typeof object.parameters[i] !== "object")
                                throw TypeError(".CS.PROTO.Describe_in.parameters: object expected");
                            message.parameters[i] = $root.CS.Parameter.fromObject(object.parameters[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Describe_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Describe_in
                 * @static
                 * @param {CS.PROTO.Describe_in} message Describe_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Describe_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.parameters = [];
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_Describe_call" : 0;
                        object.sql = "";
                        object.procedure = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.Describe_call[message.method] : message.method;
                    if (message.sql != null && message.hasOwnProperty("sql"))
                        object.sql = message.sql;
                    if (message.procedure != null && message.hasOwnProperty("procedure"))
                        object.procedure = $root.CS.DBObject.toObject(message.procedure, options);
                    if (message.parameters && message.parameters.length) {
                        object.parameters = [];
                        for (var j = 0; j < message.parameters.length; ++j)
                            object.parameters[j] = $root.CS.Parameter.toObject(message.parameters[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Describe_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Describe_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Describe_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Describe_in;
            })();
    
            PROTO.Describe_out = (function() {
    
                /**
                 * Properties of a Describe_out.
                 * @memberof CS.PROTO
                 * @interface IDescribe_out
                 * @property {CS.Status|null} [status] Describe_out status
                 * @property {CS.IDescriptionSet|null} [desc] Describe_out desc
                 * @property {Array.<CS.IError>|null} [errors] Describe_out errors
                 */
    
                /**
                 * Constructs a new Describe_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Describe_out.
                 * @implements IDescribe_out
                 * @constructor
                 * @param {CS.PROTO.IDescribe_out=} [properties] Properties to set
                 */
                function Describe_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Describe_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Describe_out
                 * @instance
                 */
                Describe_out.prototype.status = 0;
    
                /**
                 * Describe_out desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.Describe_out
                 * @instance
                 */
                Describe_out.prototype.desc = null;
    
                /**
                 * Describe_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Describe_out
                 * @instance
                 */
                Describe_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Describe_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {CS.PROTO.IDescribe_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Describe_out} Describe_out instance
                 */
                Describe_out.create = function create(properties) {
                    return new Describe_out(properties);
                };
    
                /**
                 * Encodes the specified Describe_out message. Does not implicitly {@link CS.PROTO.Describe_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {CS.PROTO.IDescribe_out} message Describe_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Describe_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Describe_out message, length delimited. Does not implicitly {@link CS.PROTO.Describe_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {CS.PROTO.IDescribe_out} message Describe_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Describe_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Describe_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Describe_out} Describe_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Describe_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Describe_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Describe_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Describe_out} Describe_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Describe_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Describe_out message.
                 * @function verify
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Describe_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Describe_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Describe_out} Describe_out
                 */
                Describe_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Describe_out)
                        return object;
                    var message = new $root.CS.PROTO.Describe_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.Describe_out.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Describe_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Describe_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Describe_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Describe_out
                 * @static
                 * @param {CS.PROTO.Describe_out} message Describe_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Describe_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.desc = null;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Describe_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Describe_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Describe_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Describe_out;
            })();
    
            /**
             * Execute_call enum.
             * @name CS.PROTO.Execute_call
             * @enum {number}
             * @property {number} Unknown_Execute_call=0 Unknown_Execute_call value
             * @property {number} Execute_call_=1 Execute_call_ value
             * @property {number} Execute_call_D=2 Execute_call_D value
             * @property {number} Execute_call_S=3 Execute_call_S value
             * @property {number} Execute_call_SD=4 Execute_call_SD value
             * @property {number} Execute_call_SP=5 Execute_call_SP value
             * @property {number} Execute_call_SPD=6 Execute_call_SPD value
             * @property {number} Execute_call_P=7 Execute_call_P value
             * @property {number} Execute_call_PD=8 Execute_call_PD value
             * @property {number} Execute_call_PP=9 Execute_call_PP value
             * @property {number} Execute_call_PPD=10 Execute_call_PPD value
             */
            PROTO.Execute_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_Execute_call"] = 0;
                values[valuesById[1] = "Execute_call_"] = 1;
                values[valuesById[2] = "Execute_call_D"] = 2;
                values[valuesById[3] = "Execute_call_S"] = 3;
                values[valuesById[4] = "Execute_call_SD"] = 4;
                values[valuesById[5] = "Execute_call_SP"] = 5;
                values[valuesById[6] = "Execute_call_SPD"] = 6;
                values[valuesById[7] = "Execute_call_P"] = 7;
                values[valuesById[8] = "Execute_call_PD"] = 8;
                values[valuesById[9] = "Execute_call_PP"] = 9;
                values[valuesById[10] = "Execute_call_PPD"] = 10;
                return values;
            })();
    
            PROTO.Execute_in = (function() {
    
                /**
                 * Properties of an Execute_in.
                 * @memberof CS.PROTO
                 * @interface IExecute_in
                 * @property {CS.PROTO.IAPIService|null} [control] Execute_in control
                 * @property {CS.PROTO.Execute_call|null} [method] Execute_in method
                 * @property {string|null} [sql] Execute_in sql
                 * @property {CS.IDBObject|null} [procedure] Execute_in procedure
                 * @property {CS.IDescriptionSet|null} [desc] Execute_in desc
                 * @property {Array.<CS.IParameter>|null} [parameters] Execute_in parameters
                 */
    
                /**
                 * Constructs a new Execute_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an Execute_in.
                 * @implements IExecute_in
                 * @constructor
                 * @param {CS.PROTO.IExecute_in=} [properties] Properties to set
                 */
                function Execute_in(properties) {
                    this.parameters = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Execute_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Execute_in
                 * @instance
                 */
                Execute_in.prototype.control = null;
    
                /**
                 * Execute_in method.
                 * @member {CS.PROTO.Execute_call} method
                 * @memberof CS.PROTO.Execute_in
                 * @instance
                 */
                Execute_in.prototype.method = 0;
    
                /**
                 * Execute_in sql.
                 * @member {string} sql
                 * @memberof CS.PROTO.Execute_in
                 * @instance
                 */
                Execute_in.prototype.sql = "";
    
                /**
                 * Execute_in procedure.
                 * @member {CS.IDBObject|null|undefined} procedure
                 * @memberof CS.PROTO.Execute_in
                 * @instance
                 */
                Execute_in.prototype.procedure = null;
    
                /**
                 * Execute_in desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.Execute_in
                 * @instance
                 */
                Execute_in.prototype.desc = null;
    
                /**
                 * Execute_in parameters.
                 * @member {Array.<CS.IParameter>} parameters
                 * @memberof CS.PROTO.Execute_in
                 * @instance
                 */
                Execute_in.prototype.parameters = $util.emptyArray;
    
                /**
                 * Creates a new Execute_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {CS.PROTO.IExecute_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Execute_in} Execute_in instance
                 */
                Execute_in.create = function create(properties) {
                    return new Execute_in(properties);
                };
    
                /**
                 * Encodes the specified Execute_in message. Does not implicitly {@link CS.PROTO.Execute_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {CS.PROTO.IExecute_in} message Execute_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Execute_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.sql);
                    if (message.procedure != null && Object.hasOwnProperty.call(message, "procedure"))
                        $root.CS.DBObject.encode(message.procedure, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.parameters != null && message.parameters.length)
                        for (var i = 0; i < message.parameters.length; ++i)
                            $root.CS.Parameter.encode(message.parameters[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Execute_in message, length delimited. Does not implicitly {@link CS.PROTO.Execute_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {CS.PROTO.IExecute_in} message Execute_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Execute_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Execute_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Execute_in} Execute_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Execute_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Execute_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.sql = reader.string();
                            break;
                        case 4:
                            message.procedure = $root.CS.DBObject.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        case 6:
                            if (!(message.parameters && message.parameters.length))
                                message.parameters = [];
                            message.parameters.push($root.CS.Parameter.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Execute_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Execute_in} Execute_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Execute_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Execute_in message.
                 * @function verify
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Execute_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.sql != null && message.hasOwnProperty("sql"))
                        if (!$util.isString(message.sql))
                            return "sql: string expected";
                    if (message.procedure != null && message.hasOwnProperty("procedure")) {
                        var error = $root.CS.DBObject.verify(message.procedure);
                        if (error)
                            return "procedure." + error;
                    }
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!Array.isArray(message.parameters))
                            return "parameters: array expected";
                        for (var i = 0; i < message.parameters.length; ++i) {
                            var error = $root.CS.Parameter.verify(message.parameters[i]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Execute_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Execute_in} Execute_in
                 */
                Execute_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Execute_in)
                        return object;
                    var message = new $root.CS.PROTO.Execute_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Execute_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_Execute_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "Execute_call_":
                    case 1:
                        message.method = 1;
                        break;
                    case "Execute_call_D":
                    case 2:
                        message.method = 2;
                        break;
                    case "Execute_call_S":
                    case 3:
                        message.method = 3;
                        break;
                    case "Execute_call_SD":
                    case 4:
                        message.method = 4;
                        break;
                    case "Execute_call_SP":
                    case 5:
                        message.method = 5;
                        break;
                    case "Execute_call_SPD":
                    case 6:
                        message.method = 6;
                        break;
                    case "Execute_call_P":
                    case 7:
                        message.method = 7;
                        break;
                    case "Execute_call_PD":
                    case 8:
                        message.method = 8;
                        break;
                    case "Execute_call_PP":
                    case 9:
                        message.method = 9;
                        break;
                    case "Execute_call_PPD":
                    case 10:
                        message.method = 10;
                        break;
                    }
                    if (object.sql != null)
                        message.sql = String(object.sql);
                    if (object.procedure != null) {
                        if (typeof object.procedure !== "object")
                            throw TypeError(".CS.PROTO.Execute_in.procedure: object expected");
                        message.procedure = $root.CS.DBObject.fromObject(object.procedure);
                    }
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.Execute_in.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    if (object.parameters) {
                        if (!Array.isArray(object.parameters))
                            throw TypeError(".CS.PROTO.Execute_in.parameters: array expected");
                        message.parameters = [];
                        for (var i = 0; i < object.parameters.length; ++i) {
                            if (typeof object.parameters[i] !== "object")
                                throw TypeError(".CS.PROTO.Execute_in.parameters: object expected");
                            message.parameters[i] = $root.CS.Parameter.fromObject(object.parameters[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Execute_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Execute_in
                 * @static
                 * @param {CS.PROTO.Execute_in} message Execute_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Execute_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.parameters = [];
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_Execute_call" : 0;
                        object.sql = "";
                        object.procedure = null;
                        object.desc = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.Execute_call[message.method] : message.method;
                    if (message.sql != null && message.hasOwnProperty("sql"))
                        object.sql = message.sql;
                    if (message.procedure != null && message.hasOwnProperty("procedure"))
                        object.procedure = $root.CS.DBObject.toObject(message.procedure, options);
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    if (message.parameters && message.parameters.length) {
                        object.parameters = [];
                        for (var j = 0; j < message.parameters.length; ++j)
                            object.parameters[j] = $root.CS.Parameter.toObject(message.parameters[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Execute_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Execute_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Execute_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Execute_in;
            })();
    
            PROTO.Execute_out = (function() {
    
                /**
                 * Properties of an Execute_out.
                 * @memberof CS.PROTO
                 * @interface IExecute_out
                 * @property {CS.Status|null} [status] Execute_out status
                 * @property {number|null} [id] Execute_out id
                 * @property {CS.IDescriptionSet|null} [desc] Execute_out desc
                 * @property {number|Long|null} [rowsAffected] Execute_out rowsAffected
                 * @property {Array.<CS.IError>|null} [errors] Execute_out errors
                 */
    
                /**
                 * Constructs a new Execute_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an Execute_out.
                 * @implements IExecute_out
                 * @constructor
                 * @param {CS.PROTO.IExecute_out=} [properties] Properties to set
                 */
                function Execute_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Execute_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Execute_out
                 * @instance
                 */
                Execute_out.prototype.status = 0;
    
                /**
                 * Execute_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.Execute_out
                 * @instance
                 */
                Execute_out.prototype.id = 0;
    
                /**
                 * Execute_out desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.Execute_out
                 * @instance
                 */
                Execute_out.prototype.desc = null;
    
                /**
                 * Execute_out rowsAffected.
                 * @member {number|Long} rowsAffected
                 * @memberof CS.PROTO.Execute_out
                 * @instance
                 */
                Execute_out.prototype.rowsAffected = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Execute_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Execute_out
                 * @instance
                 */
                Execute_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Execute_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {CS.PROTO.IExecute_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Execute_out} Execute_out instance
                 */
                Execute_out.create = function create(properties) {
                    return new Execute_out(properties);
                };
    
                /**
                 * Encodes the specified Execute_out message. Does not implicitly {@link CS.PROTO.Execute_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {CS.PROTO.IExecute_out} message Execute_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Execute_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.rowsAffected != null && Object.hasOwnProperty.call(message, "rowsAffected"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.rowsAffected);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Execute_out message, length delimited. Does not implicitly {@link CS.PROTO.Execute_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {CS.PROTO.IExecute_out} message Execute_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Execute_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Execute_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Execute_out} Execute_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Execute_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Execute_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.rowsAffected = reader.uint64();
                            break;
                        case 5:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Execute_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Execute_out} Execute_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Execute_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Execute_out message.
                 * @function verify
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Execute_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (!$util.isInteger(message.rowsAffected) && !(message.rowsAffected && $util.isInteger(message.rowsAffected.low) && $util.isInteger(message.rowsAffected.high)))
                            return "rowsAffected: integer|Long expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Execute_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Execute_out} Execute_out
                 */
                Execute_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Execute_out)
                        return object;
                    var message = new $root.CS.PROTO.Execute_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.Execute_out.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    if (object.rowsAffected != null)
                        if ($util.Long)
                            (message.rowsAffected = $util.Long.fromValue(object.rowsAffected)).unsigned = true;
                        else if (typeof object.rowsAffected === "string")
                            message.rowsAffected = parseInt(object.rowsAffected, 10);
                        else if (typeof object.rowsAffected === "number")
                            message.rowsAffected = object.rowsAffected;
                        else if (typeof object.rowsAffected === "object")
                            message.rowsAffected = new $util.LongBits(object.rowsAffected.low >>> 0, object.rowsAffected.high >>> 0).toNumber(true);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Execute_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Execute_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Execute_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Execute_out
                 * @static
                 * @param {CS.PROTO.Execute_out} message Execute_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Execute_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                        object.desc = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rowsAffected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rowsAffected = options.longs === String ? "0" : 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (typeof message.rowsAffected === "number")
                            object.rowsAffected = options.longs === String ? String(message.rowsAffected) : message.rowsAffected;
                        else
                            object.rowsAffected = options.longs === String ? $util.Long.prototype.toString.call(message.rowsAffected) : options.longs === Number ? new $util.LongBits(message.rowsAffected.low >>> 0, message.rowsAffected.high >>> 0).toNumber(true) : message.rowsAffected;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Execute_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Execute_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Execute_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Execute_out;
            })();
    
            /**
             * NextResultSet_call enum.
             * @name CS.PROTO.NextResultSet_call
             * @enum {number}
             * @property {number} Unknown_NextResultSet_call=0 Unknown_NextResultSet_call value
             * @property {number} NextResultSet_call_=1 NextResultSet_call_ value
             * @property {number} NextResultSet_call_D=2 NextResultSet_call_D value
             */
            PROTO.NextResultSet_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_NextResultSet_call"] = 0;
                values[valuesById[1] = "NextResultSet_call_"] = 1;
                values[valuesById[2] = "NextResultSet_call_D"] = 2;
                return values;
            })();
    
            PROTO.NextResultSet_in = (function() {
    
                /**
                 * Properties of a NextResultSet_in.
                 * @memberof CS.PROTO
                 * @interface INextResultSet_in
                 * @property {CS.PROTO.IAPIService|null} [control] NextResultSet_in control
                 * @property {CS.PROTO.NextResultSet_call|null} [method] NextResultSet_in method
                 * @property {CS.IDescriptionSet|null} [desc] NextResultSet_in desc
                 */
    
                /**
                 * Constructs a new NextResultSet_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a NextResultSet_in.
                 * @implements INextResultSet_in
                 * @constructor
                 * @param {CS.PROTO.INextResultSet_in=} [properties] Properties to set
                 */
                function NextResultSet_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NextResultSet_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.NextResultSet_in
                 * @instance
                 */
                NextResultSet_in.prototype.control = null;
    
                /**
                 * NextResultSet_in method.
                 * @member {CS.PROTO.NextResultSet_call} method
                 * @memberof CS.PROTO.NextResultSet_in
                 * @instance
                 */
                NextResultSet_in.prototype.method = 0;
    
                /**
                 * NextResultSet_in desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.NextResultSet_in
                 * @instance
                 */
                NextResultSet_in.prototype.desc = null;
    
                /**
                 * Creates a new NextResultSet_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {CS.PROTO.INextResultSet_in=} [properties] Properties to set
                 * @returns {CS.PROTO.NextResultSet_in} NextResultSet_in instance
                 */
                NextResultSet_in.create = function create(properties) {
                    return new NextResultSet_in(properties);
                };
    
                /**
                 * Encodes the specified NextResultSet_in message. Does not implicitly {@link CS.PROTO.NextResultSet_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {CS.PROTO.INextResultSet_in} message NextResultSet_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NextResultSet_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NextResultSet_in message, length delimited. Does not implicitly {@link CS.PROTO.NextResultSet_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {CS.PROTO.INextResultSet_in} message NextResultSet_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NextResultSet_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NextResultSet_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.NextResultSet_in} NextResultSet_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NextResultSet_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.NextResultSet_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NextResultSet_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.NextResultSet_in} NextResultSet_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NextResultSet_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NextResultSet_in message.
                 * @function verify
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NextResultSet_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a NextResultSet_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.NextResultSet_in} NextResultSet_in
                 */
                NextResultSet_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.NextResultSet_in)
                        return object;
                    var message = new $root.CS.PROTO.NextResultSet_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.NextResultSet_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_NextResultSet_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "NextResultSet_call_":
                    case 1:
                        message.method = 1;
                        break;
                    case "NextResultSet_call_D":
                    case 2:
                        message.method = 2;
                        break;
                    }
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.NextResultSet_in.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NextResultSet_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.NextResultSet_in
                 * @static
                 * @param {CS.PROTO.NextResultSet_in} message NextResultSet_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NextResultSet_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_NextResultSet_call" : 0;
                        object.desc = null;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.NextResultSet_call[message.method] : message.method;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    return object;
                };
    
                /**
                 * Converts this NextResultSet_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.NextResultSet_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NextResultSet_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NextResultSet_in;
            })();
    
            PROTO.NextResultSet_out = (function() {
    
                /**
                 * Properties of a NextResultSet_out.
                 * @memberof CS.PROTO
                 * @interface INextResultSet_out
                 * @property {CS.Status|null} [status] NextResultSet_out status
                 * @property {number|null} [id] NextResultSet_out id
                 * @property {CS.IDescriptionSet|null} [desc] NextResultSet_out desc
                 * @property {number|Long|null} [rowsAffected] NextResultSet_out rowsAffected
                 * @property {Array.<CS.IError>|null} [errors] NextResultSet_out errors
                 */
    
                /**
                 * Constructs a new NextResultSet_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a NextResultSet_out.
                 * @implements INextResultSet_out
                 * @constructor
                 * @param {CS.PROTO.INextResultSet_out=} [properties] Properties to set
                 */
                function NextResultSet_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NextResultSet_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.NextResultSet_out
                 * @instance
                 */
                NextResultSet_out.prototype.status = 0;
    
                /**
                 * NextResultSet_out id.
                 * @member {number} id
                 * @memberof CS.PROTO.NextResultSet_out
                 * @instance
                 */
                NextResultSet_out.prototype.id = 0;
    
                /**
                 * NextResultSet_out desc.
                 * @member {CS.IDescriptionSet|null|undefined} desc
                 * @memberof CS.PROTO.NextResultSet_out
                 * @instance
                 */
                NextResultSet_out.prototype.desc = null;
    
                /**
                 * NextResultSet_out rowsAffected.
                 * @member {number|Long} rowsAffected
                 * @memberof CS.PROTO.NextResultSet_out
                 * @instance
                 */
                NextResultSet_out.prototype.rowsAffected = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * NextResultSet_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.NextResultSet_out
                 * @instance
                 */
                NextResultSet_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new NextResultSet_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {CS.PROTO.INextResultSet_out=} [properties] Properties to set
                 * @returns {CS.PROTO.NextResultSet_out} NextResultSet_out instance
                 */
                NextResultSet_out.create = function create(properties) {
                    return new NextResultSet_out(properties);
                };
    
                /**
                 * Encodes the specified NextResultSet_out message. Does not implicitly {@link CS.PROTO.NextResultSet_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {CS.PROTO.INextResultSet_out} message NextResultSet_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NextResultSet_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                        $root.CS.DescriptionSet.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.rowsAffected != null && Object.hasOwnProperty.call(message, "rowsAffected"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.rowsAffected);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NextResultSet_out message, length delimited. Does not implicitly {@link CS.PROTO.NextResultSet_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {CS.PROTO.INextResultSet_out} message NextResultSet_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NextResultSet_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NextResultSet_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.NextResultSet_out} NextResultSet_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NextResultSet_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.NextResultSet_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.desc = $root.CS.DescriptionSet.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.rowsAffected = reader.uint64();
                            break;
                        case 5:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NextResultSet_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.NextResultSet_out} NextResultSet_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NextResultSet_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NextResultSet_out message.
                 * @function verify
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NextResultSet_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        var error = $root.CS.DescriptionSet.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (!$util.isInteger(message.rowsAffected) && !(message.rowsAffected && $util.isInteger(message.rowsAffected.low) && $util.isInteger(message.rowsAffected.high)))
                            return "rowsAffected: integer|Long expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NextResultSet_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.NextResultSet_out} NextResultSet_out
                 */
                NextResultSet_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.NextResultSet_out)
                        return object;
                    var message = new $root.CS.PROTO.NextResultSet_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".CS.PROTO.NextResultSet_out.desc: object expected");
                        message.desc = $root.CS.DescriptionSet.fromObject(object.desc);
                    }
                    if (object.rowsAffected != null)
                        if ($util.Long)
                            (message.rowsAffected = $util.Long.fromValue(object.rowsAffected)).unsigned = true;
                        else if (typeof object.rowsAffected === "string")
                            message.rowsAffected = parseInt(object.rowsAffected, 10);
                        else if (typeof object.rowsAffected === "number")
                            message.rowsAffected = object.rowsAffected;
                        else if (typeof object.rowsAffected === "object")
                            message.rowsAffected = new $util.LongBits(object.rowsAffected.low >>> 0, object.rowsAffected.high >>> 0).toNumber(true);
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.NextResultSet_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.NextResultSet_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NextResultSet_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.NextResultSet_out
                 * @static
                 * @param {CS.PROTO.NextResultSet_out} message NextResultSet_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NextResultSet_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                        object.id = 0;
                        object.desc = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rowsAffected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rowsAffected = options.longs === String ? "0" : 0;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.CS.DescriptionSet.toObject(message.desc, options);
                    if (message.rowsAffected != null && message.hasOwnProperty("rowsAffected"))
                        if (typeof message.rowsAffected === "number")
                            object.rowsAffected = options.longs === String ? String(message.rowsAffected) : message.rowsAffected;
                        else
                            object.rowsAffected = options.longs === String ? $util.Long.prototype.toString.call(message.rowsAffected) : options.longs === Number ? new $util.LongBits(message.rowsAffected.low >>> 0, message.rowsAffected.high >>> 0).toNumber(true) : message.rowsAffected;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NextResultSet_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.NextResultSet_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NextResultSet_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NextResultSet_out;
            })();
    
            PROTO.Commit_in = (function() {
    
                /**
                 * Properties of a Commit_in.
                 * @memberof CS.PROTO
                 * @interface ICommit_in
                 * @property {CS.PROTO.IAPIService|null} [control] Commit_in control
                 */
    
                /**
                 * Constructs a new Commit_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Commit_in.
                 * @implements ICommit_in
                 * @constructor
                 * @param {CS.PROTO.ICommit_in=} [properties] Properties to set
                 */
                function Commit_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Commit_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Commit_in
                 * @instance
                 */
                Commit_in.prototype.control = null;
    
                /**
                 * Creates a new Commit_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {CS.PROTO.ICommit_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Commit_in} Commit_in instance
                 */
                Commit_in.create = function create(properties) {
                    return new Commit_in(properties);
                };
    
                /**
                 * Encodes the specified Commit_in message. Does not implicitly {@link CS.PROTO.Commit_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {CS.PROTO.ICommit_in} message Commit_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Commit_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Commit_in message, length delimited. Does not implicitly {@link CS.PROTO.Commit_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {CS.PROTO.ICommit_in} message Commit_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Commit_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Commit_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Commit_in} Commit_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Commit_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Commit_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Commit_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Commit_in} Commit_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Commit_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Commit_in message.
                 * @function verify
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Commit_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Commit_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Commit_in} Commit_in
                 */
                Commit_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Commit_in)
                        return object;
                    var message = new $root.CS.PROTO.Commit_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Commit_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Commit_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Commit_in
                 * @static
                 * @param {CS.PROTO.Commit_in} message Commit_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Commit_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this Commit_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Commit_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Commit_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Commit_in;
            })();
    
            PROTO.Commit_out = (function() {
    
                /**
                 * Properties of a Commit_out.
                 * @memberof CS.PROTO
                 * @interface ICommit_out
                 * @property {CS.Status|null} [status] Commit_out status
                 * @property {Array.<CS.IError>|null} [errors] Commit_out errors
                 */
    
                /**
                 * Constructs a new Commit_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Commit_out.
                 * @implements ICommit_out
                 * @constructor
                 * @param {CS.PROTO.ICommit_out=} [properties] Properties to set
                 */
                function Commit_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Commit_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Commit_out
                 * @instance
                 */
                Commit_out.prototype.status = 0;
    
                /**
                 * Commit_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Commit_out
                 * @instance
                 */
                Commit_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Commit_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {CS.PROTO.ICommit_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Commit_out} Commit_out instance
                 */
                Commit_out.create = function create(properties) {
                    return new Commit_out(properties);
                };
    
                /**
                 * Encodes the specified Commit_out message. Does not implicitly {@link CS.PROTO.Commit_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {CS.PROTO.ICommit_out} message Commit_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Commit_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Commit_out message, length delimited. Does not implicitly {@link CS.PROTO.Commit_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {CS.PROTO.ICommit_out} message Commit_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Commit_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Commit_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Commit_out} Commit_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Commit_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Commit_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Commit_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Commit_out} Commit_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Commit_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Commit_out message.
                 * @function verify
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Commit_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Commit_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Commit_out} Commit_out
                 */
                Commit_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Commit_out)
                        return object;
                    var message = new $root.CS.PROTO.Commit_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Commit_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Commit_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Commit_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Commit_out
                 * @static
                 * @param {CS.PROTO.Commit_out} message Commit_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Commit_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Commit_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Commit_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Commit_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Commit_out;
            })();
    
            PROTO.Rollback_in = (function() {
    
                /**
                 * Properties of a Rollback_in.
                 * @memberof CS.PROTO
                 * @interface IRollback_in
                 * @property {CS.PROTO.IAPIService|null} [control] Rollback_in control
                 */
    
                /**
                 * Constructs a new Rollback_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Rollback_in.
                 * @implements IRollback_in
                 * @constructor
                 * @param {CS.PROTO.IRollback_in=} [properties] Properties to set
                 */
                function Rollback_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Rollback_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.Rollback_in
                 * @instance
                 */
                Rollback_in.prototype.control = null;
    
                /**
                 * Creates a new Rollback_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {CS.PROTO.IRollback_in=} [properties] Properties to set
                 * @returns {CS.PROTO.Rollback_in} Rollback_in instance
                 */
                Rollback_in.create = function create(properties) {
                    return new Rollback_in(properties);
                };
    
                /**
                 * Encodes the specified Rollback_in message. Does not implicitly {@link CS.PROTO.Rollback_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {CS.PROTO.IRollback_in} message Rollback_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rollback_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Rollback_in message, length delimited. Does not implicitly {@link CS.PROTO.Rollback_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {CS.PROTO.IRollback_in} message Rollback_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rollback_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Rollback_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Rollback_in} Rollback_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rollback_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Rollback_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Rollback_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Rollback_in} Rollback_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rollback_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Rollback_in message.
                 * @function verify
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Rollback_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Rollback_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Rollback_in} Rollback_in
                 */
                Rollback_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Rollback_in)
                        return object;
                    var message = new $root.CS.PROTO.Rollback_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.Rollback_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Rollback_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Rollback_in
                 * @static
                 * @param {CS.PROTO.Rollback_in} message Rollback_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Rollback_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.control = null;
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    return object;
                };
    
                /**
                 * Converts this Rollback_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Rollback_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Rollback_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Rollback_in;
            })();
    
            PROTO.Rollback_out = (function() {
    
                /**
                 * Properties of a Rollback_out.
                 * @memberof CS.PROTO
                 * @interface IRollback_out
                 * @property {CS.Status|null} [status] Rollback_out status
                 * @property {Array.<CS.IError>|null} [errors] Rollback_out errors
                 */
    
                /**
                 * Constructs a new Rollback_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents a Rollback_out.
                 * @implements IRollback_out
                 * @constructor
                 * @param {CS.PROTO.IRollback_out=} [properties] Properties to set
                 */
                function Rollback_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Rollback_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.Rollback_out
                 * @instance
                 */
                Rollback_out.prototype.status = 0;
    
                /**
                 * Rollback_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.Rollback_out
                 * @instance
                 */
                Rollback_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new Rollback_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {CS.PROTO.IRollback_out=} [properties] Properties to set
                 * @returns {CS.PROTO.Rollback_out} Rollback_out instance
                 */
                Rollback_out.create = function create(properties) {
                    return new Rollback_out(properties);
                };
    
                /**
                 * Encodes the specified Rollback_out message. Does not implicitly {@link CS.PROTO.Rollback_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {CS.PROTO.IRollback_out} message Rollback_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rollback_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Rollback_out message, length delimited. Does not implicitly {@link CS.PROTO.Rollback_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {CS.PROTO.IRollback_out} message Rollback_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rollback_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Rollback_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.Rollback_out} Rollback_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rollback_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.Rollback_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Rollback_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.Rollback_out} Rollback_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rollback_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Rollback_out message.
                 * @function verify
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Rollback_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Rollback_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.Rollback_out} Rollback_out
                 */
                Rollback_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.Rollback_out)
                        return object;
                    var message = new $root.CS.PROTO.Rollback_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.Rollback_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.Rollback_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Rollback_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.Rollback_out
                 * @static
                 * @param {CS.PROTO.Rollback_out} message Rollback_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Rollback_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Rollback_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.Rollback_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Rollback_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Rollback_out;
            })();
    
            PROTO.RDBMSJobService = (function() {
    
                /**
                 * Constructs a new RDBMSJobService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a RDBMSJobService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function RDBMSJobService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (RDBMSJobService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = RDBMSJobService;
    
                /**
                 * Creates new RDBMSJobService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.RDBMSJobService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {RDBMSJobService} RPC service. Useful where requests and/or responses are streamed.
                 */
                RDBMSJobService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#setClientInfo}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef SetClientInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.SetClientInfo_out} [response] SetClientInfo_out
                 */
    
                /**
                 * Calls SetClientInfo.
                 * @function setClientInfo
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.ISetClientInfo_in} request SetClientInfo_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.SetClientInfoCallback} callback Node-style callback called with the error, if any, and SetClientInfo_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.setClientInfo = function setClientInfo(request, callback) {
                    return this.rpcCall(setClientInfo, $root.CS.PROTO.SetClientInfo_in, $root.CS.PROTO.SetClientInfo_out, request, callback);
                }, "name", { value: "SetClientInfo" });
    
                /**
                 * Calls SetClientInfo.
                 * @function setClientInfo
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.ISetClientInfo_in} request SetClientInfo_in message or plain object
                 * @returns {Promise<CS.PROTO.SetClientInfo_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#getClientInfo}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef GetClientInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.GetClientInfo_out} [response] GetClientInfo_out
                 */
    
                /**
                 * Calls GetClientInfo.
                 * @function getClientInfo
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IGetClientInfo_in} request GetClientInfo_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.GetClientInfoCallback} callback Node-style callback called with the error, if any, and GetClientInfo_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.getClientInfo = function getClientInfo(request, callback) {
                    return this.rpcCall(getClientInfo, $root.CS.PROTO.GetClientInfo_in, $root.CS.PROTO.GetClientInfo_out, request, callback);
                }, "name", { value: "GetClientInfo" });
    
                /**
                 * Calls GetClientInfo.
                 * @function getClientInfo
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IGetClientInfo_in} request GetClientInfo_in message or plain object
                 * @returns {Promise<CS.PROTO.GetClientInfo_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#describe}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef DescribeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Describe_out} [response] Describe_out
                 */
    
                /**
                 * Calls Describe.
                 * @function describe
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IDescribe_in} request Describe_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.DescribeCallback} callback Node-style callback called with the error, if any, and Describe_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.describe = function describe(request, callback) {
                    return this.rpcCall(describe, $root.CS.PROTO.Describe_in, $root.CS.PROTO.Describe_out, request, callback);
                }, "name", { value: "Describe" });
    
                /**
                 * Calls Describe.
                 * @function describe
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IDescribe_in} request Describe_in message or plain object
                 * @returns {Promise<CS.PROTO.Describe_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#execute}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef ExecuteCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Execute_out} [response] Execute_out
                 */
    
                /**
                 * Calls Execute.
                 * @function execute
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IExecute_in} request Execute_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.ExecuteCallback} callback Node-style callback called with the error, if any, and Execute_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.execute = function execute(request, callback) {
                    return this.rpcCall(execute, $root.CS.PROTO.Execute_in, $root.CS.PROTO.Execute_out, request, callback);
                }, "name", { value: "Execute" });
    
                /**
                 * Calls Execute.
                 * @function execute
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IExecute_in} request Execute_in message or plain object
                 * @returns {Promise<CS.PROTO.Execute_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#nextResultSet}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef NextResultSetCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.NextResultSet_out} [response] NextResultSet_out
                 */
    
                /**
                 * Calls NextResultSet.
                 * @function nextResultSet
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.INextResultSet_in} request NextResultSet_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.NextResultSetCallback} callback Node-style callback called with the error, if any, and NextResultSet_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.nextResultSet = function nextResultSet(request, callback) {
                    return this.rpcCall(nextResultSet, $root.CS.PROTO.NextResultSet_in, $root.CS.PROTO.NextResultSet_out, request, callback);
                }, "name", { value: "NextResultSet" });
    
                /**
                 * Calls NextResultSet.
                 * @function nextResultSet
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.INextResultSet_in} request NextResultSet_in message or plain object
                 * @returns {Promise<CS.PROTO.NextResultSet_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#ping}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef PingCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Ping_out} [response] Ping_out
                 */
    
                /**
                 * Calls Ping.
                 * @function ping
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IPing_in} request Ping_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.PingCallback} callback Node-style callback called with the error, if any, and Ping_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.ping = function ping(request, callback) {
                    return this.rpcCall(ping, $root.CS.PROTO.Ping_in, $root.CS.PROTO.Ping_out, request, callback);
                }, "name", { value: "Ping" });
    
                /**
                 * Calls Ping.
                 * @function ping
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IPing_in} request Ping_in message or plain object
                 * @returns {Promise<CS.PROTO.Ping_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#pingInfo}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef PingInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.PingInfo_out} [response] PingInfo_out
                 */
    
                /**
                 * Calls PingInfo.
                 * @function pingInfo
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IPingInfo_in} request PingInfo_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.PingInfoCallback} callback Node-style callback called with the error, if any, and PingInfo_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.pingInfo = function pingInfo(request, callback) {
                    return this.rpcCall(pingInfo, $root.CS.PROTO.PingInfo_in, $root.CS.PROTO.PingInfo_out, request, callback);
                }, "name", { value: "PingInfo" });
    
                /**
                 * Calls PingInfo.
                 * @function pingInfo
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IPingInfo_in} request PingInfo_in message or plain object
                 * @returns {Promise<CS.PROTO.PingInfo_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#abort}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef AbortCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Abort_out} [response] Abort_out
                 */
    
                /**
                 * Calls Abort.
                 * @function abort
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IAbort_in} request Abort_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.AbortCallback} callback Node-style callback called with the error, if any, and Abort_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.abort = function abort(request, callback) {
                    return this.rpcCall(abort, $root.CS.PROTO.Abort_in, $root.CS.PROTO.Abort_out, request, callback);
                }, "name", { value: "Abort" });
    
                /**
                 * Calls Abort.
                 * @function abort
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IAbort_in} request Abort_in message or plain object
                 * @returns {Promise<CS.PROTO.Abort_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#commit}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef CommitCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Commit_out} [response] Commit_out
                 */
    
                /**
                 * Calls Commit.
                 * @function commit
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.ICommit_in} request Commit_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.CommitCallback} callback Node-style callback called with the error, if any, and Commit_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.commit = function commit(request, callback) {
                    return this.rpcCall(commit, $root.CS.PROTO.Commit_in, $root.CS.PROTO.Commit_out, request, callback);
                }, "name", { value: "Commit" });
    
                /**
                 * Calls Commit.
                 * @function commit
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.ICommit_in} request Commit_in message or plain object
                 * @returns {Promise<CS.PROTO.Commit_out>} Promise
                 * @variation 2
                 */
    
                /**
                 * Callback as used by {@link CS.PROTO.RDBMSJobService#rollback}.
                 * @memberof CS.PROTO.RDBMSJobService
                 * @typedef RollbackCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.Rollback_out} [response] Rollback_out
                 */
    
                /**
                 * Calls Rollback.
                 * @function rollback
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IRollback_in} request Rollback_in message or plain object
                 * @param {CS.PROTO.RDBMSJobService.RollbackCallback} callback Node-style callback called with the error, if any, and Rollback_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RDBMSJobService.prototype.rollback = function rollback(request, callback) {
                    return this.rpcCall(rollback, $root.CS.PROTO.Rollback_in, $root.CS.PROTO.Rollback_out, request, callback);
                }, "name", { value: "Rollback" });
    
                /**
                 * Calls Rollback.
                 * @function rollback
                 * @memberof CS.PROTO.RDBMSJobService
                 * @instance
                 * @param {CS.PROTO.IRollback_in} request Rollback_in message or plain object
                 * @returns {Promise<CS.PROTO.Rollback_out>} Promise
                 * @variation 2
                 */
    
                return RDBMSJobService;
            })();
    
            /**
             * InternalUpdateProperty_call enum.
             * @name CS.PROTO.InternalUpdateProperty_call
             * @enum {number}
             * @property {number} Unknown_InternalUpdateProperty_call=0 Unknown_InternalUpdateProperty_call value
             * @property {number} InternalUpdateProperty_call_I=1 InternalUpdateProperty_call_I value
             * @property {number} InternalUpdateProperty_call_B=2 InternalUpdateProperty_call_B value
             */
            PROTO.InternalUpdateProperty_call = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unknown_InternalUpdateProperty_call"] = 0;
                values[valuesById[1] = "InternalUpdateProperty_call_I"] = 1;
                values[valuesById[2] = "InternalUpdateProperty_call_B"] = 2;
                return values;
            })();
    
            PROTO.InternalUpdateProperty_in = (function() {
    
                /**
                 * Properties of an InternalUpdateProperty_in.
                 * @memberof CS.PROTO
                 * @interface IInternalUpdateProperty_in
                 * @property {CS.PROTO.IAPIService|null} [control] InternalUpdateProperty_in control
                 * @property {CS.PROTO.InternalUpdateProperty_call|null} [method] InternalUpdateProperty_in method
                 * @property {string|null} [name] InternalUpdateProperty_in name
                 * @property {number|null} [ivalue] InternalUpdateProperty_in ivalue
                 * @property {boolean|null} [bvalue] InternalUpdateProperty_in bvalue
                 */
    
                /**
                 * Constructs a new InternalUpdateProperty_in.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalUpdateProperty_in.
                 * @implements IInternalUpdateProperty_in
                 * @constructor
                 * @param {CS.PROTO.IInternalUpdateProperty_in=} [properties] Properties to set
                 */
                function InternalUpdateProperty_in(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalUpdateProperty_in control.
                 * @member {CS.PROTO.IAPIService|null|undefined} control
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @instance
                 */
                InternalUpdateProperty_in.prototype.control = null;
    
                /**
                 * InternalUpdateProperty_in method.
                 * @member {CS.PROTO.InternalUpdateProperty_call} method
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @instance
                 */
                InternalUpdateProperty_in.prototype.method = 0;
    
                /**
                 * InternalUpdateProperty_in name.
                 * @member {string} name
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @instance
                 */
                InternalUpdateProperty_in.prototype.name = "";
    
                /**
                 * InternalUpdateProperty_in ivalue.
                 * @member {number} ivalue
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @instance
                 */
                InternalUpdateProperty_in.prototype.ivalue = 0;
    
                /**
                 * InternalUpdateProperty_in bvalue.
                 * @member {boolean} bvalue
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @instance
                 */
                InternalUpdateProperty_in.prototype.bvalue = false;
    
                /**
                 * Creates a new InternalUpdateProperty_in instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {CS.PROTO.IInternalUpdateProperty_in=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalUpdateProperty_in} InternalUpdateProperty_in instance
                 */
                InternalUpdateProperty_in.create = function create(properties) {
                    return new InternalUpdateProperty_in(properties);
                };
    
                /**
                 * Encodes the specified InternalUpdateProperty_in message. Does not implicitly {@link CS.PROTO.InternalUpdateProperty_in.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {CS.PROTO.IInternalUpdateProperty_in} message InternalUpdateProperty_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalUpdateProperty_in.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                        $root.CS.PROTO.APIService.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.ivalue != null && Object.hasOwnProperty.call(message, "ivalue"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ivalue);
                    if (message.bvalue != null && Object.hasOwnProperty.call(message, "bvalue"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.bvalue);
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalUpdateProperty_in message, length delimited. Does not implicitly {@link CS.PROTO.InternalUpdateProperty_in.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {CS.PROTO.IInternalUpdateProperty_in} message InternalUpdateProperty_in message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalUpdateProperty_in.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalUpdateProperty_in message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalUpdateProperty_in} InternalUpdateProperty_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalUpdateProperty_in.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalUpdateProperty_in();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.control = $root.CS.PROTO.APIService.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.method = reader.int32();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.ivalue = reader.int32();
                            break;
                        case 5:
                            message.bvalue = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalUpdateProperty_in message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalUpdateProperty_in} InternalUpdateProperty_in
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalUpdateProperty_in.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalUpdateProperty_in message.
                 * @function verify
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalUpdateProperty_in.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.control != null && message.hasOwnProperty("control")) {
                        var error = $root.CS.PROTO.APIService.verify(message.control);
                        if (error)
                            return "control." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        switch (message.method) {
                        default:
                            return "method: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.ivalue != null && message.hasOwnProperty("ivalue"))
                        if (!$util.isInteger(message.ivalue))
                            return "ivalue: integer expected";
                    if (message.bvalue != null && message.hasOwnProperty("bvalue"))
                        if (typeof message.bvalue !== "boolean")
                            return "bvalue: boolean expected";
                    return null;
                };
    
                /**
                 * Creates an InternalUpdateProperty_in message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalUpdateProperty_in} InternalUpdateProperty_in
                 */
                InternalUpdateProperty_in.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalUpdateProperty_in)
                        return object;
                    var message = new $root.CS.PROTO.InternalUpdateProperty_in();
                    if (object.control != null) {
                        if (typeof object.control !== "object")
                            throw TypeError(".CS.PROTO.InternalUpdateProperty_in.control: object expected");
                        message.control = $root.CS.PROTO.APIService.fromObject(object.control);
                    }
                    switch (object.method) {
                    case "Unknown_InternalUpdateProperty_call":
                    case 0:
                        message.method = 0;
                        break;
                    case "InternalUpdateProperty_call_I":
                    case 1:
                        message.method = 1;
                        break;
                    case "InternalUpdateProperty_call_B":
                    case 2:
                        message.method = 2;
                        break;
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.ivalue != null)
                        message.ivalue = object.ivalue | 0;
                    if (object.bvalue != null)
                        message.bvalue = Boolean(object.bvalue);
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalUpdateProperty_in message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @static
                 * @param {CS.PROTO.InternalUpdateProperty_in} message InternalUpdateProperty_in
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalUpdateProperty_in.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.control = null;
                        object.method = options.enums === String ? "Unknown_InternalUpdateProperty_call" : 0;
                        object.name = "";
                        object.ivalue = 0;
                        object.bvalue = false;
                    }
                    if (message.control != null && message.hasOwnProperty("control"))
                        object.control = $root.CS.PROTO.APIService.toObject(message.control, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = options.enums === String ? $root.CS.PROTO.InternalUpdateProperty_call[message.method] : message.method;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.ivalue != null && message.hasOwnProperty("ivalue"))
                        object.ivalue = message.ivalue;
                    if (message.bvalue != null && message.hasOwnProperty("bvalue"))
                        object.bvalue = message.bvalue;
                    return object;
                };
    
                /**
                 * Converts this InternalUpdateProperty_in to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalUpdateProperty_in
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalUpdateProperty_in.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalUpdateProperty_in;
            })();
    
            PROTO.InternalUpdateProperty_out = (function() {
    
                /**
                 * Properties of an InternalUpdateProperty_out.
                 * @memberof CS.PROTO
                 * @interface IInternalUpdateProperty_out
                 * @property {CS.Status|null} [status] InternalUpdateProperty_out status
                 * @property {Array.<CS.IError>|null} [errors] InternalUpdateProperty_out errors
                 */
    
                /**
                 * Constructs a new InternalUpdateProperty_out.
                 * @memberof CS.PROTO
                 * @classdesc Represents an InternalUpdateProperty_out.
                 * @implements IInternalUpdateProperty_out
                 * @constructor
                 * @param {CS.PROTO.IInternalUpdateProperty_out=} [properties] Properties to set
                 */
                function InternalUpdateProperty_out(properties) {
                    this.errors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InternalUpdateProperty_out status.
                 * @member {CS.Status} status
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @instance
                 */
                InternalUpdateProperty_out.prototype.status = 0;
    
                /**
                 * InternalUpdateProperty_out errors.
                 * @member {Array.<CS.IError>} errors
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @instance
                 */
                InternalUpdateProperty_out.prototype.errors = $util.emptyArray;
    
                /**
                 * Creates a new InternalUpdateProperty_out instance using the specified properties.
                 * @function create
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {CS.PROTO.IInternalUpdateProperty_out=} [properties] Properties to set
                 * @returns {CS.PROTO.InternalUpdateProperty_out} InternalUpdateProperty_out instance
                 */
                InternalUpdateProperty_out.create = function create(properties) {
                    return new InternalUpdateProperty_out(properties);
                };
    
                /**
                 * Encodes the specified InternalUpdateProperty_out message. Does not implicitly {@link CS.PROTO.InternalUpdateProperty_out.verify|verify} messages.
                 * @function encode
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {CS.PROTO.IInternalUpdateProperty_out} message InternalUpdateProperty_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalUpdateProperty_out.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.errors != null && message.errors.length)
                        for (var i = 0; i < message.errors.length; ++i)
                            $root.CS.Error.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InternalUpdateProperty_out message, length delimited. Does not implicitly {@link CS.PROTO.InternalUpdateProperty_out.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {CS.PROTO.IInternalUpdateProperty_out} message InternalUpdateProperty_out message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InternalUpdateProperty_out.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InternalUpdateProperty_out message from the specified reader or buffer.
                 * @function decode
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CS.PROTO.InternalUpdateProperty_out} InternalUpdateProperty_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalUpdateProperty_out.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PROTO.InternalUpdateProperty_out();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.CS.Error.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InternalUpdateProperty_out message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CS.PROTO.InternalUpdateProperty_out} InternalUpdateProperty_out
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InternalUpdateProperty_out.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InternalUpdateProperty_out message.
                 * @function verify
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InternalUpdateProperty_out.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (var i = 0; i < message.errors.length; ++i) {
                            var error = $root.CS.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InternalUpdateProperty_out message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CS.PROTO.InternalUpdateProperty_out} InternalUpdateProperty_out
                 */
                InternalUpdateProperty_out.fromObject = function fromObject(object) {
                    if (object instanceof $root.CS.PROTO.InternalUpdateProperty_out)
                        return object;
                    var message = new $root.CS.PROTO.InternalUpdateProperty_out();
                    switch (object.status) {
                    case "Unknown_Status":
                    case 0:
                        message.status = 0;
                        break;
                    case "NoMoreResult":
                    case 1:
                        message.status = 1;
                        break;
                    case "Success":
                    case 2:
                        message.status = 2;
                        break;
                    case "Info":
                    case 3:
                        message.status = 3;
                        break;
                    case "Warning":
                    case 4:
                        message.status = 4;
                        break;
                    case "Fatal":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".CS.PROTO.InternalUpdateProperty_out.errors: array expected");
                        message.errors = [];
                        for (var i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".CS.PROTO.InternalUpdateProperty_out.errors: object expected");
                            message.errors[i] = $root.CS.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InternalUpdateProperty_out message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @static
                 * @param {CS.PROTO.InternalUpdateProperty_out} message InternalUpdateProperty_out
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InternalUpdateProperty_out.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "Unknown_Status" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.CS.Status[message.status] : message.status;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (var j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.CS.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InternalUpdateProperty_out to JSON.
                 * @function toJSON
                 * @memberof CS.PROTO.InternalUpdateProperty_out
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InternalUpdateProperty_out.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InternalUpdateProperty_out;
            })();
    
            PROTO.RuntimePropertyService = (function() {
    
                /**
                 * Constructs a new RuntimePropertyService service.
                 * @memberof CS.PROTO
                 * @classdesc Represents a RuntimePropertyService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function RuntimePropertyService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
    
                (RuntimePropertyService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = RuntimePropertyService;
    
                /**
                 * Creates new RuntimePropertyService service using the specified rpc implementation.
                 * @function create
                 * @memberof CS.PROTO.RuntimePropertyService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {RuntimePropertyService} RPC service. Useful where requests and/or responses are streamed.
                 */
                RuntimePropertyService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };
    
                /**
                 * Callback as used by {@link CS.PROTO.RuntimePropertyService#internalUpdateProperty}.
                 * @memberof CS.PROTO.RuntimePropertyService
                 * @typedef InternalUpdatePropertyCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {CS.PROTO.InternalUpdateProperty_out} [response] InternalUpdateProperty_out
                 */
    
                /**
                 * Calls InternalUpdateProperty.
                 * @function internalUpdateProperty
                 * @memberof CS.PROTO.RuntimePropertyService
                 * @instance
                 * @param {CS.PROTO.IInternalUpdateProperty_in} request InternalUpdateProperty_in message or plain object
                 * @param {CS.PROTO.RuntimePropertyService.InternalUpdatePropertyCallback} callback Node-style callback called with the error, if any, and InternalUpdateProperty_out
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RuntimePropertyService.prototype.internalUpdateProperty = function internalUpdateProperty(request, callback) {
                    return this.rpcCall(internalUpdateProperty, $root.CS.PROTO.InternalUpdateProperty_in, $root.CS.PROTO.InternalUpdateProperty_out, request, callback);
                }, "name", { value: "InternalUpdateProperty" });
    
                /**
                 * Calls InternalUpdateProperty.
                 * @function internalUpdateProperty
                 * @memberof CS.PROTO.RuntimePropertyService
                 * @instance
                 * @param {CS.PROTO.IInternalUpdateProperty_in} request InternalUpdateProperty_in message or plain object
                 * @returns {Promise<CS.PROTO.InternalUpdateProperty_out>} Promise
                 * @variation 2
                 */
    
                return RuntimePropertyService;
            })();
    
            return PROTO;
        })();
    
        /**
         * Status enum.
         * @name CS.Status
         * @enum {number}
         * @property {number} Unknown_Status=0 Unknown_Status value
         * @property {number} NoMoreResult=1 NoMoreResult value
         * @property {number} Success=2 Success value
         * @property {number} Info=3 Info value
         * @property {number} Warning=4 Warning value
         * @property {number} Fatal=5 Fatal value
         */
        CS.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_Status"] = 0;
            values[valuesById[1] = "NoMoreResult"] = 1;
            values[valuesById[2] = "Success"] = 2;
            values[valuesById[3] = "Info"] = 3;
            values[valuesById[4] = "Warning"] = 4;
            values[valuesById[5] = "Fatal"] = 5;
            return values;
        })();
    
        /**
         * ErrorType enum.
         * @name CS.ErrorType
         * @enum {number}
         * @property {number} Unknown_ErrorType=0 Unknown_ErrorType value
         * @property {number} DBD=1 DBD value
         * @property {number} CS=2 CS value
         * @property {number} RSSLOG=3 RSSLOG value
         */
        CS.ErrorType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_ErrorType"] = 0;
            values[valuesById[1] = "DBD"] = 1;
            values[valuesById[2] = "CS"] = 2;
            values[valuesById[3] = "RSSLOG"] = 3;
            return values;
        })();
    
        CS.DBDError = (function() {
    
            /**
             * Properties of a DBDError.
             * @memberof CS
             * @interface IDBDError
             * @property {string|null} [m_State] DBDError m_State
             * @property {string|null} [m_RDBMSMessage] DBDError m_RDBMSMessage
             * @property {number|null} [m_RDBMSError] DBDError m_RDBMSError
             */
    
            /**
             * Constructs a new DBDError.
             * @memberof CS
             * @classdesc Represents a DBDError.
             * @implements IDBDError
             * @constructor
             * @param {CS.IDBDError=} [properties] Properties to set
             */
            function DBDError(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DBDError m_State.
             * @member {string} m_State
             * @memberof CS.DBDError
             * @instance
             */
            DBDError.prototype.m_State = "";
    
            /**
             * DBDError m_RDBMSMessage.
             * @member {string} m_RDBMSMessage
             * @memberof CS.DBDError
             * @instance
             */
            DBDError.prototype.m_RDBMSMessage = "";
    
            /**
             * DBDError m_RDBMSError.
             * @member {number} m_RDBMSError
             * @memberof CS.DBDError
             * @instance
             */
            DBDError.prototype.m_RDBMSError = 0;
    
            /**
             * Creates a new DBDError instance using the specified properties.
             * @function create
             * @memberof CS.DBDError
             * @static
             * @param {CS.IDBDError=} [properties] Properties to set
             * @returns {CS.DBDError} DBDError instance
             */
            DBDError.create = function create(properties) {
                return new DBDError(properties);
            };
    
            /**
             * Encodes the specified DBDError message. Does not implicitly {@link CS.DBDError.verify|verify} messages.
             * @function encode
             * @memberof CS.DBDError
             * @static
             * @param {CS.IDBDError} message DBDError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DBDError.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_State != null && Object.hasOwnProperty.call(message, "m_State"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_State);
                if (message.m_RDBMSMessage != null && Object.hasOwnProperty.call(message, "m_RDBMSMessage"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_RDBMSMessage);
                if (message.m_RDBMSError != null && Object.hasOwnProperty.call(message, "m_RDBMSError"))
                    writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.m_RDBMSError);
                return writer;
            };
    
            /**
             * Encodes the specified DBDError message, length delimited. Does not implicitly {@link CS.DBDError.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.DBDError
             * @static
             * @param {CS.IDBDError} message DBDError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DBDError.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DBDError message from the specified reader or buffer.
             * @function decode
             * @memberof CS.DBDError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.DBDError} DBDError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DBDError.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.DBDError();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_State = reader.string();
                        break;
                    case 2:
                        message.m_RDBMSMessage = reader.string();
                        break;
                    case 3:
                        message.m_RDBMSError = reader.sint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DBDError message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.DBDError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.DBDError} DBDError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DBDError.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DBDError message.
             * @function verify
             * @memberof CS.DBDError
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DBDError.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_State != null && message.hasOwnProperty("m_State"))
                    if (!$util.isString(message.m_State))
                        return "m_State: string expected";
                if (message.m_RDBMSMessage != null && message.hasOwnProperty("m_RDBMSMessage"))
                    if (!$util.isString(message.m_RDBMSMessage))
                        return "m_RDBMSMessage: string expected";
                if (message.m_RDBMSError != null && message.hasOwnProperty("m_RDBMSError"))
                    if (!$util.isInteger(message.m_RDBMSError))
                        return "m_RDBMSError: integer expected";
                return null;
            };
    
            /**
             * Creates a DBDError message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.DBDError
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.DBDError} DBDError
             */
            DBDError.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.DBDError)
                    return object;
                var message = new $root.CS.DBDError();
                if (object.m_State != null)
                    message.m_State = String(object.m_State);
                if (object.m_RDBMSMessage != null)
                    message.m_RDBMSMessage = String(object.m_RDBMSMessage);
                if (object.m_RDBMSError != null)
                    message.m_RDBMSError = object.m_RDBMSError | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a DBDError message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.DBDError
             * @static
             * @param {CS.DBDError} message DBDError
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DBDError.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_State = "";
                    object.m_RDBMSMessage = "";
                    object.m_RDBMSError = 0;
                }
                if (message.m_State != null && message.hasOwnProperty("m_State"))
                    object.m_State = message.m_State;
                if (message.m_RDBMSMessage != null && message.hasOwnProperty("m_RDBMSMessage"))
                    object.m_RDBMSMessage = message.m_RDBMSMessage;
                if (message.m_RDBMSError != null && message.hasOwnProperty("m_RDBMSError"))
                    object.m_RDBMSError = message.m_RDBMSError;
                return object;
            };
    
            /**
             * Converts this DBDError to JSON.
             * @function toJSON
             * @memberof CS.DBDError
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DBDError.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DBDError;
        })();
    
        CS.CSError = (function() {
    
            /**
             * Properties of a CSError.
             * @memberof CS
             * @interface ICSError
             * @property {number|null} [m_IDModule] CSError m_IDModule
             * @property {string|null} [m_Argument] CSError m_Argument
             */
    
            /**
             * Constructs a new CSError.
             * @memberof CS
             * @classdesc Represents a CSError.
             * @implements ICSError
             * @constructor
             * @param {CS.ICSError=} [properties] Properties to set
             */
            function CSError(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CSError m_IDModule.
             * @member {number} m_IDModule
             * @memberof CS.CSError
             * @instance
             */
            CSError.prototype.m_IDModule = 0;
    
            /**
             * CSError m_Argument.
             * @member {string} m_Argument
             * @memberof CS.CSError
             * @instance
             */
            CSError.prototype.m_Argument = "";
    
            /**
             * Creates a new CSError instance using the specified properties.
             * @function create
             * @memberof CS.CSError
             * @static
             * @param {CS.ICSError=} [properties] Properties to set
             * @returns {CS.CSError} CSError instance
             */
            CSError.create = function create(properties) {
                return new CSError(properties);
            };
    
            /**
             * Encodes the specified CSError message. Does not implicitly {@link CS.CSError.verify|verify} messages.
             * @function encode
             * @memberof CS.CSError
             * @static
             * @param {CS.ICSError} message CSError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CSError.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_IDModule != null && Object.hasOwnProperty.call(message, "m_IDModule"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.m_IDModule);
                if (message.m_Argument != null && Object.hasOwnProperty.call(message, "m_Argument"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Argument);
                return writer;
            };
    
            /**
             * Encodes the specified CSError message, length delimited. Does not implicitly {@link CS.CSError.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.CSError
             * @static
             * @param {CS.ICSError} message CSError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CSError.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CSError message from the specified reader or buffer.
             * @function decode
             * @memberof CS.CSError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.CSError} CSError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CSError.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.CSError();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_IDModule = reader.uint32();
                        break;
                    case 2:
                        message.m_Argument = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CSError message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.CSError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.CSError} CSError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CSError.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CSError message.
             * @function verify
             * @memberof CS.CSError
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CSError.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_IDModule != null && message.hasOwnProperty("m_IDModule"))
                    if (!$util.isInteger(message.m_IDModule))
                        return "m_IDModule: integer expected";
                if (message.m_Argument != null && message.hasOwnProperty("m_Argument"))
                    if (!$util.isString(message.m_Argument))
                        return "m_Argument: string expected";
                return null;
            };
    
            /**
             * Creates a CSError message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.CSError
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.CSError} CSError
             */
            CSError.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.CSError)
                    return object;
                var message = new $root.CS.CSError();
                if (object.m_IDModule != null)
                    message.m_IDModule = object.m_IDModule >>> 0;
                if (object.m_Argument != null)
                    message.m_Argument = String(object.m_Argument);
                return message;
            };
    
            /**
             * Creates a plain object from a CSError message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.CSError
             * @static
             * @param {CS.CSError} message CSError
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CSError.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_IDModule = 0;
                    object.m_Argument = "";
                }
                if (message.m_IDModule != null && message.hasOwnProperty("m_IDModule"))
                    object.m_IDModule = message.m_IDModule;
                if (message.m_Argument != null && message.hasOwnProperty("m_Argument"))
                    object.m_Argument = message.m_Argument;
                return object;
            };
    
            /**
             * Converts this CSError to JSON.
             * @function toJSON
             * @memberof CS.CSError
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CSError.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CSError;
        })();
    
        CS.RssLogError = (function() {
    
            /**
             * Properties of a RssLogError.
             * @memberof CS
             * @interface IRssLogError
             * @property {string|null} [m_Sql] RssLogError m_Sql
             */
    
            /**
             * Constructs a new RssLogError.
             * @memberof CS
             * @classdesc Represents a RssLogError.
             * @implements IRssLogError
             * @constructor
             * @param {CS.IRssLogError=} [properties] Properties to set
             */
            function RssLogError(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RssLogError m_Sql.
             * @member {string} m_Sql
             * @memberof CS.RssLogError
             * @instance
             */
            RssLogError.prototype.m_Sql = "";
    
            /**
             * Creates a new RssLogError instance using the specified properties.
             * @function create
             * @memberof CS.RssLogError
             * @static
             * @param {CS.IRssLogError=} [properties] Properties to set
             * @returns {CS.RssLogError} RssLogError instance
             */
            RssLogError.create = function create(properties) {
                return new RssLogError(properties);
            };
    
            /**
             * Encodes the specified RssLogError message. Does not implicitly {@link CS.RssLogError.verify|verify} messages.
             * @function encode
             * @memberof CS.RssLogError
             * @static
             * @param {CS.IRssLogError} message RssLogError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RssLogError.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Sql != null && Object.hasOwnProperty.call(message, "m_Sql"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Sql);
                return writer;
            };
    
            /**
             * Encodes the specified RssLogError message, length delimited. Does not implicitly {@link CS.RssLogError.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.RssLogError
             * @static
             * @param {CS.IRssLogError} message RssLogError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RssLogError.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RssLogError message from the specified reader or buffer.
             * @function decode
             * @memberof CS.RssLogError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.RssLogError} RssLogError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RssLogError.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.RssLogError();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Sql = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RssLogError message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.RssLogError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.RssLogError} RssLogError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RssLogError.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RssLogError message.
             * @function verify
             * @memberof CS.RssLogError
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RssLogError.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    if (!$util.isString(message.m_Sql))
                        return "m_Sql: string expected";
                return null;
            };
    
            /**
             * Creates a RssLogError message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.RssLogError
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.RssLogError} RssLogError
             */
            RssLogError.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.RssLogError)
                    return object;
                var message = new $root.CS.RssLogError();
                if (object.m_Sql != null)
                    message.m_Sql = String(object.m_Sql);
                return message;
            };
    
            /**
             * Creates a plain object from a RssLogError message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.RssLogError
             * @static
             * @param {CS.RssLogError} message RssLogError
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RssLogError.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.m_Sql = "";
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    object.m_Sql = message.m_Sql;
                return object;
            };
    
            /**
             * Converts this RssLogError to JSON.
             * @function toJSON
             * @memberof CS.RssLogError
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RssLogError.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RssLogError;
        })();
    
        CS.SpecificError = (function() {
    
            /**
             * Properties of a SpecificError.
             * @memberof CS
             * @interface ISpecificError
             * @property {CS.IDBDError|null} [m_DBDError] SpecificError m_DBDError
             * @property {CS.ICSError|null} [m_CSError] SpecificError m_CSError
             * @property {CS.IRssLogError|null} [m_RssLog] SpecificError m_RssLog
             */
    
            /**
             * Constructs a new SpecificError.
             * @memberof CS
             * @classdesc Represents a SpecificError.
             * @implements ISpecificError
             * @constructor
             * @param {CS.ISpecificError=} [properties] Properties to set
             */
            function SpecificError(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SpecificError m_DBDError.
             * @member {CS.IDBDError|null|undefined} m_DBDError
             * @memberof CS.SpecificError
             * @instance
             */
            SpecificError.prototype.m_DBDError = null;
    
            /**
             * SpecificError m_CSError.
             * @member {CS.ICSError|null|undefined} m_CSError
             * @memberof CS.SpecificError
             * @instance
             */
            SpecificError.prototype.m_CSError = null;
    
            /**
             * SpecificError m_RssLog.
             * @member {CS.IRssLogError|null|undefined} m_RssLog
             * @memberof CS.SpecificError
             * @instance
             */
            SpecificError.prototype.m_RssLog = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * SpecificError SpecificErrorUnion.
             * @member {"m_DBDError"|"m_CSError"|"m_RssLog"|undefined} SpecificErrorUnion
             * @memberof CS.SpecificError
             * @instance
             */
            Object.defineProperty(SpecificError.prototype, "SpecificErrorUnion", {
                get: $util.oneOfGetter($oneOfFields = ["m_DBDError", "m_CSError", "m_RssLog"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new SpecificError instance using the specified properties.
             * @function create
             * @memberof CS.SpecificError
             * @static
             * @param {CS.ISpecificError=} [properties] Properties to set
             * @returns {CS.SpecificError} SpecificError instance
             */
            SpecificError.create = function create(properties) {
                return new SpecificError(properties);
            };
    
            /**
             * Encodes the specified SpecificError message. Does not implicitly {@link CS.SpecificError.verify|verify} messages.
             * @function encode
             * @memberof CS.SpecificError
             * @static
             * @param {CS.ISpecificError} message SpecificError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecificError.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_DBDError != null && Object.hasOwnProperty.call(message, "m_DBDError"))
                    $root.CS.DBDError.encode(message.m_DBDError, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_CSError != null && Object.hasOwnProperty.call(message, "m_CSError"))
                    $root.CS.CSError.encode(message.m_CSError, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.m_RssLog != null && Object.hasOwnProperty.call(message, "m_RssLog"))
                    $root.CS.RssLogError.encode(message.m_RssLog, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SpecificError message, length delimited. Does not implicitly {@link CS.SpecificError.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SpecificError
             * @static
             * @param {CS.ISpecificError} message SpecificError message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecificError.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SpecificError message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SpecificError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SpecificError} SpecificError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecificError.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SpecificError();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_DBDError = $root.CS.DBDError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.m_CSError = $root.CS.CSError.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.m_RssLog = $root.CS.RssLogError.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SpecificError message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SpecificError
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SpecificError} SpecificError
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecificError.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SpecificError message.
             * @function verify
             * @memberof CS.SpecificError
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecificError.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.m_DBDError != null && message.hasOwnProperty("m_DBDError")) {
                    properties.SpecificErrorUnion = 1;
                    {
                        var error = $root.CS.DBDError.verify(message.m_DBDError);
                        if (error)
                            return "m_DBDError." + error;
                    }
                }
                if (message.m_CSError != null && message.hasOwnProperty("m_CSError")) {
                    if (properties.SpecificErrorUnion === 1)
                        return "SpecificErrorUnion: multiple values";
                    properties.SpecificErrorUnion = 1;
                    {
                        var error = $root.CS.CSError.verify(message.m_CSError);
                        if (error)
                            return "m_CSError." + error;
                    }
                }
                if (message.m_RssLog != null && message.hasOwnProperty("m_RssLog")) {
                    if (properties.SpecificErrorUnion === 1)
                        return "SpecificErrorUnion: multiple values";
                    properties.SpecificErrorUnion = 1;
                    {
                        var error = $root.CS.RssLogError.verify(message.m_RssLog);
                        if (error)
                            return "m_RssLog." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SpecificError message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SpecificError
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SpecificError} SpecificError
             */
            SpecificError.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SpecificError)
                    return object;
                var message = new $root.CS.SpecificError();
                if (object.m_DBDError != null) {
                    if (typeof object.m_DBDError !== "object")
                        throw TypeError(".CS.SpecificError.m_DBDError: object expected");
                    message.m_DBDError = $root.CS.DBDError.fromObject(object.m_DBDError);
                }
                if (object.m_CSError != null) {
                    if (typeof object.m_CSError !== "object")
                        throw TypeError(".CS.SpecificError.m_CSError: object expected");
                    message.m_CSError = $root.CS.CSError.fromObject(object.m_CSError);
                }
                if (object.m_RssLog != null) {
                    if (typeof object.m_RssLog !== "object")
                        throw TypeError(".CS.SpecificError.m_RssLog: object expected");
                    message.m_RssLog = $root.CS.RssLogError.fromObject(object.m_RssLog);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SpecificError message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SpecificError
             * @static
             * @param {CS.SpecificError} message SpecificError
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpecificError.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.m_DBDError != null && message.hasOwnProperty("m_DBDError")) {
                    object.m_DBDError = $root.CS.DBDError.toObject(message.m_DBDError, options);
                    if (options.oneofs)
                        object.SpecificErrorUnion = "m_DBDError";
                }
                if (message.m_CSError != null && message.hasOwnProperty("m_CSError")) {
                    object.m_CSError = $root.CS.CSError.toObject(message.m_CSError, options);
                    if (options.oneofs)
                        object.SpecificErrorUnion = "m_CSError";
                }
                if (message.m_RssLog != null && message.hasOwnProperty("m_RssLog")) {
                    object.m_RssLog = $root.CS.RssLogError.toObject(message.m_RssLog, options);
                    if (options.oneofs)
                        object.SpecificErrorUnion = "m_RssLog";
                }
                return object;
            };
    
            /**
             * Converts this SpecificError to JSON.
             * @function toJSON
             * @memberof CS.SpecificError
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpecificError.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SpecificError;
        })();
    
        CS.Error = (function() {
    
            /**
             * Properties of an Error.
             * @memberof CS
             * @interface IError
             * @property {CS.Status|null} [m_Level] Error m_Level
             * @property {number|null} [m_IDMessage] Error m_IDMessage
             * @property {CS.ISpecificError|null} [m_SpecificError] Error m_SpecificError
             */
    
            /**
             * Constructs a new Error.
             * @memberof CS
             * @classdesc Represents an Error.
             * @implements IError
             * @constructor
             * @param {CS.IError=} [properties] Properties to set
             */
            function Error(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Error m_Level.
             * @member {CS.Status} m_Level
             * @memberof CS.Error
             * @instance
             */
            Error.prototype.m_Level = 0;
    
            /**
             * Error m_IDMessage.
             * @member {number} m_IDMessage
             * @memberof CS.Error
             * @instance
             */
            Error.prototype.m_IDMessage = 0;
    
            /**
             * Error m_SpecificError.
             * @member {CS.ISpecificError|null|undefined} m_SpecificError
             * @memberof CS.Error
             * @instance
             */
            Error.prototype.m_SpecificError = null;
    
            /**
             * Creates a new Error instance using the specified properties.
             * @function create
             * @memberof CS.Error
             * @static
             * @param {CS.IError=} [properties] Properties to set
             * @returns {CS.Error} Error instance
             */
            Error.create = function create(properties) {
                return new Error(properties);
            };
    
            /**
             * Encodes the specified Error message. Does not implicitly {@link CS.Error.verify|verify} messages.
             * @function encode
             * @memberof CS.Error
             * @static
             * @param {CS.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Level != null && Object.hasOwnProperty.call(message, "m_Level"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.m_Level);
                if (message.m_IDMessage != null && Object.hasOwnProperty.call(message, "m_IDMessage"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.m_IDMessage);
                if (message.m_SpecificError != null && Object.hasOwnProperty.call(message, "m_SpecificError"))
                    $root.CS.SpecificError.encode(message.m_SpecificError, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Error message, length delimited. Does not implicitly {@link CS.Error.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Error
             * @static
             * @param {CS.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Error message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Error();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Level = reader.int32();
                        break;
                    case 2:
                        message.m_IDMessage = reader.uint32();
                        break;
                    case 3:
                        message.m_SpecificError = $root.CS.SpecificError.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Error message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Error message.
             * @function verify
             * @memberof CS.Error
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Error.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Level != null && message.hasOwnProperty("m_Level"))
                    switch (message.m_Level) {
                    default:
                        return "m_Level: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.m_IDMessage != null && message.hasOwnProperty("m_IDMessage"))
                    if (!$util.isInteger(message.m_IDMessage))
                        return "m_IDMessage: integer expected";
                if (message.m_SpecificError != null && message.hasOwnProperty("m_SpecificError")) {
                    var error = $root.CS.SpecificError.verify(message.m_SpecificError);
                    if (error)
                        return "m_SpecificError." + error;
                }
                return null;
            };
    
            /**
             * Creates an Error message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Error
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Error} Error
             */
            Error.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Error)
                    return object;
                var message = new $root.CS.Error();
                switch (object.m_Level) {
                case "Unknown_Status":
                case 0:
                    message.m_Level = 0;
                    break;
                case "NoMoreResult":
                case 1:
                    message.m_Level = 1;
                    break;
                case "Success":
                case 2:
                    message.m_Level = 2;
                    break;
                case "Info":
                case 3:
                    message.m_Level = 3;
                    break;
                case "Warning":
                case 4:
                    message.m_Level = 4;
                    break;
                case "Fatal":
                case 5:
                    message.m_Level = 5;
                    break;
                }
                if (object.m_IDMessage != null)
                    message.m_IDMessage = object.m_IDMessage >>> 0;
                if (object.m_SpecificError != null) {
                    if (typeof object.m_SpecificError !== "object")
                        throw TypeError(".CS.Error.m_SpecificError: object expected");
                    message.m_SpecificError = $root.CS.SpecificError.fromObject(object.m_SpecificError);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Error message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Error
             * @static
             * @param {CS.Error} message Error
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Error.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Level = options.enums === String ? "Unknown_Status" : 0;
                    object.m_IDMessage = 0;
                    object.m_SpecificError = null;
                }
                if (message.m_Level != null && message.hasOwnProperty("m_Level"))
                    object.m_Level = options.enums === String ? $root.CS.Status[message.m_Level] : message.m_Level;
                if (message.m_IDMessage != null && message.hasOwnProperty("m_IDMessage"))
                    object.m_IDMessage = message.m_IDMessage;
                if (message.m_SpecificError != null && message.hasOwnProperty("m_SpecificError"))
                    object.m_SpecificError = $root.CS.SpecificError.toObject(message.m_SpecificError, options);
                return object;
            };
    
            /**
             * Converts this Error to JSON.
             * @function toJSON
             * @memberof CS.Error
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Error.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Error;
        })();
    
        CS.NetworkLayerDescription = (function() {
    
            /**
             * Properties of a NetworkLayerDescription.
             * @memberof CS
             * @interface INetworkLayerDescription
             * @property {string|null} [m_Name] NetworkLayerDescription m_Name
             * @property {string|null} [m_InternalName] NetworkLayerDescription m_InternalName
             * @property {string|null} [m_Comment] NetworkLayerDescription m_Comment
             */
    
            /**
             * Constructs a new NetworkLayerDescription.
             * @memberof CS
             * @classdesc Represents a NetworkLayerDescription.
             * @implements INetworkLayerDescription
             * @constructor
             * @param {CS.INetworkLayerDescription=} [properties] Properties to set
             */
            function NetworkLayerDescription(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NetworkLayerDescription m_Name.
             * @member {string} m_Name
             * @memberof CS.NetworkLayerDescription
             * @instance
             */
            NetworkLayerDescription.prototype.m_Name = "";
    
            /**
             * NetworkLayerDescription m_InternalName.
             * @member {string} m_InternalName
             * @memberof CS.NetworkLayerDescription
             * @instance
             */
            NetworkLayerDescription.prototype.m_InternalName = "";
    
            /**
             * NetworkLayerDescription m_Comment.
             * @member {string} m_Comment
             * @memberof CS.NetworkLayerDescription
             * @instance
             */
            NetworkLayerDescription.prototype.m_Comment = "";
    
            /**
             * Creates a new NetworkLayerDescription instance using the specified properties.
             * @function create
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {CS.INetworkLayerDescription=} [properties] Properties to set
             * @returns {CS.NetworkLayerDescription} NetworkLayerDescription instance
             */
            NetworkLayerDescription.create = function create(properties) {
                return new NetworkLayerDescription(properties);
            };
    
            /**
             * Encodes the specified NetworkLayerDescription message. Does not implicitly {@link CS.NetworkLayerDescription.verify|verify} messages.
             * @function encode
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {CS.INetworkLayerDescription} message NetworkLayerDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkLayerDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Name);
                if (message.m_InternalName != null && Object.hasOwnProperty.call(message, "m_InternalName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_InternalName);
                if (message.m_Comment != null && Object.hasOwnProperty.call(message, "m_Comment"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_Comment);
                return writer;
            };
    
            /**
             * Encodes the specified NetworkLayerDescription message, length delimited. Does not implicitly {@link CS.NetworkLayerDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {CS.INetworkLayerDescription} message NetworkLayerDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkLayerDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NetworkLayerDescription message from the specified reader or buffer.
             * @function decode
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.NetworkLayerDescription} NetworkLayerDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkLayerDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.NetworkLayerDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Name = reader.string();
                        break;
                    case 2:
                        message.m_InternalName = reader.string();
                        break;
                    case 3:
                        message.m_Comment = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NetworkLayerDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.NetworkLayerDescription} NetworkLayerDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkLayerDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NetworkLayerDescription message.
             * @function verify
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NetworkLayerDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_InternalName != null && message.hasOwnProperty("m_InternalName"))
                    if (!$util.isString(message.m_InternalName))
                        return "m_InternalName: string expected";
                if (message.m_Comment != null && message.hasOwnProperty("m_Comment"))
                    if (!$util.isString(message.m_Comment))
                        return "m_Comment: string expected";
                return null;
            };
    
            /**
             * Creates a NetworkLayerDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.NetworkLayerDescription} NetworkLayerDescription
             */
            NetworkLayerDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.NetworkLayerDescription)
                    return object;
                var message = new $root.CS.NetworkLayerDescription();
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                if (object.m_InternalName != null)
                    message.m_InternalName = String(object.m_InternalName);
                if (object.m_Comment != null)
                    message.m_Comment = String(object.m_Comment);
                return message;
            };
    
            /**
             * Creates a plain object from a NetworkLayerDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.NetworkLayerDescription
             * @static
             * @param {CS.NetworkLayerDescription} message NetworkLayerDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NetworkLayerDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Name = "";
                    object.m_InternalName = "";
                    object.m_Comment = "";
                }
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_InternalName != null && message.hasOwnProperty("m_InternalName"))
                    object.m_InternalName = message.m_InternalName;
                if (message.m_Comment != null && message.hasOwnProperty("m_Comment"))
                    object.m_Comment = message.m_Comment;
                return object;
            };
    
            /**
             * Converts this NetworkLayerDescription to JSON.
             * @function toJSON
             * @memberof CS.NetworkLayerDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NetworkLayerDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NetworkLayerDescription;
        })();
    
        CS.NetworkLayerObject = (function() {
    
            /**
             * Properties of a NetworkLayerObject.
             * @memberof CS
             * @interface INetworkLayerObject
             * @property {string|null} [m_Name] NetworkLayerObject m_Name
             * @property {string|null} [m_HostName] NetworkLayerObject m_HostName
             * @property {number|Long|null} [m_ProcessID] NetworkLayerObject m_ProcessID
             */
    
            /**
             * Constructs a new NetworkLayerObject.
             * @memberof CS
             * @classdesc Represents a NetworkLayerObject.
             * @implements INetworkLayerObject
             * @constructor
             * @param {CS.INetworkLayerObject=} [properties] Properties to set
             */
            function NetworkLayerObject(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NetworkLayerObject m_Name.
             * @member {string} m_Name
             * @memberof CS.NetworkLayerObject
             * @instance
             */
            NetworkLayerObject.prototype.m_Name = "";
    
            /**
             * NetworkLayerObject m_HostName.
             * @member {string} m_HostName
             * @memberof CS.NetworkLayerObject
             * @instance
             */
            NetworkLayerObject.prototype.m_HostName = "";
    
            /**
             * NetworkLayerObject m_ProcessID.
             * @member {number|Long} m_ProcessID
             * @memberof CS.NetworkLayerObject
             * @instance
             */
            NetworkLayerObject.prototype.m_ProcessID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new NetworkLayerObject instance using the specified properties.
             * @function create
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {CS.INetworkLayerObject=} [properties] Properties to set
             * @returns {CS.NetworkLayerObject} NetworkLayerObject instance
             */
            NetworkLayerObject.create = function create(properties) {
                return new NetworkLayerObject(properties);
            };
    
            /**
             * Encodes the specified NetworkLayerObject message. Does not implicitly {@link CS.NetworkLayerObject.verify|verify} messages.
             * @function encode
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {CS.INetworkLayerObject} message NetworkLayerObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkLayerObject.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Name);
                if (message.m_HostName != null && Object.hasOwnProperty.call(message, "m_HostName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_HostName);
                if (message.m_ProcessID != null && Object.hasOwnProperty.call(message, "m_ProcessID"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.m_ProcessID);
                return writer;
            };
    
            /**
             * Encodes the specified NetworkLayerObject message, length delimited. Does not implicitly {@link CS.NetworkLayerObject.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {CS.INetworkLayerObject} message NetworkLayerObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkLayerObject.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NetworkLayerObject message from the specified reader or buffer.
             * @function decode
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.NetworkLayerObject} NetworkLayerObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkLayerObject.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.NetworkLayerObject();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Name = reader.string();
                        break;
                    case 2:
                        message.m_HostName = reader.string();
                        break;
                    case 3:
                        message.m_ProcessID = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NetworkLayerObject message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.NetworkLayerObject} NetworkLayerObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkLayerObject.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NetworkLayerObject message.
             * @function verify
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NetworkLayerObject.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_HostName != null && message.hasOwnProperty("m_HostName"))
                    if (!$util.isString(message.m_HostName))
                        return "m_HostName: string expected";
                if (message.m_ProcessID != null && message.hasOwnProperty("m_ProcessID"))
                    if (!$util.isInteger(message.m_ProcessID) && !(message.m_ProcessID && $util.isInteger(message.m_ProcessID.low) && $util.isInteger(message.m_ProcessID.high)))
                        return "m_ProcessID: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a NetworkLayerObject message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.NetworkLayerObject} NetworkLayerObject
             */
            NetworkLayerObject.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.NetworkLayerObject)
                    return object;
                var message = new $root.CS.NetworkLayerObject();
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                if (object.m_HostName != null)
                    message.m_HostName = String(object.m_HostName);
                if (object.m_ProcessID != null)
                    if ($util.Long)
                        (message.m_ProcessID = $util.Long.fromValue(object.m_ProcessID)).unsigned = true;
                    else if (typeof object.m_ProcessID === "string")
                        message.m_ProcessID = parseInt(object.m_ProcessID, 10);
                    else if (typeof object.m_ProcessID === "number")
                        message.m_ProcessID = object.m_ProcessID;
                    else if (typeof object.m_ProcessID === "object")
                        message.m_ProcessID = new $util.LongBits(object.m_ProcessID.low >>> 0, object.m_ProcessID.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a NetworkLayerObject message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.NetworkLayerObject
             * @static
             * @param {CS.NetworkLayerObject} message NetworkLayerObject
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NetworkLayerObject.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Name = "";
                    object.m_HostName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.m_ProcessID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.m_ProcessID = options.longs === String ? "0" : 0;
                }
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_HostName != null && message.hasOwnProperty("m_HostName"))
                    object.m_HostName = message.m_HostName;
                if (message.m_ProcessID != null && message.hasOwnProperty("m_ProcessID"))
                    if (typeof message.m_ProcessID === "number")
                        object.m_ProcessID = options.longs === String ? String(message.m_ProcessID) : message.m_ProcessID;
                    else
                        object.m_ProcessID = options.longs === String ? $util.Long.prototype.toString.call(message.m_ProcessID) : options.longs === Number ? new $util.LongBits(message.m_ProcessID.low >>> 0, message.m_ProcessID.high >>> 0).toNumber(true) : message.m_ProcessID;
                return object;
            };
    
            /**
             * Converts this NetworkLayerObject to JSON.
             * @function toJSON
             * @memberof CS.NetworkLayerObject
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NetworkLayerObject.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NetworkLayerObject;
        })();
    
        CS.DataBaseDescription = (function() {
    
            /**
             * Properties of a DataBaseDescription.
             * @memberof CS
             * @interface IDataBaseDescription
             * @property {string|null} [m_Name] DataBaseDescription m_Name
             * @property {string|null} [m_Family] DataBaseDescription m_Family
             * @property {Array.<CS.SupportLevel>|null} [m_SupportLevel] DataBaseDescription m_SupportLevel
             * @property {Array.<string>|null} [m_Aliases] DataBaseDescription m_Aliases
             */
    
            /**
             * Constructs a new DataBaseDescription.
             * @memberof CS
             * @classdesc Represents a DataBaseDescription.
             * @implements IDataBaseDescription
             * @constructor
             * @param {CS.IDataBaseDescription=} [properties] Properties to set
             */
            function DataBaseDescription(properties) {
                this.m_SupportLevel = [];
                this.m_Aliases = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataBaseDescription m_Name.
             * @member {string} m_Name
             * @memberof CS.DataBaseDescription
             * @instance
             */
            DataBaseDescription.prototype.m_Name = "";
    
            /**
             * DataBaseDescription m_Family.
             * @member {string} m_Family
             * @memberof CS.DataBaseDescription
             * @instance
             */
            DataBaseDescription.prototype.m_Family = "";
    
            /**
             * DataBaseDescription m_SupportLevel.
             * @member {Array.<CS.SupportLevel>} m_SupportLevel
             * @memberof CS.DataBaseDescription
             * @instance
             */
            DataBaseDescription.prototype.m_SupportLevel = $util.emptyArray;
    
            /**
             * DataBaseDescription m_Aliases.
             * @member {Array.<string>} m_Aliases
             * @memberof CS.DataBaseDescription
             * @instance
             */
            DataBaseDescription.prototype.m_Aliases = $util.emptyArray;
    
            /**
             * Creates a new DataBaseDescription instance using the specified properties.
             * @function create
             * @memberof CS.DataBaseDescription
             * @static
             * @param {CS.IDataBaseDescription=} [properties] Properties to set
             * @returns {CS.DataBaseDescription} DataBaseDescription instance
             */
            DataBaseDescription.create = function create(properties) {
                return new DataBaseDescription(properties);
            };
    
            /**
             * Encodes the specified DataBaseDescription message. Does not implicitly {@link CS.DataBaseDescription.verify|verify} messages.
             * @function encode
             * @memberof CS.DataBaseDescription
             * @static
             * @param {CS.IDataBaseDescription} message DataBaseDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataBaseDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Name);
                if (message.m_Family != null && Object.hasOwnProperty.call(message, "m_Family"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Family);
                if (message.m_SupportLevel != null && message.m_SupportLevel.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.m_SupportLevel.length; ++i)
                        writer.int32(message.m_SupportLevel[i]);
                    writer.ldelim();
                }
                if (message.m_Aliases != null && message.m_Aliases.length)
                    for (var i = 0; i < message.m_Aliases.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_Aliases[i]);
                return writer;
            };
    
            /**
             * Encodes the specified DataBaseDescription message, length delimited. Does not implicitly {@link CS.DataBaseDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.DataBaseDescription
             * @static
             * @param {CS.IDataBaseDescription} message DataBaseDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataBaseDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataBaseDescription message from the specified reader or buffer.
             * @function decode
             * @memberof CS.DataBaseDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.DataBaseDescription} DataBaseDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataBaseDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.DataBaseDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Name = reader.string();
                        break;
                    case 2:
                        message.m_Family = reader.string();
                        break;
                    case 3:
                        if (!(message.m_SupportLevel && message.m_SupportLevel.length))
                            message.m_SupportLevel = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.m_SupportLevel.push(reader.int32());
                        } else
                            message.m_SupportLevel.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.m_Aliases && message.m_Aliases.length))
                            message.m_Aliases = [];
                        message.m_Aliases.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataBaseDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.DataBaseDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.DataBaseDescription} DataBaseDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataBaseDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataBaseDescription message.
             * @function verify
             * @memberof CS.DataBaseDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataBaseDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_Family != null && message.hasOwnProperty("m_Family"))
                    if (!$util.isString(message.m_Family))
                        return "m_Family: string expected";
                if (message.m_SupportLevel != null && message.hasOwnProperty("m_SupportLevel")) {
                    if (!Array.isArray(message.m_SupportLevel))
                        return "m_SupportLevel: array expected";
                    for (var i = 0; i < message.m_SupportLevel.length; ++i)
                        switch (message.m_SupportLevel[i]) {
                        default:
                            return "m_SupportLevel: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                }
                if (message.m_Aliases != null && message.hasOwnProperty("m_Aliases")) {
                    if (!Array.isArray(message.m_Aliases))
                        return "m_Aliases: array expected";
                    for (var i = 0; i < message.m_Aliases.length; ++i)
                        if (!$util.isString(message.m_Aliases[i]))
                            return "m_Aliases: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a DataBaseDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.DataBaseDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.DataBaseDescription} DataBaseDescription
             */
            DataBaseDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.DataBaseDescription)
                    return object;
                var message = new $root.CS.DataBaseDescription();
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                if (object.m_Family != null)
                    message.m_Family = String(object.m_Family);
                if (object.m_SupportLevel) {
                    if (!Array.isArray(object.m_SupportLevel))
                        throw TypeError(".CS.DataBaseDescription.m_SupportLevel: array expected");
                    message.m_SupportLevel = [];
                    for (var i = 0; i < object.m_SupportLevel.length; ++i)
                        switch (object.m_SupportLevel[i]) {
                        default:
                        case "Unknown_SupportLevel":
                        case 0:
                            message.m_SupportLevel[i] = 0;
                            break;
                        case "Query":
                        case 1:
                            message.m_SupportLevel[i] = 1;
                            break;
                        case "Repository":
                        case 2:
                            message.m_SupportLevel[i] = 2;
                            break;
                        case "StoredProcedure":
                        case 3:
                            message.m_SupportLevel[i] = 3;
                            break;
                        case "Cancel":
                        case 4:
                            message.m_SupportLevel[i] = 4;
                            break;
                        }
                }
                if (object.m_Aliases) {
                    if (!Array.isArray(object.m_Aliases))
                        throw TypeError(".CS.DataBaseDescription.m_Aliases: array expected");
                    message.m_Aliases = [];
                    for (var i = 0; i < object.m_Aliases.length; ++i)
                        message.m_Aliases[i] = String(object.m_Aliases[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataBaseDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.DataBaseDescription
             * @static
             * @param {CS.DataBaseDescription} message DataBaseDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataBaseDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.m_SupportLevel = [];
                    object.m_Aliases = [];
                }
                if (options.defaults) {
                    object.m_Name = "";
                    object.m_Family = "";
                }
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_Family != null && message.hasOwnProperty("m_Family"))
                    object.m_Family = message.m_Family;
                if (message.m_SupportLevel && message.m_SupportLevel.length) {
                    object.m_SupportLevel = [];
                    for (var j = 0; j < message.m_SupportLevel.length; ++j)
                        object.m_SupportLevel[j] = options.enums === String ? $root.CS.SupportLevel[message.m_SupportLevel[j]] : message.m_SupportLevel[j];
                }
                if (message.m_Aliases && message.m_Aliases.length) {
                    object.m_Aliases = [];
                    for (var j = 0; j < message.m_Aliases.length; ++j)
                        object.m_Aliases[j] = message.m_Aliases[j];
                }
                return object;
            };
    
            /**
             * Converts this DataBaseDescription to JSON.
             * @function toJSON
             * @memberof CS.DataBaseDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataBaseDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataBaseDescription;
        })();
    
        CS.Alias = (function() {
    
            /**
             * Properties of an Alias.
             * @memberof CS
             * @interface IAlias
             * @property {string|null} [m_Key] Alias m_Key
             * @property {Array.<string>|null} [m_Aliases] Alias m_Aliases
             */
    
            /**
             * Constructs a new Alias.
             * @memberof CS
             * @classdesc Represents an Alias.
             * @implements IAlias
             * @constructor
             * @param {CS.IAlias=} [properties] Properties to set
             */
            function Alias(properties) {
                this.m_Aliases = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Alias m_Key.
             * @member {string} m_Key
             * @memberof CS.Alias
             * @instance
             */
            Alias.prototype.m_Key = "";
    
            /**
             * Alias m_Aliases.
             * @member {Array.<string>} m_Aliases
             * @memberof CS.Alias
             * @instance
             */
            Alias.prototype.m_Aliases = $util.emptyArray;
    
            /**
             * Creates a new Alias instance using the specified properties.
             * @function create
             * @memberof CS.Alias
             * @static
             * @param {CS.IAlias=} [properties] Properties to set
             * @returns {CS.Alias} Alias instance
             */
            Alias.create = function create(properties) {
                return new Alias(properties);
            };
    
            /**
             * Encodes the specified Alias message. Does not implicitly {@link CS.Alias.verify|verify} messages.
             * @function encode
             * @memberof CS.Alias
             * @static
             * @param {CS.IAlias} message Alias message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Alias.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Key != null && Object.hasOwnProperty.call(message, "m_Key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Key);
                if (message.m_Aliases != null && message.m_Aliases.length)
                    for (var i = 0; i < message.m_Aliases.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Aliases[i]);
                return writer;
            };
    
            /**
             * Encodes the specified Alias message, length delimited. Does not implicitly {@link CS.Alias.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Alias
             * @static
             * @param {CS.IAlias} message Alias message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Alias.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Alias message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Alias
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Alias} Alias
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Alias.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Alias();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Key = reader.string();
                        break;
                    case 2:
                        if (!(message.m_Aliases && message.m_Aliases.length))
                            message.m_Aliases = [];
                        message.m_Aliases.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Alias message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Alias
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Alias} Alias
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Alias.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Alias message.
             * @function verify
             * @memberof CS.Alias
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Alias.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Key != null && message.hasOwnProperty("m_Key"))
                    if (!$util.isString(message.m_Key))
                        return "m_Key: string expected";
                if (message.m_Aliases != null && message.hasOwnProperty("m_Aliases")) {
                    if (!Array.isArray(message.m_Aliases))
                        return "m_Aliases: array expected";
                    for (var i = 0; i < message.m_Aliases.length; ++i)
                        if (!$util.isString(message.m_Aliases[i]))
                            return "m_Aliases: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates an Alias message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Alias
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Alias} Alias
             */
            Alias.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Alias)
                    return object;
                var message = new $root.CS.Alias();
                if (object.m_Key != null)
                    message.m_Key = String(object.m_Key);
                if (object.m_Aliases) {
                    if (!Array.isArray(object.m_Aliases))
                        throw TypeError(".CS.Alias.m_Aliases: array expected");
                    message.m_Aliases = [];
                    for (var i = 0; i < object.m_Aliases.length; ++i)
                        message.m_Aliases[i] = String(object.m_Aliases[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Alias message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Alias
             * @static
             * @param {CS.Alias} message Alias
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Alias.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.m_Aliases = [];
                if (options.defaults)
                    object.m_Key = "";
                if (message.m_Key != null && message.hasOwnProperty("m_Key"))
                    object.m_Key = message.m_Key;
                if (message.m_Aliases && message.m_Aliases.length) {
                    object.m_Aliases = [];
                    for (var j = 0; j < message.m_Aliases.length; ++j)
                        object.m_Aliases[j] = message.m_Aliases[j];
                }
                return object;
            };
    
            /**
             * Converts this Alias to JSON.
             * @function toJSON
             * @memberof CS.Alias
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Alias.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Alias;
        })();
    
        CS.DataSourceConfig = (function() {
    
            /**
             * Properties of a DataSourceConfig.
             * @memberof CS
             * @interface IDataSourceConfig
             * @property {Array.<CS.IAlias>|null} [m_NetworkLayerAliases] DataSourceConfig m_NetworkLayerAliases
             * @property {Array.<string>|null} [m_NativeNetworkLayers] DataSourceConfig m_NativeNetworkLayers
             * @property {Array.<string>|null} [m_JavaNetworkLayers] DataSourceConfig m_JavaNetworkLayers
             */
    
            /**
             * Constructs a new DataSourceConfig.
             * @memberof CS
             * @classdesc Represents a DataSourceConfig.
             * @implements IDataSourceConfig
             * @constructor
             * @param {CS.IDataSourceConfig=} [properties] Properties to set
             */
            function DataSourceConfig(properties) {
                this.m_NetworkLayerAliases = [];
                this.m_NativeNetworkLayers = [];
                this.m_JavaNetworkLayers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataSourceConfig m_NetworkLayerAliases.
             * @member {Array.<CS.IAlias>} m_NetworkLayerAliases
             * @memberof CS.DataSourceConfig
             * @instance
             */
            DataSourceConfig.prototype.m_NetworkLayerAliases = $util.emptyArray;
    
            /**
             * DataSourceConfig m_NativeNetworkLayers.
             * @member {Array.<string>} m_NativeNetworkLayers
             * @memberof CS.DataSourceConfig
             * @instance
             */
            DataSourceConfig.prototype.m_NativeNetworkLayers = $util.emptyArray;
    
            /**
             * DataSourceConfig m_JavaNetworkLayers.
             * @member {Array.<string>} m_JavaNetworkLayers
             * @memberof CS.DataSourceConfig
             * @instance
             */
            DataSourceConfig.prototype.m_JavaNetworkLayers = $util.emptyArray;
    
            /**
             * Creates a new DataSourceConfig instance using the specified properties.
             * @function create
             * @memberof CS.DataSourceConfig
             * @static
             * @param {CS.IDataSourceConfig=} [properties] Properties to set
             * @returns {CS.DataSourceConfig} DataSourceConfig instance
             */
            DataSourceConfig.create = function create(properties) {
                return new DataSourceConfig(properties);
            };
    
            /**
             * Encodes the specified DataSourceConfig message. Does not implicitly {@link CS.DataSourceConfig.verify|verify} messages.
             * @function encode
             * @memberof CS.DataSourceConfig
             * @static
             * @param {CS.IDataSourceConfig} message DataSourceConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataSourceConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_NetworkLayerAliases != null && message.m_NetworkLayerAliases.length)
                    for (var i = 0; i < message.m_NetworkLayerAliases.length; ++i)
                        $root.CS.Alias.encode(message.m_NetworkLayerAliases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_NativeNetworkLayers != null && message.m_NativeNetworkLayers.length)
                    for (var i = 0; i < message.m_NativeNetworkLayers.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_NativeNetworkLayers[i]);
                if (message.m_JavaNetworkLayers != null && message.m_JavaNetworkLayers.length)
                    for (var i = 0; i < message.m_JavaNetworkLayers.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_JavaNetworkLayers[i]);
                return writer;
            };
    
            /**
             * Encodes the specified DataSourceConfig message, length delimited. Does not implicitly {@link CS.DataSourceConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.DataSourceConfig
             * @static
             * @param {CS.IDataSourceConfig} message DataSourceConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataSourceConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataSourceConfig message from the specified reader or buffer.
             * @function decode
             * @memberof CS.DataSourceConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.DataSourceConfig} DataSourceConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataSourceConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.DataSourceConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.m_NetworkLayerAliases && message.m_NetworkLayerAliases.length))
                            message.m_NetworkLayerAliases = [];
                        message.m_NetworkLayerAliases.push($root.CS.Alias.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.m_NativeNetworkLayers && message.m_NativeNetworkLayers.length))
                            message.m_NativeNetworkLayers = [];
                        message.m_NativeNetworkLayers.push(reader.string());
                        break;
                    case 3:
                        if (!(message.m_JavaNetworkLayers && message.m_JavaNetworkLayers.length))
                            message.m_JavaNetworkLayers = [];
                        message.m_JavaNetworkLayers.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataSourceConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.DataSourceConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.DataSourceConfig} DataSourceConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataSourceConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataSourceConfig message.
             * @function verify
             * @memberof CS.DataSourceConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataSourceConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_NetworkLayerAliases != null && message.hasOwnProperty("m_NetworkLayerAliases")) {
                    if (!Array.isArray(message.m_NetworkLayerAliases))
                        return "m_NetworkLayerAliases: array expected";
                    for (var i = 0; i < message.m_NetworkLayerAliases.length; ++i) {
                        var error = $root.CS.Alias.verify(message.m_NetworkLayerAliases[i]);
                        if (error)
                            return "m_NetworkLayerAliases." + error;
                    }
                }
                if (message.m_NativeNetworkLayers != null && message.hasOwnProperty("m_NativeNetworkLayers")) {
                    if (!Array.isArray(message.m_NativeNetworkLayers))
                        return "m_NativeNetworkLayers: array expected";
                    for (var i = 0; i < message.m_NativeNetworkLayers.length; ++i)
                        if (!$util.isString(message.m_NativeNetworkLayers[i]))
                            return "m_NativeNetworkLayers: string[] expected";
                }
                if (message.m_JavaNetworkLayers != null && message.hasOwnProperty("m_JavaNetworkLayers")) {
                    if (!Array.isArray(message.m_JavaNetworkLayers))
                        return "m_JavaNetworkLayers: array expected";
                    for (var i = 0; i < message.m_JavaNetworkLayers.length; ++i)
                        if (!$util.isString(message.m_JavaNetworkLayers[i]))
                            return "m_JavaNetworkLayers: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a DataSourceConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.DataSourceConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.DataSourceConfig} DataSourceConfig
             */
            DataSourceConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.DataSourceConfig)
                    return object;
                var message = new $root.CS.DataSourceConfig();
                if (object.m_NetworkLayerAliases) {
                    if (!Array.isArray(object.m_NetworkLayerAliases))
                        throw TypeError(".CS.DataSourceConfig.m_NetworkLayerAliases: array expected");
                    message.m_NetworkLayerAliases = [];
                    for (var i = 0; i < object.m_NetworkLayerAliases.length; ++i) {
                        if (typeof object.m_NetworkLayerAliases[i] !== "object")
                            throw TypeError(".CS.DataSourceConfig.m_NetworkLayerAliases: object expected");
                        message.m_NetworkLayerAliases[i] = $root.CS.Alias.fromObject(object.m_NetworkLayerAliases[i]);
                    }
                }
                if (object.m_NativeNetworkLayers) {
                    if (!Array.isArray(object.m_NativeNetworkLayers))
                        throw TypeError(".CS.DataSourceConfig.m_NativeNetworkLayers: array expected");
                    message.m_NativeNetworkLayers = [];
                    for (var i = 0; i < object.m_NativeNetworkLayers.length; ++i)
                        message.m_NativeNetworkLayers[i] = String(object.m_NativeNetworkLayers[i]);
                }
                if (object.m_JavaNetworkLayers) {
                    if (!Array.isArray(object.m_JavaNetworkLayers))
                        throw TypeError(".CS.DataSourceConfig.m_JavaNetworkLayers: array expected");
                    message.m_JavaNetworkLayers = [];
                    for (var i = 0; i < object.m_JavaNetworkLayers.length; ++i)
                        message.m_JavaNetworkLayers[i] = String(object.m_JavaNetworkLayers[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataSourceConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.DataSourceConfig
             * @static
             * @param {CS.DataSourceConfig} message DataSourceConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataSourceConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.m_NetworkLayerAliases = [];
                    object.m_NativeNetworkLayers = [];
                    object.m_JavaNetworkLayers = [];
                }
                if (message.m_NetworkLayerAliases && message.m_NetworkLayerAliases.length) {
                    object.m_NetworkLayerAliases = [];
                    for (var j = 0; j < message.m_NetworkLayerAliases.length; ++j)
                        object.m_NetworkLayerAliases[j] = $root.CS.Alias.toObject(message.m_NetworkLayerAliases[j], options);
                }
                if (message.m_NativeNetworkLayers && message.m_NativeNetworkLayers.length) {
                    object.m_NativeNetworkLayers = [];
                    for (var j = 0; j < message.m_NativeNetworkLayers.length; ++j)
                        object.m_NativeNetworkLayers[j] = message.m_NativeNetworkLayers[j];
                }
                if (message.m_JavaNetworkLayers && message.m_JavaNetworkLayers.length) {
                    object.m_JavaNetworkLayers = [];
                    for (var j = 0; j < message.m_JavaNetworkLayers.length; ++j)
                        object.m_JavaNetworkLayers[j] = message.m_JavaNetworkLayers[j];
                }
                return object;
            };
    
            /**
             * Converts this DataSourceConfig to JSON.
             * @function toJSON
             * @memberof CS.DataSourceConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataSourceConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataSourceConfig;
        })();
    
        CS.Time = (function() {
    
            /**
             * Properties of a Time.
             * @memberof CS
             * @interface ITime
             * @property {number|null} [hour] Time hour
             * @property {number|null} [minute] Time minute
             * @property {number|null} [second] Time second
             * @property {number|null} [nanosecond] Time nanosecond
             */
    
            /**
             * Constructs a new Time.
             * @memberof CS
             * @classdesc Represents a Time.
             * @implements ITime
             * @constructor
             * @param {CS.ITime=} [properties] Properties to set
             */
            function Time(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Time hour.
             * @member {number} hour
             * @memberof CS.Time
             * @instance
             */
            Time.prototype.hour = 0;
    
            /**
             * Time minute.
             * @member {number} minute
             * @memberof CS.Time
             * @instance
             */
            Time.prototype.minute = 0;
    
            /**
             * Time second.
             * @member {number} second
             * @memberof CS.Time
             * @instance
             */
            Time.prototype.second = 0;
    
            /**
             * Time nanosecond.
             * @member {number} nanosecond
             * @memberof CS.Time
             * @instance
             */
            Time.prototype.nanosecond = 0;
    
            /**
             * Creates a new Time instance using the specified properties.
             * @function create
             * @memberof CS.Time
             * @static
             * @param {CS.ITime=} [properties] Properties to set
             * @returns {CS.Time} Time instance
             */
            Time.create = function create(properties) {
                return new Time(properties);
            };
    
            /**
             * Encodes the specified Time message. Does not implicitly {@link CS.Time.verify|verify} messages.
             * @function encode
             * @memberof CS.Time
             * @static
             * @param {CS.ITime} message Time message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Time.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.hour);
                if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.minute);
                if (message.second != null && Object.hasOwnProperty.call(message, "second"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.second);
                if (message.nanosecond != null && Object.hasOwnProperty.call(message, "nanosecond"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.nanosecond);
                return writer;
            };
    
            /**
             * Encodes the specified Time message, length delimited. Does not implicitly {@link CS.Time.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Time
             * @static
             * @param {CS.ITime} message Time message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Time.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Time message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Time
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Time} Time
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Time.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Time();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hour = reader.uint32();
                        break;
                    case 2:
                        message.minute = reader.uint32();
                        break;
                    case 3:
                        message.second = reader.uint32();
                        break;
                    case 4:
                        message.nanosecond = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Time message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Time
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Time} Time
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Time.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Time message.
             * @function verify
             * @memberof CS.Time
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Time.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hour != null && message.hasOwnProperty("hour"))
                    if (!$util.isInteger(message.hour))
                        return "hour: integer expected";
                if (message.minute != null && message.hasOwnProperty("minute"))
                    if (!$util.isInteger(message.minute))
                        return "minute: integer expected";
                if (message.second != null && message.hasOwnProperty("second"))
                    if (!$util.isInteger(message.second))
                        return "second: integer expected";
                if (message.nanosecond != null && message.hasOwnProperty("nanosecond"))
                    if (!$util.isInteger(message.nanosecond))
                        return "nanosecond: integer expected";
                return null;
            };
    
            /**
             * Creates a Time message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Time
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Time} Time
             */
            Time.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Time)
                    return object;
                var message = new $root.CS.Time();
                if (object.hour != null)
                    message.hour = object.hour >>> 0;
                if (object.minute != null)
                    message.minute = object.minute >>> 0;
                if (object.second != null)
                    message.second = object.second >>> 0;
                if (object.nanosecond != null)
                    message.nanosecond = object.nanosecond >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Time message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Time
             * @static
             * @param {CS.Time} message Time
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Time.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.hour = 0;
                    object.minute = 0;
                    object.second = 0;
                    object.nanosecond = 0;
                }
                if (message.hour != null && message.hasOwnProperty("hour"))
                    object.hour = message.hour;
                if (message.minute != null && message.hasOwnProperty("minute"))
                    object.minute = message.minute;
                if (message.second != null && message.hasOwnProperty("second"))
                    object.second = message.second;
                if (message.nanosecond != null && message.hasOwnProperty("nanosecond"))
                    object.nanosecond = message.nanosecond;
                return object;
            };
    
            /**
             * Converts this Time to JSON.
             * @function toJSON
             * @memberof CS.Time
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Time.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Time;
        })();
    
        CS.Date = (function() {
    
            /**
             * Properties of a Date.
             * @memberof CS
             * @interface IDate
             * @property {number|null} [year] Date year
             * @property {number|null} [month] Date month
             * @property {number|null} [day] Date day
             */
    
            /**
             * Constructs a new Date.
             * @memberof CS
             * @classdesc Represents a Date.
             * @implements IDate
             * @constructor
             * @param {CS.IDate=} [properties] Properties to set
             */
            function Date(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Date year.
             * @member {number} year
             * @memberof CS.Date
             * @instance
             */
            Date.prototype.year = 0;
    
            /**
             * Date month.
             * @member {number} month
             * @memberof CS.Date
             * @instance
             */
            Date.prototype.month = 0;
    
            /**
             * Date day.
             * @member {number} day
             * @memberof CS.Date
             * @instance
             */
            Date.prototype.day = 0;
    
            /**
             * Creates a new Date instance using the specified properties.
             * @function create
             * @memberof CS.Date
             * @static
             * @param {CS.IDate=} [properties] Properties to set
             * @returns {CS.Date} Date instance
             */
            Date.create = function create(properties) {
                return new Date(properties);
            };
    
            /**
             * Encodes the specified Date message. Does not implicitly {@link CS.Date.verify|verify} messages.
             * @function encode
             * @memberof CS.Date
             * @static
             * @param {CS.IDate} message Date message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Date.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.year != null && Object.hasOwnProperty.call(message, "year"))
                    writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.year);
                if (message.month != null && Object.hasOwnProperty.call(message, "month"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.month);
                if (message.day != null && Object.hasOwnProperty.call(message, "day"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.day);
                return writer;
            };
    
            /**
             * Encodes the specified Date message, length delimited. Does not implicitly {@link CS.Date.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Date
             * @static
             * @param {CS.IDate} message Date message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Date.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Date message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Date
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Date} Date
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Date.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Date();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.year = reader.sint32();
                        break;
                    case 2:
                        message.month = reader.uint32();
                        break;
                    case 3:
                        message.day = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Date message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Date
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Date} Date
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Date.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Date message.
             * @function verify
             * @memberof CS.Date
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Date.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.year != null && message.hasOwnProperty("year"))
                    if (!$util.isInteger(message.year))
                        return "year: integer expected";
                if (message.month != null && message.hasOwnProperty("month"))
                    if (!$util.isInteger(message.month))
                        return "month: integer expected";
                if (message.day != null && message.hasOwnProperty("day"))
                    if (!$util.isInteger(message.day))
                        return "day: integer expected";
                return null;
            };
    
            /**
             * Creates a Date message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Date
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Date} Date
             */
            Date.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Date)
                    return object;
                var message = new $root.CS.Date();
                if (object.year != null)
                    message.year = object.year | 0;
                if (object.month != null)
                    message.month = object.month >>> 0;
                if (object.day != null)
                    message.day = object.day >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Date message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Date
             * @static
             * @param {CS.Date} message Date
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Date.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.year = 0;
                    object.month = 0;
                    object.day = 0;
                }
                if (message.year != null && message.hasOwnProperty("year"))
                    object.year = message.year;
                if (message.month != null && message.hasOwnProperty("month"))
                    object.month = message.month;
                if (message.day != null && message.hasOwnProperty("day"))
                    object.day = message.day;
                return object;
            };
    
            /**
             * Converts this Date to JSON.
             * @function toJSON
             * @memberof CS.Date
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Date.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Date;
        })();
    
        CS.TimeStamp = (function() {
    
            /**
             * Properties of a TimeStamp.
             * @memberof CS
             * @interface ITimeStamp
             * @property {CS.IDate|null} [m_Date] TimeStamp m_Date
             * @property {CS.ITime|null} [m_Time] TimeStamp m_Time
             */
    
            /**
             * Constructs a new TimeStamp.
             * @memberof CS
             * @classdesc Represents a TimeStamp.
             * @implements ITimeStamp
             * @constructor
             * @param {CS.ITimeStamp=} [properties] Properties to set
             */
            function TimeStamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TimeStamp m_Date.
             * @member {CS.IDate|null|undefined} m_Date
             * @memberof CS.TimeStamp
             * @instance
             */
            TimeStamp.prototype.m_Date = null;
    
            /**
             * TimeStamp m_Time.
             * @member {CS.ITime|null|undefined} m_Time
             * @memberof CS.TimeStamp
             * @instance
             */
            TimeStamp.prototype.m_Time = null;
    
            /**
             * Creates a new TimeStamp instance using the specified properties.
             * @function create
             * @memberof CS.TimeStamp
             * @static
             * @param {CS.ITimeStamp=} [properties] Properties to set
             * @returns {CS.TimeStamp} TimeStamp instance
             */
            TimeStamp.create = function create(properties) {
                return new TimeStamp(properties);
            };
    
            /**
             * Encodes the specified TimeStamp message. Does not implicitly {@link CS.TimeStamp.verify|verify} messages.
             * @function encode
             * @memberof CS.TimeStamp
             * @static
             * @param {CS.ITimeStamp} message TimeStamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeStamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Date != null && Object.hasOwnProperty.call(message, "m_Date"))
                    $root.CS.Date.encode(message.m_Date, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_Time != null && Object.hasOwnProperty.call(message, "m_Time"))
                    $root.CS.Time.encode(message.m_Time, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TimeStamp message, length delimited. Does not implicitly {@link CS.TimeStamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.TimeStamp
             * @static
             * @param {CS.ITimeStamp} message TimeStamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeStamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TimeStamp message from the specified reader or buffer.
             * @function decode
             * @memberof CS.TimeStamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.TimeStamp} TimeStamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeStamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.TimeStamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Date = $root.CS.Date.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.m_Time = $root.CS.Time.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TimeStamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.TimeStamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.TimeStamp} TimeStamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeStamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TimeStamp message.
             * @function verify
             * @memberof CS.TimeStamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimeStamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Date != null && message.hasOwnProperty("m_Date")) {
                    var error = $root.CS.Date.verify(message.m_Date);
                    if (error)
                        return "m_Date." + error;
                }
                if (message.m_Time != null && message.hasOwnProperty("m_Time")) {
                    var error = $root.CS.Time.verify(message.m_Time);
                    if (error)
                        return "m_Time." + error;
                }
                return null;
            };
    
            /**
             * Creates a TimeStamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.TimeStamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.TimeStamp} TimeStamp
             */
            TimeStamp.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.TimeStamp)
                    return object;
                var message = new $root.CS.TimeStamp();
                if (object.m_Date != null) {
                    if (typeof object.m_Date !== "object")
                        throw TypeError(".CS.TimeStamp.m_Date: object expected");
                    message.m_Date = $root.CS.Date.fromObject(object.m_Date);
                }
                if (object.m_Time != null) {
                    if (typeof object.m_Time !== "object")
                        throw TypeError(".CS.TimeStamp.m_Time: object expected");
                    message.m_Time = $root.CS.Time.fromObject(object.m_Time);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TimeStamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.TimeStamp
             * @static
             * @param {CS.TimeStamp} message TimeStamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimeStamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Date = null;
                    object.m_Time = null;
                }
                if (message.m_Date != null && message.hasOwnProperty("m_Date"))
                    object.m_Date = $root.CS.Date.toObject(message.m_Date, options);
                if (message.m_Time != null && message.hasOwnProperty("m_Time"))
                    object.m_Time = $root.CS.Time.toObject(message.m_Time, options);
                return object;
            };
    
            /**
             * Converts this TimeStamp to JSON.
             * @function toJSON
             * @memberof CS.TimeStamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimeStamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TimeStamp;
        })();
    
        /**
         * Priority enum.
         * @name CS.Priority
         * @enum {number}
         * @property {number} Unknown_Priority=0 Unknown_Priority value
         * @property {number} Low=1 Low value
         * @property {number} Normal=2 Normal value
         * @property {number} High=3 High value
         */
        CS.Priority = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_Priority"] = 0;
            values[valuesById[1] = "Low"] = 1;
            values[valuesById[2] = "Normal"] = 2;
            values[valuesById[3] = "High"] = 3;
            return values;
        })();
    
        /**
         * Mode enum.
         * @name CS.Mode
         * @enum {number}
         * @property {number} Unknown_Mode=0 Unknown_Mode value
         * @property {number} InMode=1 InMode value
         * @property {number} OutMode=2 OutMode value
         * @property {number} InOutMode=3 InOutMode value
         */
        CS.Mode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_Mode"] = 0;
            values[valuesById[1] = "InMode"] = 1;
            values[valuesById[2] = "OutMode"] = 2;
            values[valuesById[3] = "InOutMode"] = 3;
            return values;
        })();
    
        /**
         * SQLType enum.
         * @name CS.SQLType
         * @enum {number}
         * @property {number} Unknown_SQLType=0 Unknown_SQLType value
         * @property {number} SQL_Default=1 SQL_Default value
         * @property {number} SQL_Char=2 SQL_Char value
         * @property {number} SQL_VarChar=3 SQL_VarChar value
         * @property {number} SQL_LongVarChar=4 SQL_LongVarChar value
         * @property {number} SQL_Xml=5 SQL_Xml value
         * @property {number} SQL_Binary=6 SQL_Binary value
         * @property {number} SQL_VarBinary=7 SQL_VarBinary value
         * @property {number} SQL_LongVarBinary=8 SQL_LongVarBinary value
         * @property {number} SQL_Bit=9 SQL_Bit value
         * @property {number} SQL_TinyInt=10 SQL_TinyInt value
         * @property {number} SQL_SmallInt=11 SQL_SmallInt value
         * @property {number} SQL_Integer=12 SQL_Integer value
         * @property {number} SQL_BigInt=13 SQL_BigInt value
         * @property {number} SQL_Decimal=14 SQL_Decimal value
         * @property {number} SQL_Numeric=15 SQL_Numeric value
         * @property {number} SQL_Real=16 SQL_Real value
         * @property {number} SQL_Float=17 SQL_Float value
         * @property {number} SQL_Double=18 SQL_Double value
         * @property {number} SQL_Time=19 SQL_Time value
         * @property {number} SQL_Date=20 SQL_Date value
         * @property {number} SQL_TimeStamp=21 SQL_TimeStamp value
         * @property {number} SQL_RefCursor=22 SQL_RefCursor value
         * @property {number} SQL_Extended=23 SQL_Extended value
         * @property {number} SQL_Unsupported=24 SQL_Unsupported value
         */
        CS.SQLType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_SQLType"] = 0;
            values[valuesById[1] = "SQL_Default"] = 1;
            values[valuesById[2] = "SQL_Char"] = 2;
            values[valuesById[3] = "SQL_VarChar"] = 3;
            values[valuesById[4] = "SQL_LongVarChar"] = 4;
            values[valuesById[5] = "SQL_Xml"] = 5;
            values[valuesById[6] = "SQL_Binary"] = 6;
            values[valuesById[7] = "SQL_VarBinary"] = 7;
            values[valuesById[8] = "SQL_LongVarBinary"] = 8;
            values[valuesById[9] = "SQL_Bit"] = 9;
            values[valuesById[10] = "SQL_TinyInt"] = 10;
            values[valuesById[11] = "SQL_SmallInt"] = 11;
            values[valuesById[12] = "SQL_Integer"] = 12;
            values[valuesById[13] = "SQL_BigInt"] = 13;
            values[valuesById[14] = "SQL_Decimal"] = 14;
            values[valuesById[15] = "SQL_Numeric"] = 15;
            values[valuesById[16] = "SQL_Real"] = 16;
            values[valuesById[17] = "SQL_Float"] = 17;
            values[valuesById[18] = "SQL_Double"] = 18;
            values[valuesById[19] = "SQL_Time"] = 19;
            values[valuesById[20] = "SQL_Date"] = 20;
            values[valuesById[21] = "SQL_TimeStamp"] = 21;
            values[valuesById[22] = "SQL_RefCursor"] = 22;
            values[valuesById[23] = "SQL_Extended"] = 23;
            values[valuesById[24] = "SQL_Unsupported"] = 24;
            return values;
        })();
    
        /**
         * CType enum.
         * @name CS.CType
         * @enum {number}
         * @property {number} Unknown_CType=0 Unknown_CType value
         * @property {number} C_Default=1 C_Default value
         * @property {number} C_Char=2 C_Char value
         * @property {number} C_String=3 C_String value
         * @property {number} C_UTF8Char=4 C_UTF8Char value
         * @property {number} C_UTF8String=5 C_UTF8String value
         * @property {number} C_UCS2Char=6 C_UCS2Char value
         * @property {number} C_UCS2String=7 C_UCS2String value
         * @property {number} C_Binary=8 C_Binary value
         * @property {number} C_UInt8=9 C_UInt8 value
         * @property {number} C_SInt8=10 C_SInt8 value
         * @property {number} C_UInt16=11 C_UInt16 value
         * @property {number} C_SInt16=12 C_SInt16 value
         * @property {number} C_UInt32=13 C_UInt32 value
         * @property {number} C_SInt32=14 C_SInt32 value
         * @property {number} C_UInt64=15 C_UInt64 value
         * @property {number} C_SInt64=16 C_SInt64 value
         * @property {number} C_Float32=17 C_Float32 value
         * @property {number} C_Float64=18 C_Float64 value
         * @property {number} C_CTime=19 C_CTime value
         * @property {number} C_CDate=20 C_CDate value
         * @property {number} C_CTimeStamp=21 C_CTimeStamp value
         * @property {number} C_RefCursor=22 C_RefCursor value
         * @property {number} C_Blob=23 C_Blob value
         * @property {number} C_Clob=24 C_Clob value
         * @property {number} C_Decimal=25 C_Decimal value
         */
        CS.CType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_CType"] = 0;
            values[valuesById[1] = "C_Default"] = 1;
            values[valuesById[2] = "C_Char"] = 2;
            values[valuesById[3] = "C_String"] = 3;
            values[valuesById[4] = "C_UTF8Char"] = 4;
            values[valuesById[5] = "C_UTF8String"] = 5;
            values[valuesById[6] = "C_UCS2Char"] = 6;
            values[valuesById[7] = "C_UCS2String"] = 7;
            values[valuesById[8] = "C_Binary"] = 8;
            values[valuesById[9] = "C_UInt8"] = 9;
            values[valuesById[10] = "C_SInt8"] = 10;
            values[valuesById[11] = "C_UInt16"] = 11;
            values[valuesById[12] = "C_SInt16"] = 12;
            values[valuesById[13] = "C_UInt32"] = 13;
            values[valuesById[14] = "C_SInt32"] = 14;
            values[valuesById[15] = "C_UInt64"] = 15;
            values[valuesById[16] = "C_SInt64"] = 16;
            values[valuesById[17] = "C_Float32"] = 17;
            values[valuesById[18] = "C_Float64"] = 18;
            values[valuesById[19] = "C_CTime"] = 19;
            values[valuesById[20] = "C_CDate"] = 20;
            values[valuesById[21] = "C_CTimeStamp"] = 21;
            values[valuesById[22] = "C_RefCursor"] = 22;
            values[valuesById[23] = "C_Blob"] = 23;
            values[valuesById[24] = "C_Clob"] = 24;
            values[valuesById[25] = "C_Decimal"] = 25;
            return values;
        })();
    
        /**
         * JAVAType enum.
         * @name CS.JAVAType
         * @enum {number}
         * @property {number} Unknown_JAVAType=0 Unknown_JAVAType value
         * @property {number} JAVA_Default=1 JAVA_Default value
         * @property {number} JAVA_String=2 JAVA_String value
         * @property {number} JAVA_Binary=3 JAVA_Binary value
         * @property {number} JAVA_Byte=4 JAVA_Byte value
         * @property {number} JAVA_Short=5 JAVA_Short value
         * @property {number} JAVA_Int=6 JAVA_Int value
         * @property {number} JAVA_Long=7 JAVA_Long value
         * @property {number} JAVA_Float=8 JAVA_Float value
         * @property {number} JAVA_Double=9 JAVA_Double value
         * @property {number} JAVA_BigDecimal=10 JAVA_BigDecimal value
         * @property {number} JAVA_Time=11 JAVA_Time value
         * @property {number} JAVA_Date=12 JAVA_Date value
         * @property {number} JAVA_Timestamp=13 JAVA_Timestamp value
         * @property {number} JAVA_RefCursor=14 JAVA_RefCursor value
         * @property {number} JAVA_Blob=15 JAVA_Blob value
         * @property {number} JAVA_Clob=16 JAVA_Clob value
         */
        CS.JAVAType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_JAVAType"] = 0;
            values[valuesById[1] = "JAVA_Default"] = 1;
            values[valuesById[2] = "JAVA_String"] = 2;
            values[valuesById[3] = "JAVA_Binary"] = 3;
            values[valuesById[4] = "JAVA_Byte"] = 4;
            values[valuesById[5] = "JAVA_Short"] = 5;
            values[valuesById[6] = "JAVA_Int"] = 6;
            values[valuesById[7] = "JAVA_Long"] = 7;
            values[valuesById[8] = "JAVA_Float"] = 8;
            values[valuesById[9] = "JAVA_Double"] = 9;
            values[valuesById[10] = "JAVA_BigDecimal"] = 10;
            values[valuesById[11] = "JAVA_Time"] = 11;
            values[valuesById[12] = "JAVA_Date"] = 12;
            values[valuesById[13] = "JAVA_Timestamp"] = 13;
            values[valuesById[14] = "JAVA_RefCursor"] = 14;
            values[valuesById[15] = "JAVA_Blob"] = 15;
            values[valuesById[16] = "JAVA_Clob"] = 16;
            return values;
        })();
    
        /**
         * OperationType enum.
         * @name CS.OperationType
         * @enum {number}
         * @property {number} Unknown_OperationType=0 Unknown_OperationType value
         * @property {number} All=1 All value
         * @property {number} Numeric=2 Numeric value
         * @property {number} OneChar=3 OneChar value
         * @property {number} CharString=4 CharString value
         * @property {number} DateTime=5 DateTime value
         * @property {number} Logical=6 Logical value
         * @property {number} AnyType=7 AnyType value
         */
        CS.OperationType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_OperationType"] = 0;
            values[valuesById[1] = "All"] = 1;
            values[valuesById[2] = "Numeric"] = 2;
            values[valuesById[3] = "OneChar"] = 3;
            values[valuesById[4] = "CharString"] = 4;
            values[valuesById[5] = "DateTime"] = 5;
            values[valuesById[6] = "Logical"] = 6;
            values[valuesById[7] = "AnyType"] = 7;
            return values;
        })();
    
        CS.ConfigItem = (function() {
    
            /**
             * Properties of a ConfigItem.
             * @memberof CS
             * @interface IConfigItem
             * @property {string|null} [m_Parameter] ConfigItem m_Parameter
             * @property {string|null} [m_Value] ConfigItem m_Value
             */
    
            /**
             * Constructs a new ConfigItem.
             * @memberof CS
             * @classdesc Represents a ConfigItem.
             * @implements IConfigItem
             * @constructor
             * @param {CS.IConfigItem=} [properties] Properties to set
             */
            function ConfigItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigItem m_Parameter.
             * @member {string} m_Parameter
             * @memberof CS.ConfigItem
             * @instance
             */
            ConfigItem.prototype.m_Parameter = "";
    
            /**
             * ConfigItem m_Value.
             * @member {string} m_Value
             * @memberof CS.ConfigItem
             * @instance
             */
            ConfigItem.prototype.m_Value = "";
    
            /**
             * Creates a new ConfigItem instance using the specified properties.
             * @function create
             * @memberof CS.ConfigItem
             * @static
             * @param {CS.IConfigItem=} [properties] Properties to set
             * @returns {CS.ConfigItem} ConfigItem instance
             */
            ConfigItem.create = function create(properties) {
                return new ConfigItem(properties);
            };
    
            /**
             * Encodes the specified ConfigItem message. Does not implicitly {@link CS.ConfigItem.verify|verify} messages.
             * @function encode
             * @memberof CS.ConfigItem
             * @static
             * @param {CS.IConfigItem} message ConfigItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Parameter != null && Object.hasOwnProperty.call(message, "m_Parameter"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Parameter);
                if (message.m_Value != null && Object.hasOwnProperty.call(message, "m_Value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Value);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigItem message, length delimited. Does not implicitly {@link CS.ConfigItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.ConfigItem
             * @static
             * @param {CS.IConfigItem} message ConfigItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigItem message from the specified reader or buffer.
             * @function decode
             * @memberof CS.ConfigItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.ConfigItem} ConfigItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.ConfigItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Parameter = reader.string();
                        break;
                    case 2:
                        message.m_Value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.ConfigItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.ConfigItem} ConfigItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigItem message.
             * @function verify
             * @memberof CS.ConfigItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Parameter != null && message.hasOwnProperty("m_Parameter"))
                    if (!$util.isString(message.m_Parameter))
                        return "m_Parameter: string expected";
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    if (!$util.isString(message.m_Value))
                        return "m_Value: string expected";
                return null;
            };
    
            /**
             * Creates a ConfigItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.ConfigItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.ConfigItem} ConfigItem
             */
            ConfigItem.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.ConfigItem)
                    return object;
                var message = new $root.CS.ConfigItem();
                if (object.m_Parameter != null)
                    message.m_Parameter = String(object.m_Parameter);
                if (object.m_Value != null)
                    message.m_Value = String(object.m_Value);
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.ConfigItem
             * @static
             * @param {CS.ConfigItem} message ConfigItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Parameter = "";
                    object.m_Value = "";
                }
                if (message.m_Parameter != null && message.hasOwnProperty("m_Parameter"))
                    object.m_Parameter = message.m_Parameter;
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    object.m_Value = message.m_Value;
                return object;
            };
    
            /**
             * Converts this ConfigItem to JSON.
             * @function toJSON
             * @memberof CS.ConfigItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigItem;
        })();
    
        CS.DateOperation = (function() {
    
            /**
             * Properties of a DateOperation.
             * @memberof CS
             * @interface IDateOperation
             * @property {string|null} [m_Operation] DateOperation m_Operation
             * @property {string|null} [m_Value] DateOperation m_Value
             */
    
            /**
             * Constructs a new DateOperation.
             * @memberof CS
             * @classdesc Represents a DateOperation.
             * @implements IDateOperation
             * @constructor
             * @param {CS.IDateOperation=} [properties] Properties to set
             */
            function DateOperation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DateOperation m_Operation.
             * @member {string} m_Operation
             * @memberof CS.DateOperation
             * @instance
             */
            DateOperation.prototype.m_Operation = "";
    
            /**
             * DateOperation m_Value.
             * @member {string} m_Value
             * @memberof CS.DateOperation
             * @instance
             */
            DateOperation.prototype.m_Value = "";
    
            /**
             * Creates a new DateOperation instance using the specified properties.
             * @function create
             * @memberof CS.DateOperation
             * @static
             * @param {CS.IDateOperation=} [properties] Properties to set
             * @returns {CS.DateOperation} DateOperation instance
             */
            DateOperation.create = function create(properties) {
                return new DateOperation(properties);
            };
    
            /**
             * Encodes the specified DateOperation message. Does not implicitly {@link CS.DateOperation.verify|verify} messages.
             * @function encode
             * @memberof CS.DateOperation
             * @static
             * @param {CS.IDateOperation} message DateOperation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateOperation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Operation != null && Object.hasOwnProperty.call(message, "m_Operation"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Operation);
                if (message.m_Value != null && Object.hasOwnProperty.call(message, "m_Value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Value);
                return writer;
            };
    
            /**
             * Encodes the specified DateOperation message, length delimited. Does not implicitly {@link CS.DateOperation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.DateOperation
             * @static
             * @param {CS.IDateOperation} message DateOperation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateOperation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DateOperation message from the specified reader or buffer.
             * @function decode
             * @memberof CS.DateOperation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.DateOperation} DateOperation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateOperation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.DateOperation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Operation = reader.string();
                        break;
                    case 2:
                        message.m_Value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DateOperation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.DateOperation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.DateOperation} DateOperation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateOperation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DateOperation message.
             * @function verify
             * @memberof CS.DateOperation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DateOperation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Operation != null && message.hasOwnProperty("m_Operation"))
                    if (!$util.isString(message.m_Operation))
                        return "m_Operation: string expected";
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    if (!$util.isString(message.m_Value))
                        return "m_Value: string expected";
                return null;
            };
    
            /**
             * Creates a DateOperation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.DateOperation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.DateOperation} DateOperation
             */
            DateOperation.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.DateOperation)
                    return object;
                var message = new $root.CS.DateOperation();
                if (object.m_Operation != null)
                    message.m_Operation = String(object.m_Operation);
                if (object.m_Value != null)
                    message.m_Value = String(object.m_Value);
                return message;
            };
    
            /**
             * Creates a plain object from a DateOperation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.DateOperation
             * @static
             * @param {CS.DateOperation} message DateOperation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DateOperation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Operation = "";
                    object.m_Value = "";
                }
                if (message.m_Operation != null && message.hasOwnProperty("m_Operation"))
                    object.m_Operation = message.m_Operation;
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    object.m_Value = message.m_Value;
                return object;
            };
    
            /**
             * Converts this DateOperation to JSON.
             * @function toJSON
             * @memberof CS.DateOperation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DateOperation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DateOperation;
        })();
    
        CS.Operator = (function() {
    
            /**
             * Properties of an Operator.
             * @memberof CS
             * @interface IOperator
             * @property {string|null} [m_Tag] Operator m_Tag
             * @property {string|null} [m_Sql] Operator m_Sql
             * @property {CS.OperationType|null} [m_Type] Operator m_Type
             * @property {number|null} [m_Arity] Operator m_Arity
             */
    
            /**
             * Constructs a new Operator.
             * @memberof CS
             * @classdesc Represents an Operator.
             * @implements IOperator
             * @constructor
             * @param {CS.IOperator=} [properties] Properties to set
             */
            function Operator(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Operator m_Tag.
             * @member {string} m_Tag
             * @memberof CS.Operator
             * @instance
             */
            Operator.prototype.m_Tag = "";
    
            /**
             * Operator m_Sql.
             * @member {string} m_Sql
             * @memberof CS.Operator
             * @instance
             */
            Operator.prototype.m_Sql = "";
    
            /**
             * Operator m_Type.
             * @member {CS.OperationType} m_Type
             * @memberof CS.Operator
             * @instance
             */
            Operator.prototype.m_Type = 0;
    
            /**
             * Operator m_Arity.
             * @member {number} m_Arity
             * @memberof CS.Operator
             * @instance
             */
            Operator.prototype.m_Arity = 0;
    
            /**
             * Creates a new Operator instance using the specified properties.
             * @function create
             * @memberof CS.Operator
             * @static
             * @param {CS.IOperator=} [properties] Properties to set
             * @returns {CS.Operator} Operator instance
             */
            Operator.create = function create(properties) {
                return new Operator(properties);
            };
    
            /**
             * Encodes the specified Operator message. Does not implicitly {@link CS.Operator.verify|verify} messages.
             * @function encode
             * @memberof CS.Operator
             * @static
             * @param {CS.IOperator} message Operator message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operator.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Tag != null && Object.hasOwnProperty.call(message, "m_Tag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Tag);
                if (message.m_Sql != null && Object.hasOwnProperty.call(message, "m_Sql"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Sql);
                if (message.m_Type != null && Object.hasOwnProperty.call(message, "m_Type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.m_Type);
                if (message.m_Arity != null && Object.hasOwnProperty.call(message, "m_Arity"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.m_Arity);
                return writer;
            };
    
            /**
             * Encodes the specified Operator message, length delimited. Does not implicitly {@link CS.Operator.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Operator
             * @static
             * @param {CS.IOperator} message Operator message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operator.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Operator message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Operator
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Operator} Operator
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operator.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Operator();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Tag = reader.string();
                        break;
                    case 2:
                        message.m_Sql = reader.string();
                        break;
                    case 3:
                        message.m_Type = reader.int32();
                        break;
                    case 4:
                        message.m_Arity = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Operator message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Operator
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Operator} Operator
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operator.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Operator message.
             * @function verify
             * @memberof CS.Operator
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Operator.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Tag != null && message.hasOwnProperty("m_Tag"))
                    if (!$util.isString(message.m_Tag))
                        return "m_Tag: string expected";
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    if (!$util.isString(message.m_Sql))
                        return "m_Sql: string expected";
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    switch (message.m_Type) {
                    default:
                        return "m_Type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.m_Arity != null && message.hasOwnProperty("m_Arity"))
                    if (!$util.isInteger(message.m_Arity))
                        return "m_Arity: integer expected";
                return null;
            };
    
            /**
             * Creates an Operator message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Operator
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Operator} Operator
             */
            Operator.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Operator)
                    return object;
                var message = new $root.CS.Operator();
                if (object.m_Tag != null)
                    message.m_Tag = String(object.m_Tag);
                if (object.m_Sql != null)
                    message.m_Sql = String(object.m_Sql);
                switch (object.m_Type) {
                case "Unknown_OperationType":
                case 0:
                    message.m_Type = 0;
                    break;
                case "All":
                case 1:
                    message.m_Type = 1;
                    break;
                case "Numeric":
                case 2:
                    message.m_Type = 2;
                    break;
                case "OneChar":
                case 3:
                    message.m_Type = 3;
                    break;
                case "CharString":
                case 4:
                    message.m_Type = 4;
                    break;
                case "DateTime":
                case 5:
                    message.m_Type = 5;
                    break;
                case "Logical":
                case 6:
                    message.m_Type = 6;
                    break;
                case "AnyType":
                case 7:
                    message.m_Type = 7;
                    break;
                }
                if (object.m_Arity != null)
                    message.m_Arity = object.m_Arity >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Operator message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Operator
             * @static
             * @param {CS.Operator} message Operator
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Operator.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Tag = "";
                    object.m_Sql = "";
                    object.m_Type = options.enums === String ? "Unknown_OperationType" : 0;
                    object.m_Arity = 0;
                }
                if (message.m_Tag != null && message.hasOwnProperty("m_Tag"))
                    object.m_Tag = message.m_Tag;
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    object.m_Sql = message.m_Sql;
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    object.m_Type = options.enums === String ? $root.CS.OperationType[message.m_Type] : message.m_Type;
                if (message.m_Arity != null && message.hasOwnProperty("m_Arity"))
                    object.m_Arity = message.m_Arity;
                return object;
            };
    
            /**
             * Converts this Operator to JSON.
             * @function toJSON
             * @memberof CS.Operator
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Operator.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Operator;
        })();
    
        CS.FunctionParameter = (function() {
    
            /**
             * Properties of a FunctionParameter.
             * @memberof CS
             * @interface IFunctionParameter
             * @property {string|null} [m_Name] FunctionParameter m_Name
             * @property {CS.OperationType|null} [m_Type] FunctionParameter m_Type
             */
    
            /**
             * Constructs a new FunctionParameter.
             * @memberof CS
             * @classdesc Represents a FunctionParameter.
             * @implements IFunctionParameter
             * @constructor
             * @param {CS.IFunctionParameter=} [properties] Properties to set
             */
            function FunctionParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FunctionParameter m_Name.
             * @member {string} m_Name
             * @memberof CS.FunctionParameter
             * @instance
             */
            FunctionParameter.prototype.m_Name = "";
    
            /**
             * FunctionParameter m_Type.
             * @member {CS.OperationType} m_Type
             * @memberof CS.FunctionParameter
             * @instance
             */
            FunctionParameter.prototype.m_Type = 0;
    
            /**
             * Creates a new FunctionParameter instance using the specified properties.
             * @function create
             * @memberof CS.FunctionParameter
             * @static
             * @param {CS.IFunctionParameter=} [properties] Properties to set
             * @returns {CS.FunctionParameter} FunctionParameter instance
             */
            FunctionParameter.create = function create(properties) {
                return new FunctionParameter(properties);
            };
    
            /**
             * Encodes the specified FunctionParameter message. Does not implicitly {@link CS.FunctionParameter.verify|verify} messages.
             * @function encode
             * @memberof CS.FunctionParameter
             * @static
             * @param {CS.IFunctionParameter} message FunctionParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FunctionParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Name);
                if (message.m_Type != null && Object.hasOwnProperty.call(message, "m_Type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.m_Type);
                return writer;
            };
    
            /**
             * Encodes the specified FunctionParameter message, length delimited. Does not implicitly {@link CS.FunctionParameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.FunctionParameter
             * @static
             * @param {CS.IFunctionParameter} message FunctionParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FunctionParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FunctionParameter message from the specified reader or buffer.
             * @function decode
             * @memberof CS.FunctionParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.FunctionParameter} FunctionParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FunctionParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.FunctionParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Name = reader.string();
                        break;
                    case 2:
                        message.m_Type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FunctionParameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.FunctionParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.FunctionParameter} FunctionParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FunctionParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FunctionParameter message.
             * @function verify
             * @memberof CS.FunctionParameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FunctionParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    switch (message.m_Type) {
                    default:
                        return "m_Type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a FunctionParameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.FunctionParameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.FunctionParameter} FunctionParameter
             */
            FunctionParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.FunctionParameter)
                    return object;
                var message = new $root.CS.FunctionParameter();
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                switch (object.m_Type) {
                case "Unknown_OperationType":
                case 0:
                    message.m_Type = 0;
                    break;
                case "All":
                case 1:
                    message.m_Type = 1;
                    break;
                case "Numeric":
                case 2:
                    message.m_Type = 2;
                    break;
                case "OneChar":
                case 3:
                    message.m_Type = 3;
                    break;
                case "CharString":
                case 4:
                    message.m_Type = 4;
                    break;
                case "DateTime":
                case 5:
                    message.m_Type = 5;
                    break;
                case "Logical":
                case 6:
                    message.m_Type = 6;
                    break;
                case "AnyType":
                case 7:
                    message.m_Type = 7;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FunctionParameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.FunctionParameter
             * @static
             * @param {CS.FunctionParameter} message FunctionParameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FunctionParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Name = "";
                    object.m_Type = options.enums === String ? "Unknown_OperationType" : 0;
                }
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    object.m_Type = options.enums === String ? $root.CS.OperationType[message.m_Type] : message.m_Type;
                return object;
            };
    
            /**
             * Converts this FunctionParameter to JSON.
             * @function toJSON
             * @memberof CS.FunctionParameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FunctionParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FunctionParameter;
        })();
    
        CS.Function = (function() {
    
            /**
             * Properties of a Function.
             * @memberof CS
             * @interface IFunction
             * @property {string|null} [m_Tag] Function m_Tag
             * @property {string|null} [m_Name] Function m_Name
             * @property {string|null} [m_FuncName] Function m_FuncName
             * @property {string|null} [m_Sql] Function m_Sql
             * @property {string|null} [m_Help] Function m_Help
             * @property {Array.<CS.IFunctionParameter>|null} [m_Parameters] Function m_Parameters
             * @property {boolean|null} [m_InMacro] Function m_InMacro
             * @property {boolean|null} [m_Group] Function m_Group
             * @property {boolean|null} [m_Distinct] Function m_Distinct
             * @property {CS.OperationType|null} [m_ReturnType] Function m_ReturnType
             */
    
            /**
             * Constructs a new Function.
             * @memberof CS
             * @classdesc Represents a Function.
             * @implements IFunction
             * @constructor
             * @param {CS.IFunction=} [properties] Properties to set
             */
            function Function(properties) {
                this.m_Parameters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Function m_Tag.
             * @member {string} m_Tag
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_Tag = "";
    
            /**
             * Function m_Name.
             * @member {string} m_Name
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_Name = "";
    
            /**
             * Function m_FuncName.
             * @member {string} m_FuncName
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_FuncName = "";
    
            /**
             * Function m_Sql.
             * @member {string} m_Sql
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_Sql = "";
    
            /**
             * Function m_Help.
             * @member {string} m_Help
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_Help = "";
    
            /**
             * Function m_Parameters.
             * @member {Array.<CS.IFunctionParameter>} m_Parameters
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_Parameters = $util.emptyArray;
    
            /**
             * Function m_InMacro.
             * @member {boolean} m_InMacro
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_InMacro = false;
    
            /**
             * Function m_Group.
             * @member {boolean} m_Group
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_Group = false;
    
            /**
             * Function m_Distinct.
             * @member {boolean} m_Distinct
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_Distinct = false;
    
            /**
             * Function m_ReturnType.
             * @member {CS.OperationType} m_ReturnType
             * @memberof CS.Function
             * @instance
             */
            Function.prototype.m_ReturnType = 0;
    
            /**
             * Creates a new Function instance using the specified properties.
             * @function create
             * @memberof CS.Function
             * @static
             * @param {CS.IFunction=} [properties] Properties to set
             * @returns {CS.Function} Function instance
             */
            Function.create = function create(properties) {
                return new Function(properties);
            };
    
            /**
             * Encodes the specified Function message. Does not implicitly {@link CS.Function.verify|verify} messages.
             * @function encode
             * @memberof CS.Function
             * @static
             * @param {CS.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Tag != null && Object.hasOwnProperty.call(message, "m_Tag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Tag);
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Name);
                if (message.m_FuncName != null && Object.hasOwnProperty.call(message, "m_FuncName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_FuncName);
                if (message.m_Sql != null && Object.hasOwnProperty.call(message, "m_Sql"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_Sql);
                if (message.m_Help != null && Object.hasOwnProperty.call(message, "m_Help"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.m_Help);
                if (message.m_Parameters != null && message.m_Parameters.length)
                    for (var i = 0; i < message.m_Parameters.length; ++i)
                        $root.CS.FunctionParameter.encode(message.m_Parameters[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.m_InMacro != null && Object.hasOwnProperty.call(message, "m_InMacro"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.m_InMacro);
                if (message.m_Group != null && Object.hasOwnProperty.call(message, "m_Group"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.m_Group);
                if (message.m_Distinct != null && Object.hasOwnProperty.call(message, "m_Distinct"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.m_Distinct);
                if (message.m_ReturnType != null && Object.hasOwnProperty.call(message, "m_ReturnType"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.m_ReturnType);
                return writer;
            };
    
            /**
             * Encodes the specified Function message, length delimited. Does not implicitly {@link CS.Function.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Function
             * @static
             * @param {CS.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Function message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Function();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Tag = reader.string();
                        break;
                    case 2:
                        message.m_Name = reader.string();
                        break;
                    case 3:
                        message.m_FuncName = reader.string();
                        break;
                    case 4:
                        message.m_Sql = reader.string();
                        break;
                    case 5:
                        message.m_Help = reader.string();
                        break;
                    case 6:
                        if (!(message.m_Parameters && message.m_Parameters.length))
                            message.m_Parameters = [];
                        message.m_Parameters.push($root.CS.FunctionParameter.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.m_InMacro = reader.bool();
                        break;
                    case 8:
                        message.m_Group = reader.bool();
                        break;
                    case 9:
                        message.m_Distinct = reader.bool();
                        break;
                    case 10:
                        message.m_ReturnType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Function message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Function message.
             * @function verify
             * @memberof CS.Function
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Function.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Tag != null && message.hasOwnProperty("m_Tag"))
                    if (!$util.isString(message.m_Tag))
                        return "m_Tag: string expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_FuncName != null && message.hasOwnProperty("m_FuncName"))
                    if (!$util.isString(message.m_FuncName))
                        return "m_FuncName: string expected";
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    if (!$util.isString(message.m_Sql))
                        return "m_Sql: string expected";
                if (message.m_Help != null && message.hasOwnProperty("m_Help"))
                    if (!$util.isString(message.m_Help))
                        return "m_Help: string expected";
                if (message.m_Parameters != null && message.hasOwnProperty("m_Parameters")) {
                    if (!Array.isArray(message.m_Parameters))
                        return "m_Parameters: array expected";
                    for (var i = 0; i < message.m_Parameters.length; ++i) {
                        var error = $root.CS.FunctionParameter.verify(message.m_Parameters[i]);
                        if (error)
                            return "m_Parameters." + error;
                    }
                }
                if (message.m_InMacro != null && message.hasOwnProperty("m_InMacro"))
                    if (typeof message.m_InMacro !== "boolean")
                        return "m_InMacro: boolean expected";
                if (message.m_Group != null && message.hasOwnProperty("m_Group"))
                    if (typeof message.m_Group !== "boolean")
                        return "m_Group: boolean expected";
                if (message.m_Distinct != null && message.hasOwnProperty("m_Distinct"))
                    if (typeof message.m_Distinct !== "boolean")
                        return "m_Distinct: boolean expected";
                if (message.m_ReturnType != null && message.hasOwnProperty("m_ReturnType"))
                    switch (message.m_ReturnType) {
                    default:
                        return "m_ReturnType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a Function message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Function
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Function} Function
             */
            Function.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Function)
                    return object;
                var message = new $root.CS.Function();
                if (object.m_Tag != null)
                    message.m_Tag = String(object.m_Tag);
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                if (object.m_FuncName != null)
                    message.m_FuncName = String(object.m_FuncName);
                if (object.m_Sql != null)
                    message.m_Sql = String(object.m_Sql);
                if (object.m_Help != null)
                    message.m_Help = String(object.m_Help);
                if (object.m_Parameters) {
                    if (!Array.isArray(object.m_Parameters))
                        throw TypeError(".CS.Function.m_Parameters: array expected");
                    message.m_Parameters = [];
                    for (var i = 0; i < object.m_Parameters.length; ++i) {
                        if (typeof object.m_Parameters[i] !== "object")
                            throw TypeError(".CS.Function.m_Parameters: object expected");
                        message.m_Parameters[i] = $root.CS.FunctionParameter.fromObject(object.m_Parameters[i]);
                    }
                }
                if (object.m_InMacro != null)
                    message.m_InMacro = Boolean(object.m_InMacro);
                if (object.m_Group != null)
                    message.m_Group = Boolean(object.m_Group);
                if (object.m_Distinct != null)
                    message.m_Distinct = Boolean(object.m_Distinct);
                switch (object.m_ReturnType) {
                case "Unknown_OperationType":
                case 0:
                    message.m_ReturnType = 0;
                    break;
                case "All":
                case 1:
                    message.m_ReturnType = 1;
                    break;
                case "Numeric":
                case 2:
                    message.m_ReturnType = 2;
                    break;
                case "OneChar":
                case 3:
                    message.m_ReturnType = 3;
                    break;
                case "CharString":
                case 4:
                    message.m_ReturnType = 4;
                    break;
                case "DateTime":
                case 5:
                    message.m_ReturnType = 5;
                    break;
                case "Logical":
                case 6:
                    message.m_ReturnType = 6;
                    break;
                case "AnyType":
                case 7:
                    message.m_ReturnType = 7;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Function message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Function
             * @static
             * @param {CS.Function} message Function
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Function.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.m_Parameters = [];
                if (options.defaults) {
                    object.m_Tag = "";
                    object.m_Name = "";
                    object.m_FuncName = "";
                    object.m_Sql = "";
                    object.m_Help = "";
                    object.m_InMacro = false;
                    object.m_Group = false;
                    object.m_Distinct = false;
                    object.m_ReturnType = options.enums === String ? "Unknown_OperationType" : 0;
                }
                if (message.m_Tag != null && message.hasOwnProperty("m_Tag"))
                    object.m_Tag = message.m_Tag;
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_FuncName != null && message.hasOwnProperty("m_FuncName"))
                    object.m_FuncName = message.m_FuncName;
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    object.m_Sql = message.m_Sql;
                if (message.m_Help != null && message.hasOwnProperty("m_Help"))
                    object.m_Help = message.m_Help;
                if (message.m_Parameters && message.m_Parameters.length) {
                    object.m_Parameters = [];
                    for (var j = 0; j < message.m_Parameters.length; ++j)
                        object.m_Parameters[j] = $root.CS.FunctionParameter.toObject(message.m_Parameters[j], options);
                }
                if (message.m_InMacro != null && message.hasOwnProperty("m_InMacro"))
                    object.m_InMacro = message.m_InMacro;
                if (message.m_Group != null && message.hasOwnProperty("m_Group"))
                    object.m_Group = message.m_Group;
                if (message.m_Distinct != null && message.hasOwnProperty("m_Distinct"))
                    object.m_Distinct = message.m_Distinct;
                if (message.m_ReturnType != null && message.hasOwnProperty("m_ReturnType"))
                    object.m_ReturnType = options.enums === String ? $root.CS.OperationType[message.m_ReturnType] : message.m_ReturnType;
                return object;
            };
    
            /**
             * Converts this Function to JSON.
             * @function toJSON
             * @memberof CS.Function
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Function.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Function;
        })();
    
        CS.DomainParameterSet = (function() {
    
            /**
             * Properties of a DomainParameterSet.
             * @memberof CS
             * @interface IDomainParameterSet
             * @property {string|null} [m_Domain] DomainParameterSet m_Domain
             * @property {Array.<CS.IConfigItem>|null} [m_Configuration] DomainParameterSet m_Configuration
             * @property {Array.<CS.IDateOperation>|null} [m_DateOperations] DomainParameterSet m_DateOperations
             * @property {Array.<CS.IOperator>|null} [m_Operators] DomainParameterSet m_Operators
             * @property {Array.<CS.IFunction>|null} [m_Functions] DomainParameterSet m_Functions
             */
    
            /**
             * Constructs a new DomainParameterSet.
             * @memberof CS
             * @classdesc Represents a DomainParameterSet.
             * @implements IDomainParameterSet
             * @constructor
             * @param {CS.IDomainParameterSet=} [properties] Properties to set
             */
            function DomainParameterSet(properties) {
                this.m_Configuration = [];
                this.m_DateOperations = [];
                this.m_Operators = [];
                this.m_Functions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DomainParameterSet m_Domain.
             * @member {string} m_Domain
             * @memberof CS.DomainParameterSet
             * @instance
             */
            DomainParameterSet.prototype.m_Domain = "";
    
            /**
             * DomainParameterSet m_Configuration.
             * @member {Array.<CS.IConfigItem>} m_Configuration
             * @memberof CS.DomainParameterSet
             * @instance
             */
            DomainParameterSet.prototype.m_Configuration = $util.emptyArray;
    
            /**
             * DomainParameterSet m_DateOperations.
             * @member {Array.<CS.IDateOperation>} m_DateOperations
             * @memberof CS.DomainParameterSet
             * @instance
             */
            DomainParameterSet.prototype.m_DateOperations = $util.emptyArray;
    
            /**
             * DomainParameterSet m_Operators.
             * @member {Array.<CS.IOperator>} m_Operators
             * @memberof CS.DomainParameterSet
             * @instance
             */
            DomainParameterSet.prototype.m_Operators = $util.emptyArray;
    
            /**
             * DomainParameterSet m_Functions.
             * @member {Array.<CS.IFunction>} m_Functions
             * @memberof CS.DomainParameterSet
             * @instance
             */
            DomainParameterSet.prototype.m_Functions = $util.emptyArray;
    
            /**
             * Creates a new DomainParameterSet instance using the specified properties.
             * @function create
             * @memberof CS.DomainParameterSet
             * @static
             * @param {CS.IDomainParameterSet=} [properties] Properties to set
             * @returns {CS.DomainParameterSet} DomainParameterSet instance
             */
            DomainParameterSet.create = function create(properties) {
                return new DomainParameterSet(properties);
            };
    
            /**
             * Encodes the specified DomainParameterSet message. Does not implicitly {@link CS.DomainParameterSet.verify|verify} messages.
             * @function encode
             * @memberof CS.DomainParameterSet
             * @static
             * @param {CS.IDomainParameterSet} message DomainParameterSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DomainParameterSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Domain != null && Object.hasOwnProperty.call(message, "m_Domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Domain);
                if (message.m_Configuration != null && message.m_Configuration.length)
                    for (var i = 0; i < message.m_Configuration.length; ++i)
                        $root.CS.ConfigItem.encode(message.m_Configuration[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.m_DateOperations != null && message.m_DateOperations.length)
                    for (var i = 0; i < message.m_DateOperations.length; ++i)
                        $root.CS.DateOperation.encode(message.m_DateOperations[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.m_Operators != null && message.m_Operators.length)
                    for (var i = 0; i < message.m_Operators.length; ++i)
                        $root.CS.Operator.encode(message.m_Operators[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.m_Functions != null && message.m_Functions.length)
                    for (var i = 0; i < message.m_Functions.length; ++i)
                        $root.CS.Function.encode(message.m_Functions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DomainParameterSet message, length delimited. Does not implicitly {@link CS.DomainParameterSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.DomainParameterSet
             * @static
             * @param {CS.IDomainParameterSet} message DomainParameterSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DomainParameterSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DomainParameterSet message from the specified reader or buffer.
             * @function decode
             * @memberof CS.DomainParameterSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.DomainParameterSet} DomainParameterSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DomainParameterSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.DomainParameterSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Domain = reader.string();
                        break;
                    case 2:
                        if (!(message.m_Configuration && message.m_Configuration.length))
                            message.m_Configuration = [];
                        message.m_Configuration.push($root.CS.ConfigItem.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.m_DateOperations && message.m_DateOperations.length))
                            message.m_DateOperations = [];
                        message.m_DateOperations.push($root.CS.DateOperation.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.m_Operators && message.m_Operators.length))
                            message.m_Operators = [];
                        message.m_Operators.push($root.CS.Operator.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.m_Functions && message.m_Functions.length))
                            message.m_Functions = [];
                        message.m_Functions.push($root.CS.Function.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DomainParameterSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.DomainParameterSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.DomainParameterSet} DomainParameterSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DomainParameterSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DomainParameterSet message.
             * @function verify
             * @memberof CS.DomainParameterSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DomainParameterSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Domain != null && message.hasOwnProperty("m_Domain"))
                    if (!$util.isString(message.m_Domain))
                        return "m_Domain: string expected";
                if (message.m_Configuration != null && message.hasOwnProperty("m_Configuration")) {
                    if (!Array.isArray(message.m_Configuration))
                        return "m_Configuration: array expected";
                    for (var i = 0; i < message.m_Configuration.length; ++i) {
                        var error = $root.CS.ConfigItem.verify(message.m_Configuration[i]);
                        if (error)
                            return "m_Configuration." + error;
                    }
                }
                if (message.m_DateOperations != null && message.hasOwnProperty("m_DateOperations")) {
                    if (!Array.isArray(message.m_DateOperations))
                        return "m_DateOperations: array expected";
                    for (var i = 0; i < message.m_DateOperations.length; ++i) {
                        var error = $root.CS.DateOperation.verify(message.m_DateOperations[i]);
                        if (error)
                            return "m_DateOperations." + error;
                    }
                }
                if (message.m_Operators != null && message.hasOwnProperty("m_Operators")) {
                    if (!Array.isArray(message.m_Operators))
                        return "m_Operators: array expected";
                    for (var i = 0; i < message.m_Operators.length; ++i) {
                        var error = $root.CS.Operator.verify(message.m_Operators[i]);
                        if (error)
                            return "m_Operators." + error;
                    }
                }
                if (message.m_Functions != null && message.hasOwnProperty("m_Functions")) {
                    if (!Array.isArray(message.m_Functions))
                        return "m_Functions: array expected";
                    for (var i = 0; i < message.m_Functions.length; ++i) {
                        var error = $root.CS.Function.verify(message.m_Functions[i]);
                        if (error)
                            return "m_Functions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DomainParameterSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.DomainParameterSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.DomainParameterSet} DomainParameterSet
             */
            DomainParameterSet.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.DomainParameterSet)
                    return object;
                var message = new $root.CS.DomainParameterSet();
                if (object.m_Domain != null)
                    message.m_Domain = String(object.m_Domain);
                if (object.m_Configuration) {
                    if (!Array.isArray(object.m_Configuration))
                        throw TypeError(".CS.DomainParameterSet.m_Configuration: array expected");
                    message.m_Configuration = [];
                    for (var i = 0; i < object.m_Configuration.length; ++i) {
                        if (typeof object.m_Configuration[i] !== "object")
                            throw TypeError(".CS.DomainParameterSet.m_Configuration: object expected");
                        message.m_Configuration[i] = $root.CS.ConfigItem.fromObject(object.m_Configuration[i]);
                    }
                }
                if (object.m_DateOperations) {
                    if (!Array.isArray(object.m_DateOperations))
                        throw TypeError(".CS.DomainParameterSet.m_DateOperations: array expected");
                    message.m_DateOperations = [];
                    for (var i = 0; i < object.m_DateOperations.length; ++i) {
                        if (typeof object.m_DateOperations[i] !== "object")
                            throw TypeError(".CS.DomainParameterSet.m_DateOperations: object expected");
                        message.m_DateOperations[i] = $root.CS.DateOperation.fromObject(object.m_DateOperations[i]);
                    }
                }
                if (object.m_Operators) {
                    if (!Array.isArray(object.m_Operators))
                        throw TypeError(".CS.DomainParameterSet.m_Operators: array expected");
                    message.m_Operators = [];
                    for (var i = 0; i < object.m_Operators.length; ++i) {
                        if (typeof object.m_Operators[i] !== "object")
                            throw TypeError(".CS.DomainParameterSet.m_Operators: object expected");
                        message.m_Operators[i] = $root.CS.Operator.fromObject(object.m_Operators[i]);
                    }
                }
                if (object.m_Functions) {
                    if (!Array.isArray(object.m_Functions))
                        throw TypeError(".CS.DomainParameterSet.m_Functions: array expected");
                    message.m_Functions = [];
                    for (var i = 0; i < object.m_Functions.length; ++i) {
                        if (typeof object.m_Functions[i] !== "object")
                            throw TypeError(".CS.DomainParameterSet.m_Functions: object expected");
                        message.m_Functions[i] = $root.CS.Function.fromObject(object.m_Functions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DomainParameterSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.DomainParameterSet
             * @static
             * @param {CS.DomainParameterSet} message DomainParameterSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DomainParameterSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.m_Configuration = [];
                    object.m_DateOperations = [];
                    object.m_Operators = [];
                    object.m_Functions = [];
                }
                if (options.defaults)
                    object.m_Domain = "";
                if (message.m_Domain != null && message.hasOwnProperty("m_Domain"))
                    object.m_Domain = message.m_Domain;
                if (message.m_Configuration && message.m_Configuration.length) {
                    object.m_Configuration = [];
                    for (var j = 0; j < message.m_Configuration.length; ++j)
                        object.m_Configuration[j] = $root.CS.ConfigItem.toObject(message.m_Configuration[j], options);
                }
                if (message.m_DateOperations && message.m_DateOperations.length) {
                    object.m_DateOperations = [];
                    for (var j = 0; j < message.m_DateOperations.length; ++j)
                        object.m_DateOperations[j] = $root.CS.DateOperation.toObject(message.m_DateOperations[j], options);
                }
                if (message.m_Operators && message.m_Operators.length) {
                    object.m_Operators = [];
                    for (var j = 0; j < message.m_Operators.length; ++j)
                        object.m_Operators[j] = $root.CS.Operator.toObject(message.m_Operators[j], options);
                }
                if (message.m_Functions && message.m_Functions.length) {
                    object.m_Functions = [];
                    for (var j = 0; j < message.m_Functions.length; ++j)
                        object.m_Functions[j] = $root.CS.Function.toObject(message.m_Functions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this DomainParameterSet to JSON.
             * @function toJSON
             * @memberof CS.DomainParameterSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DomainParameterSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DomainParameterSet;
        })();
    
        CS.Strategy = (function() {
    
            /**
             * Properties of a Strategy.
             * @memberof CS
             * @interface IStrategy
             * @property {string|null} [m_Tag] Strategy m_Tag
             * @property {string|null} [m_Name] Strategy m_Name
             * @property {string|null} [m_Type] Strategy m_Type
             * @property {string|null} [m_Connection] Strategy m_Connection
             * @property {string|null} [m_Sql] Strategy m_Sql
             * @property {string|null} [m_Help] Strategy m_Help
             * @property {Array.<string>|null} [m_List] Strategy m_List
             * @property {boolean|null} [m_SkipMeasures] Strategy m_SkipMeasures
             * @property {string|null} [m_Separator] Strategy m_Separator
             */
    
            /**
             * Constructs a new Strategy.
             * @memberof CS
             * @classdesc Represents a Strategy.
             * @implements IStrategy
             * @constructor
             * @param {CS.IStrategy=} [properties] Properties to set
             */
            function Strategy(properties) {
                this.m_List = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Strategy m_Tag.
             * @member {string} m_Tag
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_Tag = "";
    
            /**
             * Strategy m_Name.
             * @member {string} m_Name
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_Name = "";
    
            /**
             * Strategy m_Type.
             * @member {string} m_Type
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_Type = "";
    
            /**
             * Strategy m_Connection.
             * @member {string} m_Connection
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_Connection = "";
    
            /**
             * Strategy m_Sql.
             * @member {string} m_Sql
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_Sql = "";
    
            /**
             * Strategy m_Help.
             * @member {string} m_Help
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_Help = "";
    
            /**
             * Strategy m_List.
             * @member {Array.<string>} m_List
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_List = $util.emptyArray;
    
            /**
             * Strategy m_SkipMeasures.
             * @member {boolean} m_SkipMeasures
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_SkipMeasures = false;
    
            /**
             * Strategy m_Separator.
             * @member {string} m_Separator
             * @memberof CS.Strategy
             * @instance
             */
            Strategy.prototype.m_Separator = "";
    
            /**
             * Creates a new Strategy instance using the specified properties.
             * @function create
             * @memberof CS.Strategy
             * @static
             * @param {CS.IStrategy=} [properties] Properties to set
             * @returns {CS.Strategy} Strategy instance
             */
            Strategy.create = function create(properties) {
                return new Strategy(properties);
            };
    
            /**
             * Encodes the specified Strategy message. Does not implicitly {@link CS.Strategy.verify|verify} messages.
             * @function encode
             * @memberof CS.Strategy
             * @static
             * @param {CS.IStrategy} message Strategy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Strategy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Tag != null && Object.hasOwnProperty.call(message, "m_Tag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Tag);
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Name);
                if (message.m_Type != null && Object.hasOwnProperty.call(message, "m_Type"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_Type);
                if (message.m_Connection != null && Object.hasOwnProperty.call(message, "m_Connection"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_Connection);
                if (message.m_Sql != null && Object.hasOwnProperty.call(message, "m_Sql"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.m_Sql);
                if (message.m_Help != null && Object.hasOwnProperty.call(message, "m_Help"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.m_Help);
                if (message.m_List != null && message.m_List.length)
                    for (var i = 0; i < message.m_List.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.m_List[i]);
                if (message.m_SkipMeasures != null && Object.hasOwnProperty.call(message, "m_SkipMeasures"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.m_SkipMeasures);
                if (message.m_Separator != null && Object.hasOwnProperty.call(message, "m_Separator"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.m_Separator);
                return writer;
            };
    
            /**
             * Encodes the specified Strategy message, length delimited. Does not implicitly {@link CS.Strategy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Strategy
             * @static
             * @param {CS.IStrategy} message Strategy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Strategy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Strategy message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Strategy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Strategy} Strategy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Strategy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Strategy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Tag = reader.string();
                        break;
                    case 2:
                        message.m_Name = reader.string();
                        break;
                    case 3:
                        message.m_Type = reader.string();
                        break;
                    case 4:
                        message.m_Connection = reader.string();
                        break;
                    case 5:
                        message.m_Sql = reader.string();
                        break;
                    case 6:
                        message.m_Help = reader.string();
                        break;
                    case 7:
                        if (!(message.m_List && message.m_List.length))
                            message.m_List = [];
                        message.m_List.push(reader.string());
                        break;
                    case 8:
                        message.m_SkipMeasures = reader.bool();
                        break;
                    case 9:
                        message.m_Separator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Strategy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Strategy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Strategy} Strategy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Strategy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Strategy message.
             * @function verify
             * @memberof CS.Strategy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Strategy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Tag != null && message.hasOwnProperty("m_Tag"))
                    if (!$util.isString(message.m_Tag))
                        return "m_Tag: string expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    if (!$util.isString(message.m_Type))
                        return "m_Type: string expected";
                if (message.m_Connection != null && message.hasOwnProperty("m_Connection"))
                    if (!$util.isString(message.m_Connection))
                        return "m_Connection: string expected";
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    if (!$util.isString(message.m_Sql))
                        return "m_Sql: string expected";
                if (message.m_Help != null && message.hasOwnProperty("m_Help"))
                    if (!$util.isString(message.m_Help))
                        return "m_Help: string expected";
                if (message.m_List != null && message.hasOwnProperty("m_List")) {
                    if (!Array.isArray(message.m_List))
                        return "m_List: array expected";
                    for (var i = 0; i < message.m_List.length; ++i)
                        if (!$util.isString(message.m_List[i]))
                            return "m_List: string[] expected";
                }
                if (message.m_SkipMeasures != null && message.hasOwnProperty("m_SkipMeasures"))
                    if (typeof message.m_SkipMeasures !== "boolean")
                        return "m_SkipMeasures: boolean expected";
                if (message.m_Separator != null && message.hasOwnProperty("m_Separator"))
                    if (!$util.isString(message.m_Separator))
                        return "m_Separator: string expected";
                return null;
            };
    
            /**
             * Creates a Strategy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Strategy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Strategy} Strategy
             */
            Strategy.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Strategy)
                    return object;
                var message = new $root.CS.Strategy();
                if (object.m_Tag != null)
                    message.m_Tag = String(object.m_Tag);
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                if (object.m_Type != null)
                    message.m_Type = String(object.m_Type);
                if (object.m_Connection != null)
                    message.m_Connection = String(object.m_Connection);
                if (object.m_Sql != null)
                    message.m_Sql = String(object.m_Sql);
                if (object.m_Help != null)
                    message.m_Help = String(object.m_Help);
                if (object.m_List) {
                    if (!Array.isArray(object.m_List))
                        throw TypeError(".CS.Strategy.m_List: array expected");
                    message.m_List = [];
                    for (var i = 0; i < object.m_List.length; ++i)
                        message.m_List[i] = String(object.m_List[i]);
                }
                if (object.m_SkipMeasures != null)
                    message.m_SkipMeasures = Boolean(object.m_SkipMeasures);
                if (object.m_Separator != null)
                    message.m_Separator = String(object.m_Separator);
                return message;
            };
    
            /**
             * Creates a plain object from a Strategy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Strategy
             * @static
             * @param {CS.Strategy} message Strategy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Strategy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.m_List = [];
                if (options.defaults) {
                    object.m_Tag = "";
                    object.m_Name = "";
                    object.m_Type = "";
                    object.m_Connection = "";
                    object.m_Sql = "";
                    object.m_Help = "";
                    object.m_SkipMeasures = false;
                    object.m_Separator = "";
                }
                if (message.m_Tag != null && message.hasOwnProperty("m_Tag"))
                    object.m_Tag = message.m_Tag;
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    object.m_Type = message.m_Type;
                if (message.m_Connection != null && message.hasOwnProperty("m_Connection"))
                    object.m_Connection = message.m_Connection;
                if (message.m_Sql != null && message.hasOwnProperty("m_Sql"))
                    object.m_Sql = message.m_Sql;
                if (message.m_Help != null && message.hasOwnProperty("m_Help"))
                    object.m_Help = message.m_Help;
                if (message.m_List && message.m_List.length) {
                    object.m_List = [];
                    for (var j = 0; j < message.m_List.length; ++j)
                        object.m_List[j] = message.m_List[j];
                }
                if (message.m_SkipMeasures != null && message.hasOwnProperty("m_SkipMeasures"))
                    object.m_SkipMeasures = message.m_SkipMeasures;
                if (message.m_Separator != null && message.hasOwnProperty("m_Separator"))
                    object.m_Separator = message.m_Separator;
                return object;
            };
    
            /**
             * Converts this Strategy to JSON.
             * @function toJSON
             * @memberof CS.Strategy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Strategy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Strategy;
        })();
    
        /**
         * SupportLevel enum.
         * @name CS.SupportLevel
         * @enum {number}
         * @property {number} Unknown_SupportLevel=0 Unknown_SupportLevel value
         * @property {number} Query=1 Query value
         * @property {number} Repository=2 Repository value
         * @property {number} StoredProcedure=3 StoredProcedure value
         * @property {number} Cancel=4 Cancel value
         */
        CS.SupportLevel = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_SupportLevel"] = 0;
            values[valuesById[1] = "Query"] = 1;
            values[valuesById[2] = "Repository"] = 2;
            values[valuesById[3] = "StoredProcedure"] = 3;
            values[valuesById[4] = "Cancel"] = 4;
            return values;
        })();
    
        /**
         * CancelSupportLevel enum.
         * @name CS.CancelSupportLevel
         * @enum {number}
         * @property {number} Unknown_CancelSupportLevel=0 Unknown_CancelSupportLevel value
         * @property {number} Describe=1 Describe value
         * @property {number} Execute=2 Execute value
         * @property {number} Fetch=3 Fetch value
         */
        CS.CancelSupportLevel = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_CancelSupportLevel"] = 0;
            values[valuesById[1] = "Describe"] = 1;
            values[valuesById[2] = "Execute"] = 2;
            values[valuesById[3] = "Fetch"] = 3;
            return values;
        })();
    
        CS.LocaleDescriptor = (function() {
    
            /**
             * Properties of a LocaleDescriptor.
             * @memberof CS
             * @interface ILocaleDescriptor
             * @property {string|null} [m_Language] LocaleDescriptor m_Language
             * @property {string|null} [m_Country] LocaleDescriptor m_Country
             * @property {string|null} [m_CharSet] LocaleDescriptor m_CharSet
             * @property {string|null} [m_DateFormat] LocaleDescriptor m_DateFormat
             * @property {string|null} [m_TimeFormat] LocaleDescriptor m_TimeFormat
             * @property {string|null} [m_TimeStampFormat] LocaleDescriptor m_TimeStampFormat
             */
    
            /**
             * Constructs a new LocaleDescriptor.
             * @memberof CS
             * @classdesc Represents a LocaleDescriptor.
             * @implements ILocaleDescriptor
             * @constructor
             * @param {CS.ILocaleDescriptor=} [properties] Properties to set
             */
            function LocaleDescriptor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LocaleDescriptor m_Language.
             * @member {string} m_Language
             * @memberof CS.LocaleDescriptor
             * @instance
             */
            LocaleDescriptor.prototype.m_Language = "";
    
            /**
             * LocaleDescriptor m_Country.
             * @member {string} m_Country
             * @memberof CS.LocaleDescriptor
             * @instance
             */
            LocaleDescriptor.prototype.m_Country = "";
    
            /**
             * LocaleDescriptor m_CharSet.
             * @member {string} m_CharSet
             * @memberof CS.LocaleDescriptor
             * @instance
             */
            LocaleDescriptor.prototype.m_CharSet = "";
    
            /**
             * LocaleDescriptor m_DateFormat.
             * @member {string} m_DateFormat
             * @memberof CS.LocaleDescriptor
             * @instance
             */
            LocaleDescriptor.prototype.m_DateFormat = "";
    
            /**
             * LocaleDescriptor m_TimeFormat.
             * @member {string} m_TimeFormat
             * @memberof CS.LocaleDescriptor
             * @instance
             */
            LocaleDescriptor.prototype.m_TimeFormat = "";
    
            /**
             * LocaleDescriptor m_TimeStampFormat.
             * @member {string} m_TimeStampFormat
             * @memberof CS.LocaleDescriptor
             * @instance
             */
            LocaleDescriptor.prototype.m_TimeStampFormat = "";
    
            /**
             * Creates a new LocaleDescriptor instance using the specified properties.
             * @function create
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {CS.ILocaleDescriptor=} [properties] Properties to set
             * @returns {CS.LocaleDescriptor} LocaleDescriptor instance
             */
            LocaleDescriptor.create = function create(properties) {
                return new LocaleDescriptor(properties);
            };
    
            /**
             * Encodes the specified LocaleDescriptor message. Does not implicitly {@link CS.LocaleDescriptor.verify|verify} messages.
             * @function encode
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {CS.ILocaleDescriptor} message LocaleDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocaleDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Language != null && Object.hasOwnProperty.call(message, "m_Language"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Language);
                if (message.m_Country != null && Object.hasOwnProperty.call(message, "m_Country"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Country);
                if (message.m_CharSet != null && Object.hasOwnProperty.call(message, "m_CharSet"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_CharSet);
                if (message.m_DateFormat != null && Object.hasOwnProperty.call(message, "m_DateFormat"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_DateFormat);
                if (message.m_TimeFormat != null && Object.hasOwnProperty.call(message, "m_TimeFormat"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.m_TimeFormat);
                if (message.m_TimeStampFormat != null && Object.hasOwnProperty.call(message, "m_TimeStampFormat"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.m_TimeStampFormat);
                return writer;
            };
    
            /**
             * Encodes the specified LocaleDescriptor message, length delimited. Does not implicitly {@link CS.LocaleDescriptor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {CS.ILocaleDescriptor} message LocaleDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocaleDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LocaleDescriptor message from the specified reader or buffer.
             * @function decode
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.LocaleDescriptor} LocaleDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocaleDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.LocaleDescriptor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Language = reader.string();
                        break;
                    case 2:
                        message.m_Country = reader.string();
                        break;
                    case 3:
                        message.m_CharSet = reader.string();
                        break;
                    case 4:
                        message.m_DateFormat = reader.string();
                        break;
                    case 5:
                        message.m_TimeFormat = reader.string();
                        break;
                    case 6:
                        message.m_TimeStampFormat = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LocaleDescriptor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.LocaleDescriptor} LocaleDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocaleDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LocaleDescriptor message.
             * @function verify
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocaleDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Language != null && message.hasOwnProperty("m_Language"))
                    if (!$util.isString(message.m_Language))
                        return "m_Language: string expected";
                if (message.m_Country != null && message.hasOwnProperty("m_Country"))
                    if (!$util.isString(message.m_Country))
                        return "m_Country: string expected";
                if (message.m_CharSet != null && message.hasOwnProperty("m_CharSet"))
                    if (!$util.isString(message.m_CharSet))
                        return "m_CharSet: string expected";
                if (message.m_DateFormat != null && message.hasOwnProperty("m_DateFormat"))
                    if (!$util.isString(message.m_DateFormat))
                        return "m_DateFormat: string expected";
                if (message.m_TimeFormat != null && message.hasOwnProperty("m_TimeFormat"))
                    if (!$util.isString(message.m_TimeFormat))
                        return "m_TimeFormat: string expected";
                if (message.m_TimeStampFormat != null && message.hasOwnProperty("m_TimeStampFormat"))
                    if (!$util.isString(message.m_TimeStampFormat))
                        return "m_TimeStampFormat: string expected";
                return null;
            };
    
            /**
             * Creates a LocaleDescriptor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.LocaleDescriptor} LocaleDescriptor
             */
            LocaleDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.LocaleDescriptor)
                    return object;
                var message = new $root.CS.LocaleDescriptor();
                if (object.m_Language != null)
                    message.m_Language = String(object.m_Language);
                if (object.m_Country != null)
                    message.m_Country = String(object.m_Country);
                if (object.m_CharSet != null)
                    message.m_CharSet = String(object.m_CharSet);
                if (object.m_DateFormat != null)
                    message.m_DateFormat = String(object.m_DateFormat);
                if (object.m_TimeFormat != null)
                    message.m_TimeFormat = String(object.m_TimeFormat);
                if (object.m_TimeStampFormat != null)
                    message.m_TimeStampFormat = String(object.m_TimeStampFormat);
                return message;
            };
    
            /**
             * Creates a plain object from a LocaleDescriptor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.LocaleDescriptor
             * @static
             * @param {CS.LocaleDescriptor} message LocaleDescriptor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocaleDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Language = "";
                    object.m_Country = "";
                    object.m_CharSet = "";
                    object.m_DateFormat = "";
                    object.m_TimeFormat = "";
                    object.m_TimeStampFormat = "";
                }
                if (message.m_Language != null && message.hasOwnProperty("m_Language"))
                    object.m_Language = message.m_Language;
                if (message.m_Country != null && message.hasOwnProperty("m_Country"))
                    object.m_Country = message.m_Country;
                if (message.m_CharSet != null && message.hasOwnProperty("m_CharSet"))
                    object.m_CharSet = message.m_CharSet;
                if (message.m_DateFormat != null && message.hasOwnProperty("m_DateFormat"))
                    object.m_DateFormat = message.m_DateFormat;
                if (message.m_TimeFormat != null && message.hasOwnProperty("m_TimeFormat"))
                    object.m_TimeFormat = message.m_TimeFormat;
                if (message.m_TimeStampFormat != null && message.hasOwnProperty("m_TimeStampFormat"))
                    object.m_TimeStampFormat = message.m_TimeStampFormat;
                return object;
            };
    
            /**
             * Converts this LocaleDescriptor to JSON.
             * @function toJSON
             * @memberof CS.LocaleDescriptor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocaleDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LocaleDescriptor;
        })();
    
        /**
         * TransactionType enum.
         * @name CS.TransactionType
         * @enum {number}
         * @property {number} Unknown_TransactionType=0 Unknown_TransactionType value
         * @property {number} None=1 None value
         * @property {number} AutoCommit=2 AutoCommit value
         * @property {number} Transactional=3 Transactional value
         */
        CS.TransactionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_TransactionType"] = 0;
            values[valuesById[1] = "None"] = 1;
            values[valuesById[2] = "AutoCommit"] = 2;
            values[valuesById[3] = "Transactional"] = 3;
            return values;
        })();
    
        /**
         * ConnectivityType enum.
         * @name CS.ConnectivityType
         * @enum {number}
         * @property {number} Unknown_ConnectivityType=0 Unknown_ConnectivityType value
         * @property {number} Relational=1 Relational value
         * @property {number} OLAP=2 OLAP value
         * @property {number} Open=3 Open value
         */
        CS.ConnectivityType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_ConnectivityType"] = 0;
            values[valuesById[1] = "Relational"] = 1;
            values[valuesById[2] = "OLAP"] = 2;
            values[valuesById[3] = "Open"] = 3;
            return values;
        })();
    
        /**
         * CSPropertyType enum.
         * @name CS.CSPropertyType
         * @enum {number}
         * @property {number} Unknown_CSPropertyType=0 Unknown_CSPropertyType value
         * @property {number} Type_Bool=1 Type_Bool value
         * @property {number} Type_String=2 Type_String value
         * @property {number} Type_UInt16=3 Type_UInt16 value
         * @property {number} Type_UInt32=4 Type_UInt32 value
         * @property {number} Type_SInt32=5 Type_SInt32 value
         * @property {number} Type_UInt64=6 Type_UInt64 value
         */
        CS.CSPropertyType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_CSPropertyType"] = 0;
            values[valuesById[1] = "Type_Bool"] = 1;
            values[valuesById[2] = "Type_String"] = 2;
            values[valuesById[3] = "Type_UInt16"] = 3;
            values[valuesById[4] = "Type_UInt32"] = 4;
            values[valuesById[5] = "Type_SInt32"] = 5;
            values[valuesById[6] = "Type_UInt64"] = 6;
            return values;
        })();
    
        CS.CSPropertyValue = (function() {
    
            /**
             * Properties of a CSPropertyValue.
             * @memberof CS
             * @interface ICSPropertyValue
             * @property {boolean|null} [m_BoolValue] CSPropertyValue m_BoolValue
             * @property {string|null} [m_StringValue] CSPropertyValue m_StringValue
             * @property {number|null} [m_SInt32Value] CSPropertyValue m_SInt32Value
             * @property {number|null} [m_UInt16Value] CSPropertyValue m_UInt16Value
             * @property {number|null} [m_UInt32Value] CSPropertyValue m_UInt32Value
             * @property {number|Long|null} [m_UInt64Value] CSPropertyValue m_UInt64Value
             */
    
            /**
             * Constructs a new CSPropertyValue.
             * @memberof CS
             * @classdesc Represents a CSPropertyValue.
             * @implements ICSPropertyValue
             * @constructor
             * @param {CS.ICSPropertyValue=} [properties] Properties to set
             */
            function CSPropertyValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CSPropertyValue m_BoolValue.
             * @member {boolean} m_BoolValue
             * @memberof CS.CSPropertyValue
             * @instance
             */
            CSPropertyValue.prototype.m_BoolValue = false;
    
            /**
             * CSPropertyValue m_StringValue.
             * @member {string} m_StringValue
             * @memberof CS.CSPropertyValue
             * @instance
             */
            CSPropertyValue.prototype.m_StringValue = "";
    
            /**
             * CSPropertyValue m_SInt32Value.
             * @member {number} m_SInt32Value
             * @memberof CS.CSPropertyValue
             * @instance
             */
            CSPropertyValue.prototype.m_SInt32Value = 0;
    
            /**
             * CSPropertyValue m_UInt16Value.
             * @member {number} m_UInt16Value
             * @memberof CS.CSPropertyValue
             * @instance
             */
            CSPropertyValue.prototype.m_UInt16Value = 0;
    
            /**
             * CSPropertyValue m_UInt32Value.
             * @member {number} m_UInt32Value
             * @memberof CS.CSPropertyValue
             * @instance
             */
            CSPropertyValue.prototype.m_UInt32Value = 0;
    
            /**
             * CSPropertyValue m_UInt64Value.
             * @member {number|Long} m_UInt64Value
             * @memberof CS.CSPropertyValue
             * @instance
             */
            CSPropertyValue.prototype.m_UInt64Value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CSPropertyValue CSPropertyValueUnion.
             * @member {"m_BoolValue"|"m_StringValue"|"m_SInt32Value"|"m_UInt16Value"|"m_UInt32Value"|"m_UInt64Value"|undefined} CSPropertyValueUnion
             * @memberof CS.CSPropertyValue
             * @instance
             */
            Object.defineProperty(CSPropertyValue.prototype, "CSPropertyValueUnion", {
                get: $util.oneOfGetter($oneOfFields = ["m_BoolValue", "m_StringValue", "m_SInt32Value", "m_UInt16Value", "m_UInt32Value", "m_UInt64Value"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CSPropertyValue instance using the specified properties.
             * @function create
             * @memberof CS.CSPropertyValue
             * @static
             * @param {CS.ICSPropertyValue=} [properties] Properties to set
             * @returns {CS.CSPropertyValue} CSPropertyValue instance
             */
            CSPropertyValue.create = function create(properties) {
                return new CSPropertyValue(properties);
            };
    
            /**
             * Encodes the specified CSPropertyValue message. Does not implicitly {@link CS.CSPropertyValue.verify|verify} messages.
             * @function encode
             * @memberof CS.CSPropertyValue
             * @static
             * @param {CS.ICSPropertyValue} message CSPropertyValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CSPropertyValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_BoolValue != null && Object.hasOwnProperty.call(message, "m_BoolValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.m_BoolValue);
                if (message.m_StringValue != null && Object.hasOwnProperty.call(message, "m_StringValue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_StringValue);
                if (message.m_SInt32Value != null && Object.hasOwnProperty.call(message, "m_SInt32Value"))
                    writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.m_SInt32Value);
                if (message.m_UInt16Value != null && Object.hasOwnProperty.call(message, "m_UInt16Value"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.m_UInt16Value);
                if (message.m_UInt32Value != null && Object.hasOwnProperty.call(message, "m_UInt32Value"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.m_UInt32Value);
                if (message.m_UInt64Value != null && Object.hasOwnProperty.call(message, "m_UInt64Value"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.m_UInt64Value);
                return writer;
            };
    
            /**
             * Encodes the specified CSPropertyValue message, length delimited. Does not implicitly {@link CS.CSPropertyValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.CSPropertyValue
             * @static
             * @param {CS.ICSPropertyValue} message CSPropertyValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CSPropertyValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CSPropertyValue message from the specified reader or buffer.
             * @function decode
             * @memberof CS.CSPropertyValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.CSPropertyValue} CSPropertyValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CSPropertyValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.CSPropertyValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_BoolValue = reader.bool();
                        break;
                    case 2:
                        message.m_StringValue = reader.string();
                        break;
                    case 3:
                        message.m_SInt32Value = reader.sint32();
                        break;
                    case 4:
                        message.m_UInt16Value = reader.uint32();
                        break;
                    case 5:
                        message.m_UInt32Value = reader.uint32();
                        break;
                    case 6:
                        message.m_UInt64Value = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CSPropertyValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.CSPropertyValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.CSPropertyValue} CSPropertyValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CSPropertyValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CSPropertyValue message.
             * @function verify
             * @memberof CS.CSPropertyValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CSPropertyValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.m_BoolValue != null && message.hasOwnProperty("m_BoolValue")) {
                    properties.CSPropertyValueUnion = 1;
                    if (typeof message.m_BoolValue !== "boolean")
                        return "m_BoolValue: boolean expected";
                }
                if (message.m_StringValue != null && message.hasOwnProperty("m_StringValue")) {
                    if (properties.CSPropertyValueUnion === 1)
                        return "CSPropertyValueUnion: multiple values";
                    properties.CSPropertyValueUnion = 1;
                    if (!$util.isString(message.m_StringValue))
                        return "m_StringValue: string expected";
                }
                if (message.m_SInt32Value != null && message.hasOwnProperty("m_SInt32Value")) {
                    if (properties.CSPropertyValueUnion === 1)
                        return "CSPropertyValueUnion: multiple values";
                    properties.CSPropertyValueUnion = 1;
                    if (!$util.isInteger(message.m_SInt32Value))
                        return "m_SInt32Value: integer expected";
                }
                if (message.m_UInt16Value != null && message.hasOwnProperty("m_UInt16Value")) {
                    if (properties.CSPropertyValueUnion === 1)
                        return "CSPropertyValueUnion: multiple values";
                    properties.CSPropertyValueUnion = 1;
                    if (!$util.isInteger(message.m_UInt16Value))
                        return "m_UInt16Value: integer expected";
                }
                if (message.m_UInt32Value != null && message.hasOwnProperty("m_UInt32Value")) {
                    if (properties.CSPropertyValueUnion === 1)
                        return "CSPropertyValueUnion: multiple values";
                    properties.CSPropertyValueUnion = 1;
                    if (!$util.isInteger(message.m_UInt32Value))
                        return "m_UInt32Value: integer expected";
                }
                if (message.m_UInt64Value != null && message.hasOwnProperty("m_UInt64Value")) {
                    if (properties.CSPropertyValueUnion === 1)
                        return "CSPropertyValueUnion: multiple values";
                    properties.CSPropertyValueUnion = 1;
                    if (!$util.isInteger(message.m_UInt64Value) && !(message.m_UInt64Value && $util.isInteger(message.m_UInt64Value.low) && $util.isInteger(message.m_UInt64Value.high)))
                        return "m_UInt64Value: integer|Long expected";
                }
                return null;
            };
    
            /**
             * Creates a CSPropertyValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.CSPropertyValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.CSPropertyValue} CSPropertyValue
             */
            CSPropertyValue.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.CSPropertyValue)
                    return object;
                var message = new $root.CS.CSPropertyValue();
                if (object.m_BoolValue != null)
                    message.m_BoolValue = Boolean(object.m_BoolValue);
                if (object.m_StringValue != null)
                    message.m_StringValue = String(object.m_StringValue);
                if (object.m_SInt32Value != null)
                    message.m_SInt32Value = object.m_SInt32Value | 0;
                if (object.m_UInt16Value != null)
                    message.m_UInt16Value = object.m_UInt16Value >>> 0;
                if (object.m_UInt32Value != null)
                    message.m_UInt32Value = object.m_UInt32Value >>> 0;
                if (object.m_UInt64Value != null)
                    if ($util.Long)
                        (message.m_UInt64Value = $util.Long.fromValue(object.m_UInt64Value)).unsigned = true;
                    else if (typeof object.m_UInt64Value === "string")
                        message.m_UInt64Value = parseInt(object.m_UInt64Value, 10);
                    else if (typeof object.m_UInt64Value === "number")
                        message.m_UInt64Value = object.m_UInt64Value;
                    else if (typeof object.m_UInt64Value === "object")
                        message.m_UInt64Value = new $util.LongBits(object.m_UInt64Value.low >>> 0, object.m_UInt64Value.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a CSPropertyValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.CSPropertyValue
             * @static
             * @param {CS.CSPropertyValue} message CSPropertyValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CSPropertyValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.m_BoolValue != null && message.hasOwnProperty("m_BoolValue")) {
                    object.m_BoolValue = message.m_BoolValue;
                    if (options.oneofs)
                        object.CSPropertyValueUnion = "m_BoolValue";
                }
                if (message.m_StringValue != null && message.hasOwnProperty("m_StringValue")) {
                    object.m_StringValue = message.m_StringValue;
                    if (options.oneofs)
                        object.CSPropertyValueUnion = "m_StringValue";
                }
                if (message.m_SInt32Value != null && message.hasOwnProperty("m_SInt32Value")) {
                    object.m_SInt32Value = message.m_SInt32Value;
                    if (options.oneofs)
                        object.CSPropertyValueUnion = "m_SInt32Value";
                }
                if (message.m_UInt16Value != null && message.hasOwnProperty("m_UInt16Value")) {
                    object.m_UInt16Value = message.m_UInt16Value;
                    if (options.oneofs)
                        object.CSPropertyValueUnion = "m_UInt16Value";
                }
                if (message.m_UInt32Value != null && message.hasOwnProperty("m_UInt32Value")) {
                    object.m_UInt32Value = message.m_UInt32Value;
                    if (options.oneofs)
                        object.CSPropertyValueUnion = "m_UInt32Value";
                }
                if (message.m_UInt64Value != null && message.hasOwnProperty("m_UInt64Value")) {
                    if (typeof message.m_UInt64Value === "number")
                        object.m_UInt64Value = options.longs === String ? String(message.m_UInt64Value) : message.m_UInt64Value;
                    else
                        object.m_UInt64Value = options.longs === String ? $util.Long.prototype.toString.call(message.m_UInt64Value) : options.longs === Number ? new $util.LongBits(message.m_UInt64Value.low >>> 0, message.m_UInt64Value.high >>> 0).toNumber(true) : message.m_UInt64Value;
                    if (options.oneofs)
                        object.CSPropertyValueUnion = "m_UInt64Value";
                }
                return object;
            };
    
            /**
             * Converts this CSPropertyValue to JSON.
             * @function toJSON
             * @memberof CS.CSPropertyValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CSPropertyValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CSPropertyValue;
        })();
    
        CS.CSProperty = (function() {
    
            /**
             * Properties of a CSProperty.
             * @memberof CS
             * @interface ICSProperty
             * @property {string|null} [m_Name] CSProperty m_Name
             * @property {CS.ICSPropertyValue|null} [m_Value] CSProperty m_Value
             * @property {CS.CSPropertyType|null} [m_Type] CSProperty m_Type
             * @property {number|null} [m_Access] CSProperty m_Access
             */
    
            /**
             * Constructs a new CSProperty.
             * @memberof CS
             * @classdesc Represents a CSProperty.
             * @implements ICSProperty
             * @constructor
             * @param {CS.ICSProperty=} [properties] Properties to set
             */
            function CSProperty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CSProperty m_Name.
             * @member {string} m_Name
             * @memberof CS.CSProperty
             * @instance
             */
            CSProperty.prototype.m_Name = "";
    
            /**
             * CSProperty m_Value.
             * @member {CS.ICSPropertyValue|null|undefined} m_Value
             * @memberof CS.CSProperty
             * @instance
             */
            CSProperty.prototype.m_Value = null;
    
            /**
             * CSProperty m_Type.
             * @member {CS.CSPropertyType} m_Type
             * @memberof CS.CSProperty
             * @instance
             */
            CSProperty.prototype.m_Type = 0;
    
            /**
             * CSProperty m_Access.
             * @member {number} m_Access
             * @memberof CS.CSProperty
             * @instance
             */
            CSProperty.prototype.m_Access = 0;
    
            /**
             * Creates a new CSProperty instance using the specified properties.
             * @function create
             * @memberof CS.CSProperty
             * @static
             * @param {CS.ICSProperty=} [properties] Properties to set
             * @returns {CS.CSProperty} CSProperty instance
             */
            CSProperty.create = function create(properties) {
                return new CSProperty(properties);
            };
    
            /**
             * Encodes the specified CSProperty message. Does not implicitly {@link CS.CSProperty.verify|verify} messages.
             * @function encode
             * @memberof CS.CSProperty
             * @static
             * @param {CS.ICSProperty} message CSProperty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CSProperty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Name);
                if (message.m_Value != null && Object.hasOwnProperty.call(message, "m_Value"))
                    $root.CS.CSPropertyValue.encode(message.m_Value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.m_Type != null && Object.hasOwnProperty.call(message, "m_Type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.m_Type);
                if (message.m_Access != null && Object.hasOwnProperty.call(message, "m_Access"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.m_Access);
                return writer;
            };
    
            /**
             * Encodes the specified CSProperty message, length delimited. Does not implicitly {@link CS.CSProperty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.CSProperty
             * @static
             * @param {CS.ICSProperty} message CSProperty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CSProperty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CSProperty message from the specified reader or buffer.
             * @function decode
             * @memberof CS.CSProperty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.CSProperty} CSProperty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CSProperty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.CSProperty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Name = reader.string();
                        break;
                    case 2:
                        message.m_Value = $root.CS.CSPropertyValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.m_Type = reader.int32();
                        break;
                    case 4:
                        message.m_Access = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CSProperty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.CSProperty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.CSProperty} CSProperty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CSProperty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CSProperty message.
             * @function verify
             * @memberof CS.CSProperty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CSProperty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_Value != null && message.hasOwnProperty("m_Value")) {
                    var error = $root.CS.CSPropertyValue.verify(message.m_Value);
                    if (error)
                        return "m_Value." + error;
                }
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    switch (message.m_Type) {
                    default:
                        return "m_Type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.m_Access != null && message.hasOwnProperty("m_Access"))
                    if (!$util.isInteger(message.m_Access))
                        return "m_Access: integer expected";
                return null;
            };
    
            /**
             * Creates a CSProperty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.CSProperty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.CSProperty} CSProperty
             */
            CSProperty.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.CSProperty)
                    return object;
                var message = new $root.CS.CSProperty();
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                if (object.m_Value != null) {
                    if (typeof object.m_Value !== "object")
                        throw TypeError(".CS.CSProperty.m_Value: object expected");
                    message.m_Value = $root.CS.CSPropertyValue.fromObject(object.m_Value);
                }
                switch (object.m_Type) {
                case "Unknown_CSPropertyType":
                case 0:
                    message.m_Type = 0;
                    break;
                case "Type_Bool":
                case 1:
                    message.m_Type = 1;
                    break;
                case "Type_String":
                case 2:
                    message.m_Type = 2;
                    break;
                case "Type_UInt16":
                case 3:
                    message.m_Type = 3;
                    break;
                case "Type_UInt32":
                case 4:
                    message.m_Type = 4;
                    break;
                case "Type_SInt32":
                case 5:
                    message.m_Type = 5;
                    break;
                case "Type_UInt64":
                case 6:
                    message.m_Type = 6;
                    break;
                }
                if (object.m_Access != null)
                    message.m_Access = object.m_Access >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a CSProperty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.CSProperty
             * @static
             * @param {CS.CSProperty} message CSProperty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CSProperty.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Name = "";
                    object.m_Value = null;
                    object.m_Type = options.enums === String ? "Unknown_CSPropertyType" : 0;
                    object.m_Access = 0;
                }
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    object.m_Value = $root.CS.CSPropertyValue.toObject(message.m_Value, options);
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    object.m_Type = options.enums === String ? $root.CS.CSPropertyType[message.m_Type] : message.m_Type;
                if (message.m_Access != null && message.hasOwnProperty("m_Access"))
                    object.m_Access = message.m_Access;
                return object;
            };
    
            /**
             * Converts this CSProperty to JSON.
             * @function toJSON
             * @memberof CS.CSProperty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CSProperty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CSProperty;
        })();
    
        CS.PropertySet = (function() {
    
            /**
             * Properties of a PropertySet.
             * @memberof CS
             * @interface IPropertySet
             * @property {number|null} [m_Mask] PropertySet m_Mask
             * @property {Array.<CS.ICSProperty>|null} [m_Properties] PropertySet m_Properties
             * @property {Array.<CS.CType>|null} [m_SQLBindings] PropertySet m_SQLBindings
             * @property {CS.ILocaleDescriptor|null} [m_Locale] PropertySet m_Locale
             */
    
            /**
             * Constructs a new PropertySet.
             * @memberof CS
             * @classdesc Represents a PropertySet.
             * @implements IPropertySet
             * @constructor
             * @param {CS.IPropertySet=} [properties] Properties to set
             */
            function PropertySet(properties) {
                this.m_Properties = [];
                this.m_SQLBindings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PropertySet m_Mask.
             * @member {number} m_Mask
             * @memberof CS.PropertySet
             * @instance
             */
            PropertySet.prototype.m_Mask = 0;
    
            /**
             * PropertySet m_Properties.
             * @member {Array.<CS.ICSProperty>} m_Properties
             * @memberof CS.PropertySet
             * @instance
             */
            PropertySet.prototype.m_Properties = $util.emptyArray;
    
            /**
             * PropertySet m_SQLBindings.
             * @member {Array.<CS.CType>} m_SQLBindings
             * @memberof CS.PropertySet
             * @instance
             */
            PropertySet.prototype.m_SQLBindings = $util.emptyArray;
    
            /**
             * PropertySet m_Locale.
             * @member {CS.ILocaleDescriptor|null|undefined} m_Locale
             * @memberof CS.PropertySet
             * @instance
             */
            PropertySet.prototype.m_Locale = null;
    
            /**
             * Creates a new PropertySet instance using the specified properties.
             * @function create
             * @memberof CS.PropertySet
             * @static
             * @param {CS.IPropertySet=} [properties] Properties to set
             * @returns {CS.PropertySet} PropertySet instance
             */
            PropertySet.create = function create(properties) {
                return new PropertySet(properties);
            };
    
            /**
             * Encodes the specified PropertySet message. Does not implicitly {@link CS.PropertySet.verify|verify} messages.
             * @function encode
             * @memberof CS.PropertySet
             * @static
             * @param {CS.IPropertySet} message PropertySet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropertySet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Mask != null && Object.hasOwnProperty.call(message, "m_Mask"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.m_Mask);
                if (message.m_Properties != null && message.m_Properties.length)
                    for (var i = 0; i < message.m_Properties.length; ++i)
                        $root.CS.CSProperty.encode(message.m_Properties[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.m_SQLBindings != null && message.m_SQLBindings.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.m_SQLBindings.length; ++i)
                        writer.int32(message.m_SQLBindings[i]);
                    writer.ldelim();
                }
                if (message.m_Locale != null && Object.hasOwnProperty.call(message, "m_Locale"))
                    $root.CS.LocaleDescriptor.encode(message.m_Locale, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PropertySet message, length delimited. Does not implicitly {@link CS.PropertySet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.PropertySet
             * @static
             * @param {CS.IPropertySet} message PropertySet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropertySet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PropertySet message from the specified reader or buffer.
             * @function decode
             * @memberof CS.PropertySet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.PropertySet} PropertySet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropertySet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.PropertySet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Mask = reader.uint32();
                        break;
                    case 2:
                        if (!(message.m_Properties && message.m_Properties.length))
                            message.m_Properties = [];
                        message.m_Properties.push($root.CS.CSProperty.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.m_SQLBindings && message.m_SQLBindings.length))
                            message.m_SQLBindings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.m_SQLBindings.push(reader.int32());
                        } else
                            message.m_SQLBindings.push(reader.int32());
                        break;
                    case 4:
                        message.m_Locale = $root.CS.LocaleDescriptor.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PropertySet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.PropertySet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.PropertySet} PropertySet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropertySet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PropertySet message.
             * @function verify
             * @memberof CS.PropertySet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PropertySet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Mask != null && message.hasOwnProperty("m_Mask"))
                    if (!$util.isInteger(message.m_Mask))
                        return "m_Mask: integer expected";
                if (message.m_Properties != null && message.hasOwnProperty("m_Properties")) {
                    if (!Array.isArray(message.m_Properties))
                        return "m_Properties: array expected";
                    for (var i = 0; i < message.m_Properties.length; ++i) {
                        var error = $root.CS.CSProperty.verify(message.m_Properties[i]);
                        if (error)
                            return "m_Properties." + error;
                    }
                }
                if (message.m_SQLBindings != null && message.hasOwnProperty("m_SQLBindings")) {
                    if (!Array.isArray(message.m_SQLBindings))
                        return "m_SQLBindings: array expected";
                    for (var i = 0; i < message.m_SQLBindings.length; ++i)
                        switch (message.m_SQLBindings[i]) {
                        default:
                            return "m_SQLBindings: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                            break;
                        }
                }
                if (message.m_Locale != null && message.hasOwnProperty("m_Locale")) {
                    var error = $root.CS.LocaleDescriptor.verify(message.m_Locale);
                    if (error)
                        return "m_Locale." + error;
                }
                return null;
            };
    
            /**
             * Creates a PropertySet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.PropertySet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.PropertySet} PropertySet
             */
            PropertySet.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.PropertySet)
                    return object;
                var message = new $root.CS.PropertySet();
                if (object.m_Mask != null)
                    message.m_Mask = object.m_Mask >>> 0;
                if (object.m_Properties) {
                    if (!Array.isArray(object.m_Properties))
                        throw TypeError(".CS.PropertySet.m_Properties: array expected");
                    message.m_Properties = [];
                    for (var i = 0; i < object.m_Properties.length; ++i) {
                        if (typeof object.m_Properties[i] !== "object")
                            throw TypeError(".CS.PropertySet.m_Properties: object expected");
                        message.m_Properties[i] = $root.CS.CSProperty.fromObject(object.m_Properties[i]);
                    }
                }
                if (object.m_SQLBindings) {
                    if (!Array.isArray(object.m_SQLBindings))
                        throw TypeError(".CS.PropertySet.m_SQLBindings: array expected");
                    message.m_SQLBindings = [];
                    for (var i = 0; i < object.m_SQLBindings.length; ++i)
                        switch (object.m_SQLBindings[i]) {
                        default:
                        case "Unknown_CType":
                        case 0:
                            message.m_SQLBindings[i] = 0;
                            break;
                        case "C_Default":
                        case 1:
                            message.m_SQLBindings[i] = 1;
                            break;
                        case "C_Char":
                        case 2:
                            message.m_SQLBindings[i] = 2;
                            break;
                        case "C_String":
                        case 3:
                            message.m_SQLBindings[i] = 3;
                            break;
                        case "C_UTF8Char":
                        case 4:
                            message.m_SQLBindings[i] = 4;
                            break;
                        case "C_UTF8String":
                        case 5:
                            message.m_SQLBindings[i] = 5;
                            break;
                        case "C_UCS2Char":
                        case 6:
                            message.m_SQLBindings[i] = 6;
                            break;
                        case "C_UCS2String":
                        case 7:
                            message.m_SQLBindings[i] = 7;
                            break;
                        case "C_Binary":
                        case 8:
                            message.m_SQLBindings[i] = 8;
                            break;
                        case "C_UInt8":
                        case 9:
                            message.m_SQLBindings[i] = 9;
                            break;
                        case "C_SInt8":
                        case 10:
                            message.m_SQLBindings[i] = 10;
                            break;
                        case "C_UInt16":
                        case 11:
                            message.m_SQLBindings[i] = 11;
                            break;
                        case "C_SInt16":
                        case 12:
                            message.m_SQLBindings[i] = 12;
                            break;
                        case "C_UInt32":
                        case 13:
                            message.m_SQLBindings[i] = 13;
                            break;
                        case "C_SInt32":
                        case 14:
                            message.m_SQLBindings[i] = 14;
                            break;
                        case "C_UInt64":
                        case 15:
                            message.m_SQLBindings[i] = 15;
                            break;
                        case "C_SInt64":
                        case 16:
                            message.m_SQLBindings[i] = 16;
                            break;
                        case "C_Float32":
                        case 17:
                            message.m_SQLBindings[i] = 17;
                            break;
                        case "C_Float64":
                        case 18:
                            message.m_SQLBindings[i] = 18;
                            break;
                        case "C_CTime":
                        case 19:
                            message.m_SQLBindings[i] = 19;
                            break;
                        case "C_CDate":
                        case 20:
                            message.m_SQLBindings[i] = 20;
                            break;
                        case "C_CTimeStamp":
                        case 21:
                            message.m_SQLBindings[i] = 21;
                            break;
                        case "C_RefCursor":
                        case 22:
                            message.m_SQLBindings[i] = 22;
                            break;
                        case "C_Blob":
                        case 23:
                            message.m_SQLBindings[i] = 23;
                            break;
                        case "C_Clob":
                        case 24:
                            message.m_SQLBindings[i] = 24;
                            break;
                        case "C_Decimal":
                        case 25:
                            message.m_SQLBindings[i] = 25;
                            break;
                        }
                }
                if (object.m_Locale != null) {
                    if (typeof object.m_Locale !== "object")
                        throw TypeError(".CS.PropertySet.m_Locale: object expected");
                    message.m_Locale = $root.CS.LocaleDescriptor.fromObject(object.m_Locale);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PropertySet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.PropertySet
             * @static
             * @param {CS.PropertySet} message PropertySet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PropertySet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.m_Properties = [];
                    object.m_SQLBindings = [];
                }
                if (options.defaults) {
                    object.m_Mask = 0;
                    object.m_Locale = null;
                }
                if (message.m_Mask != null && message.hasOwnProperty("m_Mask"))
                    object.m_Mask = message.m_Mask;
                if (message.m_Properties && message.m_Properties.length) {
                    object.m_Properties = [];
                    for (var j = 0; j < message.m_Properties.length; ++j)
                        object.m_Properties[j] = $root.CS.CSProperty.toObject(message.m_Properties[j], options);
                }
                if (message.m_SQLBindings && message.m_SQLBindings.length) {
                    object.m_SQLBindings = [];
                    for (var j = 0; j < message.m_SQLBindings.length; ++j)
                        object.m_SQLBindings[j] = options.enums === String ? $root.CS.CType[message.m_SQLBindings[j]] : message.m_SQLBindings[j];
                }
                if (message.m_Locale != null && message.hasOwnProperty("m_Locale"))
                    object.m_Locale = $root.CS.LocaleDescriptor.toObject(message.m_Locale, options);
                return object;
            };
    
            /**
             * Converts this PropertySet to JSON.
             * @function toJSON
             * @memberof CS.PropertySet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PropertySet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PropertySet;
        })();
    
        /**
         * ArgumentTag enum.
         * @name CS.ArgumentTag
         * @enum {number}
         * @property {number} Unknown_ArgumentTag=0 Unknown_ArgumentTag value
         * @property {number} A_String=1 A_String value
         * @property {number} A_QuotedString=2 A_QuotedString value
         * @property {number} A_UTF8String=3 A_UTF8String value
         * @property {number} A_QuotedUTF8String=4 A_QuotedUTF8String value
         * @property {number} A_SInt32=5 A_SInt32 value
         * @property {number} A_UInt32=6 A_UInt32 value
         */
        CS.ArgumentTag = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_ArgumentTag"] = 0;
            values[valuesById[1] = "A_String"] = 1;
            values[valuesById[2] = "A_QuotedString"] = 2;
            values[valuesById[3] = "A_UTF8String"] = 3;
            values[valuesById[4] = "A_QuotedUTF8String"] = 4;
            values[valuesById[5] = "A_SInt32"] = 5;
            values[valuesById[6] = "A_UInt32"] = 6;
            return values;
        })();
    
        CS.Argument = (function() {
    
            /**
             * Properties of an Argument.
             * @memberof CS
             * @interface IArgument
             * @property {string|null} [m_String] Argument m_String
             * @property {string|null} [m_QuotedString] Argument m_QuotedString
             * @property {string|null} [m_UTF8String] Argument m_UTF8String
             * @property {string|null} [m_QuotedUTF8String] Argument m_QuotedUTF8String
             * @property {number|null} [m_UInt32] Argument m_UInt32
             * @property {number|null} [m_SInt32] Argument m_SInt32
             */
    
            /**
             * Constructs a new Argument.
             * @memberof CS
             * @classdesc Represents an Argument.
             * @implements IArgument
             * @constructor
             * @param {CS.IArgument=} [properties] Properties to set
             */
            function Argument(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Argument m_String.
             * @member {string} m_String
             * @memberof CS.Argument
             * @instance
             */
            Argument.prototype.m_String = "";
    
            /**
             * Argument m_QuotedString.
             * @member {string} m_QuotedString
             * @memberof CS.Argument
             * @instance
             */
            Argument.prototype.m_QuotedString = "";
    
            /**
             * Argument m_UTF8String.
             * @member {string} m_UTF8String
             * @memberof CS.Argument
             * @instance
             */
            Argument.prototype.m_UTF8String = "";
    
            /**
             * Argument m_QuotedUTF8String.
             * @member {string} m_QuotedUTF8String
             * @memberof CS.Argument
             * @instance
             */
            Argument.prototype.m_QuotedUTF8String = "";
    
            /**
             * Argument m_UInt32.
             * @member {number} m_UInt32
             * @memberof CS.Argument
             * @instance
             */
            Argument.prototype.m_UInt32 = 0;
    
            /**
             * Argument m_SInt32.
             * @member {number} m_SInt32
             * @memberof CS.Argument
             * @instance
             */
            Argument.prototype.m_SInt32 = 0;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Argument ArgumentUnion.
             * @member {"m_String"|"m_QuotedString"|"m_UTF8String"|"m_QuotedUTF8String"|"m_UInt32"|"m_SInt32"|undefined} ArgumentUnion
             * @memberof CS.Argument
             * @instance
             */
            Object.defineProperty(Argument.prototype, "ArgumentUnion", {
                get: $util.oneOfGetter($oneOfFields = ["m_String", "m_QuotedString", "m_UTF8String", "m_QuotedUTF8String", "m_UInt32", "m_SInt32"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Argument instance using the specified properties.
             * @function create
             * @memberof CS.Argument
             * @static
             * @param {CS.IArgument=} [properties] Properties to set
             * @returns {CS.Argument} Argument instance
             */
            Argument.create = function create(properties) {
                return new Argument(properties);
            };
    
            /**
             * Encodes the specified Argument message. Does not implicitly {@link CS.Argument.verify|verify} messages.
             * @function encode
             * @memberof CS.Argument
             * @static
             * @param {CS.IArgument} message Argument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Argument.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_String != null && Object.hasOwnProperty.call(message, "m_String"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_String);
                if (message.m_QuotedString != null && Object.hasOwnProperty.call(message, "m_QuotedString"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_QuotedString);
                if (message.m_UTF8String != null && Object.hasOwnProperty.call(message, "m_UTF8String"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_UTF8String);
                if (message.m_QuotedUTF8String != null && Object.hasOwnProperty.call(message, "m_QuotedUTF8String"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_QuotedUTF8String);
                if (message.m_UInt32 != null && Object.hasOwnProperty.call(message, "m_UInt32"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.m_UInt32);
                if (message.m_SInt32 != null && Object.hasOwnProperty.call(message, "m_SInt32"))
                    writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.m_SInt32);
                return writer;
            };
    
            /**
             * Encodes the specified Argument message, length delimited. Does not implicitly {@link CS.Argument.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Argument
             * @static
             * @param {CS.IArgument} message Argument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Argument.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Argument message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Argument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Argument} Argument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Argument.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Argument();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_String = reader.string();
                        break;
                    case 2:
                        message.m_QuotedString = reader.string();
                        break;
                    case 3:
                        message.m_UTF8String = reader.string();
                        break;
                    case 4:
                        message.m_QuotedUTF8String = reader.string();
                        break;
                    case 5:
                        message.m_UInt32 = reader.uint32();
                        break;
                    case 6:
                        message.m_SInt32 = reader.sint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Argument message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Argument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Argument} Argument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Argument.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Argument message.
             * @function verify
             * @memberof CS.Argument
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Argument.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.m_String != null && message.hasOwnProperty("m_String")) {
                    properties.ArgumentUnion = 1;
                    if (!$util.isString(message.m_String))
                        return "m_String: string expected";
                }
                if (message.m_QuotedString != null && message.hasOwnProperty("m_QuotedString")) {
                    if (properties.ArgumentUnion === 1)
                        return "ArgumentUnion: multiple values";
                    properties.ArgumentUnion = 1;
                    if (!$util.isString(message.m_QuotedString))
                        return "m_QuotedString: string expected";
                }
                if (message.m_UTF8String != null && message.hasOwnProperty("m_UTF8String")) {
                    if (properties.ArgumentUnion === 1)
                        return "ArgumentUnion: multiple values";
                    properties.ArgumentUnion = 1;
                    if (!$util.isString(message.m_UTF8String))
                        return "m_UTF8String: string expected";
                }
                if (message.m_QuotedUTF8String != null && message.hasOwnProperty("m_QuotedUTF8String")) {
                    if (properties.ArgumentUnion === 1)
                        return "ArgumentUnion: multiple values";
                    properties.ArgumentUnion = 1;
                    if (!$util.isString(message.m_QuotedUTF8String))
                        return "m_QuotedUTF8String: string expected";
                }
                if (message.m_UInt32 != null && message.hasOwnProperty("m_UInt32")) {
                    if (properties.ArgumentUnion === 1)
                        return "ArgumentUnion: multiple values";
                    properties.ArgumentUnion = 1;
                    if (!$util.isInteger(message.m_UInt32))
                        return "m_UInt32: integer expected";
                }
                if (message.m_SInt32 != null && message.hasOwnProperty("m_SInt32")) {
                    if (properties.ArgumentUnion === 1)
                        return "ArgumentUnion: multiple values";
                    properties.ArgumentUnion = 1;
                    if (!$util.isInteger(message.m_SInt32))
                        return "m_SInt32: integer expected";
                }
                return null;
            };
    
            /**
             * Creates an Argument message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Argument
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Argument} Argument
             */
            Argument.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Argument)
                    return object;
                var message = new $root.CS.Argument();
                if (object.m_String != null)
                    message.m_String = String(object.m_String);
                if (object.m_QuotedString != null)
                    message.m_QuotedString = String(object.m_QuotedString);
                if (object.m_UTF8String != null)
                    message.m_UTF8String = String(object.m_UTF8String);
                if (object.m_QuotedUTF8String != null)
                    message.m_QuotedUTF8String = String(object.m_QuotedUTF8String);
                if (object.m_UInt32 != null)
                    message.m_UInt32 = object.m_UInt32 >>> 0;
                if (object.m_SInt32 != null)
                    message.m_SInt32 = object.m_SInt32 | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Argument message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Argument
             * @static
             * @param {CS.Argument} message Argument
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Argument.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.m_String != null && message.hasOwnProperty("m_String")) {
                    object.m_String = message.m_String;
                    if (options.oneofs)
                        object.ArgumentUnion = "m_String";
                }
                if (message.m_QuotedString != null && message.hasOwnProperty("m_QuotedString")) {
                    object.m_QuotedString = message.m_QuotedString;
                    if (options.oneofs)
                        object.ArgumentUnion = "m_QuotedString";
                }
                if (message.m_UTF8String != null && message.hasOwnProperty("m_UTF8String")) {
                    object.m_UTF8String = message.m_UTF8String;
                    if (options.oneofs)
                        object.ArgumentUnion = "m_UTF8String";
                }
                if (message.m_QuotedUTF8String != null && message.hasOwnProperty("m_QuotedUTF8String")) {
                    object.m_QuotedUTF8String = message.m_QuotedUTF8String;
                    if (options.oneofs)
                        object.ArgumentUnion = "m_QuotedUTF8String";
                }
                if (message.m_UInt32 != null && message.hasOwnProperty("m_UInt32")) {
                    object.m_UInt32 = message.m_UInt32;
                    if (options.oneofs)
                        object.ArgumentUnion = "m_UInt32";
                }
                if (message.m_SInt32 != null && message.hasOwnProperty("m_SInt32")) {
                    object.m_SInt32 = message.m_SInt32;
                    if (options.oneofs)
                        object.ArgumentUnion = "m_SInt32";
                }
                return object;
            };
    
            /**
             * Converts this Argument to JSON.
             * @function toJSON
             * @memberof CS.Argument
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Argument.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Argument;
        })();
    
        CS.SeqString = (function() {
    
            /**
             * Properties of a SeqString.
             * @memberof CS
             * @interface ISeqString
             * @property {Array.<string>|null} [values] SeqString values
             */
    
            /**
             * Constructs a new SeqString.
             * @memberof CS
             * @classdesc Represents a SeqString.
             * @implements ISeqString
             * @constructor
             * @param {CS.ISeqString=} [properties] Properties to set
             */
            function SeqString(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqString values.
             * @member {Array.<string>} values
             * @memberof CS.SeqString
             * @instance
             */
            SeqString.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqString instance using the specified properties.
             * @function create
             * @memberof CS.SeqString
             * @static
             * @param {CS.ISeqString=} [properties] Properties to set
             * @returns {CS.SeqString} SeqString instance
             */
            SeqString.create = function create(properties) {
                return new SeqString(properties);
            };
    
            /**
             * Encodes the specified SeqString message. Does not implicitly {@link CS.SeqString.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqString
             * @static
             * @param {CS.ISeqString} message SeqString message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqString.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.values[i]);
                return writer;
            };
    
            /**
             * Encodes the specified SeqString message, length delimited. Does not implicitly {@link CS.SeqString.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqString
             * @static
             * @param {CS.ISeqString} message SeqString message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqString.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqString message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqString
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqString} SeqString
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqString.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqString();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqString message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqString
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqString} SeqString
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqString.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqString message.
             * @function verify
             * @memberof CS.SeqString
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqString.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isString(message.values[i]))
                            return "values: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqString message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqString
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqString} SeqString
             */
            SeqString.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqString)
                    return object;
                var message = new $root.CS.SeqString();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqString.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = String(object.values[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqString message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqString
             * @static
             * @param {CS.SeqString} message SeqString
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqString.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqString to JSON.
             * @function toJSON
             * @memberof CS.SeqString
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqString.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqString;
        })();
    
        CS.SeqUTF8String = (function() {
    
            /**
             * Properties of a SeqUTF8String.
             * @memberof CS
             * @interface ISeqUTF8String
             * @property {Array.<string>|null} [values] SeqUTF8String values
             */
    
            /**
             * Constructs a new SeqUTF8String.
             * @memberof CS
             * @classdesc Represents a SeqUTF8String.
             * @implements ISeqUTF8String
             * @constructor
             * @param {CS.ISeqUTF8String=} [properties] Properties to set
             */
            function SeqUTF8String(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqUTF8String values.
             * @member {Array.<string>} values
             * @memberof CS.SeqUTF8String
             * @instance
             */
            SeqUTF8String.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqUTF8String instance using the specified properties.
             * @function create
             * @memberof CS.SeqUTF8String
             * @static
             * @param {CS.ISeqUTF8String=} [properties] Properties to set
             * @returns {CS.SeqUTF8String} SeqUTF8String instance
             */
            SeqUTF8String.create = function create(properties) {
                return new SeqUTF8String(properties);
            };
    
            /**
             * Encodes the specified SeqUTF8String message. Does not implicitly {@link CS.SeqUTF8String.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqUTF8String
             * @static
             * @param {CS.ISeqUTF8String} message SeqUTF8String message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUTF8String.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.values[i]);
                return writer;
            };
    
            /**
             * Encodes the specified SeqUTF8String message, length delimited. Does not implicitly {@link CS.SeqUTF8String.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqUTF8String
             * @static
             * @param {CS.ISeqUTF8String} message SeqUTF8String message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUTF8String.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqUTF8String message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqUTF8String
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqUTF8String} SeqUTF8String
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUTF8String.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqUTF8String();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqUTF8String message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqUTF8String
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqUTF8String} SeqUTF8String
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUTF8String.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqUTF8String message.
             * @function verify
             * @memberof CS.SeqUTF8String
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqUTF8String.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isString(message.values[i]))
                            return "values: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqUTF8String message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqUTF8String
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqUTF8String} SeqUTF8String
             */
            SeqUTF8String.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqUTF8String)
                    return object;
                var message = new $root.CS.SeqUTF8String();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqUTF8String.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = String(object.values[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqUTF8String message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqUTF8String
             * @static
             * @param {CS.SeqUTF8String} message SeqUTF8String
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqUTF8String.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqUTF8String to JSON.
             * @function toJSON
             * @memberof CS.SeqUTF8String
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqUTF8String.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqUTF8String;
        })();
    
        CS.SeqBinary = (function() {
    
            /**
             * Properties of a SeqBinary.
             * @memberof CS
             * @interface ISeqBinary
             * @property {Array.<Uint8Array>|null} [values] SeqBinary values
             */
    
            /**
             * Constructs a new SeqBinary.
             * @memberof CS
             * @classdesc Represents a SeqBinary.
             * @implements ISeqBinary
             * @constructor
             * @param {CS.ISeqBinary=} [properties] Properties to set
             */
            function SeqBinary(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqBinary values.
             * @member {Array.<Uint8Array>} values
             * @memberof CS.SeqBinary
             * @instance
             */
            SeqBinary.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqBinary instance using the specified properties.
             * @function create
             * @memberof CS.SeqBinary
             * @static
             * @param {CS.ISeqBinary=} [properties] Properties to set
             * @returns {CS.SeqBinary} SeqBinary instance
             */
            SeqBinary.create = function create(properties) {
                return new SeqBinary(properties);
            };
    
            /**
             * Encodes the specified SeqBinary message. Does not implicitly {@link CS.SeqBinary.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqBinary
             * @static
             * @param {CS.ISeqBinary} message SeqBinary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqBinary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.values[i]);
                return writer;
            };
    
            /**
             * Encodes the specified SeqBinary message, length delimited. Does not implicitly {@link CS.SeqBinary.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqBinary
             * @static
             * @param {CS.ISeqBinary} message SeqBinary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqBinary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqBinary message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqBinary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqBinary} SeqBinary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqBinary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqBinary();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqBinary message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqBinary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqBinary} SeqBinary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqBinary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqBinary message.
             * @function verify
             * @memberof CS.SeqBinary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqBinary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!(message.values[i] && typeof message.values[i].length === "number" || $util.isString(message.values[i])))
                            return "values: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqBinary message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqBinary
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqBinary} SeqBinary
             */
            SeqBinary.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqBinary)
                    return object;
                var message = new $root.CS.SeqBinary();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqBinary.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        if (typeof object.values[i] === "string")
                            $util.base64.decode(object.values[i], message.values[i] = $util.newBuffer($util.base64.length(object.values[i])), 0);
                        else if (object.values[i].length)
                            message.values[i] = object.values[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqBinary message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqBinary
             * @static
             * @param {CS.SeqBinary} message SeqBinary
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqBinary.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = options.bytes === String ? $util.base64.encode(message.values[j], 0, message.values[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.values[j]) : message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqBinary to JSON.
             * @function toJSON
             * @memberof CS.SeqBinary
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqBinary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqBinary;
        })();
    
        CS.SeqUInt8 = (function() {
    
            /**
             * Properties of a SeqUInt8.
             * @memberof CS
             * @interface ISeqUInt8
             * @property {Array.<number>|null} [values] SeqUInt8 values
             */
    
            /**
             * Constructs a new SeqUInt8.
             * @memberof CS
             * @classdesc Represents a SeqUInt8.
             * @implements ISeqUInt8
             * @constructor
             * @param {CS.ISeqUInt8=} [properties] Properties to set
             */
            function SeqUInt8(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqUInt8 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqUInt8
             * @instance
             */
            SeqUInt8.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqUInt8 instance using the specified properties.
             * @function create
             * @memberof CS.SeqUInt8
             * @static
             * @param {CS.ISeqUInt8=} [properties] Properties to set
             * @returns {CS.SeqUInt8} SeqUInt8 instance
             */
            SeqUInt8.create = function create(properties) {
                return new SeqUInt8(properties);
            };
    
            /**
             * Encodes the specified SeqUInt8 message. Does not implicitly {@link CS.SeqUInt8.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqUInt8
             * @static
             * @param {CS.ISeqUInt8} message SeqUInt8 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt8.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqUInt8 message, length delimited. Does not implicitly {@link CS.SeqUInt8.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqUInt8
             * @static
             * @param {CS.ISeqUInt8} message SeqUInt8 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt8.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqUInt8 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqUInt8
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqUInt8} SeqUInt8
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt8.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqUInt8();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.uint32());
                        } else
                            message.values.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqUInt8 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqUInt8
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqUInt8} SeqUInt8
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt8.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqUInt8 message.
             * @function verify
             * @memberof CS.SeqUInt8
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqUInt8.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqUInt8 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqUInt8
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqUInt8} SeqUInt8
             */
            SeqUInt8.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqUInt8)
                    return object;
                var message = new $root.CS.SeqUInt8();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqUInt8.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqUInt8 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqUInt8
             * @static
             * @param {CS.SeqUInt8} message SeqUInt8
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqUInt8.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqUInt8 to JSON.
             * @function toJSON
             * @memberof CS.SeqUInt8
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqUInt8.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqUInt8;
        })();
    
        CS.SeqSInt8 = (function() {
    
            /**
             * Properties of a SeqSInt8.
             * @memberof CS
             * @interface ISeqSInt8
             * @property {Array.<number>|null} [values] SeqSInt8 values
             */
    
            /**
             * Constructs a new SeqSInt8.
             * @memberof CS
             * @classdesc Represents a SeqSInt8.
             * @implements ISeqSInt8
             * @constructor
             * @param {CS.ISeqSInt8=} [properties] Properties to set
             */
            function SeqSInt8(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqSInt8 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqSInt8
             * @instance
             */
            SeqSInt8.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqSInt8 instance using the specified properties.
             * @function create
             * @memberof CS.SeqSInt8
             * @static
             * @param {CS.ISeqSInt8=} [properties] Properties to set
             * @returns {CS.SeqSInt8} SeqSInt8 instance
             */
            SeqSInt8.create = function create(properties) {
                return new SeqSInt8(properties);
            };
    
            /**
             * Encodes the specified SeqSInt8 message. Does not implicitly {@link CS.SeqSInt8.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqSInt8
             * @static
             * @param {CS.ISeqSInt8} message SeqSInt8 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt8.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.sint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqSInt8 message, length delimited. Does not implicitly {@link CS.SeqSInt8.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqSInt8
             * @static
             * @param {CS.ISeqSInt8} message SeqSInt8 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt8.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqSInt8 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqSInt8
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqSInt8} SeqSInt8
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt8.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqSInt8();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.sint32());
                        } else
                            message.values.push(reader.sint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqSInt8 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqSInt8
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqSInt8} SeqSInt8
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt8.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqSInt8 message.
             * @function verify
             * @memberof CS.SeqSInt8
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqSInt8.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqSInt8 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqSInt8
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqSInt8} SeqSInt8
             */
            SeqSInt8.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqSInt8)
                    return object;
                var message = new $root.CS.SeqSInt8();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqSInt8.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] | 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqSInt8 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqSInt8
             * @static
             * @param {CS.SeqSInt8} message SeqSInt8
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqSInt8.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqSInt8 to JSON.
             * @function toJSON
             * @memberof CS.SeqSInt8
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqSInt8.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqSInt8;
        })();
    
        CS.SeqUInt16 = (function() {
    
            /**
             * Properties of a SeqUInt16.
             * @memberof CS
             * @interface ISeqUInt16
             * @property {Array.<number>|null} [values] SeqUInt16 values
             */
    
            /**
             * Constructs a new SeqUInt16.
             * @memberof CS
             * @classdesc Represents a SeqUInt16.
             * @implements ISeqUInt16
             * @constructor
             * @param {CS.ISeqUInt16=} [properties] Properties to set
             */
            function SeqUInt16(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqUInt16 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqUInt16
             * @instance
             */
            SeqUInt16.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqUInt16 instance using the specified properties.
             * @function create
             * @memberof CS.SeqUInt16
             * @static
             * @param {CS.ISeqUInt16=} [properties] Properties to set
             * @returns {CS.SeqUInt16} SeqUInt16 instance
             */
            SeqUInt16.create = function create(properties) {
                return new SeqUInt16(properties);
            };
    
            /**
             * Encodes the specified SeqUInt16 message. Does not implicitly {@link CS.SeqUInt16.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqUInt16
             * @static
             * @param {CS.ISeqUInt16} message SeqUInt16 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt16.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqUInt16 message, length delimited. Does not implicitly {@link CS.SeqUInt16.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqUInt16
             * @static
             * @param {CS.ISeqUInt16} message SeqUInt16 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt16.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqUInt16 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqUInt16
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqUInt16} SeqUInt16
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt16.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqUInt16();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.uint32());
                        } else
                            message.values.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqUInt16 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqUInt16
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqUInt16} SeqUInt16
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt16.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqUInt16 message.
             * @function verify
             * @memberof CS.SeqUInt16
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqUInt16.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqUInt16 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqUInt16
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqUInt16} SeqUInt16
             */
            SeqUInt16.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqUInt16)
                    return object;
                var message = new $root.CS.SeqUInt16();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqUInt16.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqUInt16 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqUInt16
             * @static
             * @param {CS.SeqUInt16} message SeqUInt16
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqUInt16.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqUInt16 to JSON.
             * @function toJSON
             * @memberof CS.SeqUInt16
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqUInt16.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqUInt16;
        })();
    
        CS.SeqSInt16 = (function() {
    
            /**
             * Properties of a SeqSInt16.
             * @memberof CS
             * @interface ISeqSInt16
             * @property {Array.<number>|null} [values] SeqSInt16 values
             */
    
            /**
             * Constructs a new SeqSInt16.
             * @memberof CS
             * @classdesc Represents a SeqSInt16.
             * @implements ISeqSInt16
             * @constructor
             * @param {CS.ISeqSInt16=} [properties] Properties to set
             */
            function SeqSInt16(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqSInt16 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqSInt16
             * @instance
             */
            SeqSInt16.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqSInt16 instance using the specified properties.
             * @function create
             * @memberof CS.SeqSInt16
             * @static
             * @param {CS.ISeqSInt16=} [properties] Properties to set
             * @returns {CS.SeqSInt16} SeqSInt16 instance
             */
            SeqSInt16.create = function create(properties) {
                return new SeqSInt16(properties);
            };
    
            /**
             * Encodes the specified SeqSInt16 message. Does not implicitly {@link CS.SeqSInt16.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqSInt16
             * @static
             * @param {CS.ISeqSInt16} message SeqSInt16 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt16.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.sint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqSInt16 message, length delimited. Does not implicitly {@link CS.SeqSInt16.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqSInt16
             * @static
             * @param {CS.ISeqSInt16} message SeqSInt16 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt16.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqSInt16 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqSInt16
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqSInt16} SeqSInt16
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt16.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqSInt16();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.sint32());
                        } else
                            message.values.push(reader.sint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqSInt16 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqSInt16
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqSInt16} SeqSInt16
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt16.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqSInt16 message.
             * @function verify
             * @memberof CS.SeqSInt16
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqSInt16.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqSInt16 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqSInt16
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqSInt16} SeqSInt16
             */
            SeqSInt16.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqSInt16)
                    return object;
                var message = new $root.CS.SeqSInt16();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqSInt16.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] | 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqSInt16 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqSInt16
             * @static
             * @param {CS.SeqSInt16} message SeqSInt16
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqSInt16.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqSInt16 to JSON.
             * @function toJSON
             * @memberof CS.SeqSInt16
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqSInt16.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqSInt16;
        })();
    
        CS.SeqUInt32 = (function() {
    
            /**
             * Properties of a SeqUInt32.
             * @memberof CS
             * @interface ISeqUInt32
             * @property {Array.<number>|null} [values] SeqUInt32 values
             */
    
            /**
             * Constructs a new SeqUInt32.
             * @memberof CS
             * @classdesc Represents a SeqUInt32.
             * @implements ISeqUInt32
             * @constructor
             * @param {CS.ISeqUInt32=} [properties] Properties to set
             */
            function SeqUInt32(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqUInt32 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqUInt32
             * @instance
             */
            SeqUInt32.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqUInt32 instance using the specified properties.
             * @function create
             * @memberof CS.SeqUInt32
             * @static
             * @param {CS.ISeqUInt32=} [properties] Properties to set
             * @returns {CS.SeqUInt32} SeqUInt32 instance
             */
            SeqUInt32.create = function create(properties) {
                return new SeqUInt32(properties);
            };
    
            /**
             * Encodes the specified SeqUInt32 message. Does not implicitly {@link CS.SeqUInt32.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqUInt32
             * @static
             * @param {CS.ISeqUInt32} message SeqUInt32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt32.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqUInt32 message, length delimited. Does not implicitly {@link CS.SeqUInt32.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqUInt32
             * @static
             * @param {CS.ISeqUInt32} message SeqUInt32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt32.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqUInt32 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqUInt32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqUInt32} SeqUInt32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt32.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqUInt32();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.uint32());
                        } else
                            message.values.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqUInt32 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqUInt32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqUInt32} SeqUInt32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt32.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqUInt32 message.
             * @function verify
             * @memberof CS.SeqUInt32
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqUInt32.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqUInt32 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqUInt32
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqUInt32} SeqUInt32
             */
            SeqUInt32.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqUInt32)
                    return object;
                var message = new $root.CS.SeqUInt32();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqUInt32.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqUInt32 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqUInt32
             * @static
             * @param {CS.SeqUInt32} message SeqUInt32
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqUInt32.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqUInt32 to JSON.
             * @function toJSON
             * @memberof CS.SeqUInt32
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqUInt32.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqUInt32;
        })();
    
        CS.SeqSInt32 = (function() {
    
            /**
             * Properties of a SeqSInt32.
             * @memberof CS
             * @interface ISeqSInt32
             * @property {Array.<number>|null} [values] SeqSInt32 values
             */
    
            /**
             * Constructs a new SeqSInt32.
             * @memberof CS
             * @classdesc Represents a SeqSInt32.
             * @implements ISeqSInt32
             * @constructor
             * @param {CS.ISeqSInt32=} [properties] Properties to set
             */
            function SeqSInt32(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqSInt32 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqSInt32
             * @instance
             */
            SeqSInt32.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqSInt32 instance using the specified properties.
             * @function create
             * @memberof CS.SeqSInt32
             * @static
             * @param {CS.ISeqSInt32=} [properties] Properties to set
             * @returns {CS.SeqSInt32} SeqSInt32 instance
             */
            SeqSInt32.create = function create(properties) {
                return new SeqSInt32(properties);
            };
    
            /**
             * Encodes the specified SeqSInt32 message. Does not implicitly {@link CS.SeqSInt32.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqSInt32
             * @static
             * @param {CS.ISeqSInt32} message SeqSInt32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt32.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.sint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqSInt32 message, length delimited. Does not implicitly {@link CS.SeqSInt32.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqSInt32
             * @static
             * @param {CS.ISeqSInt32} message SeqSInt32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt32.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqSInt32 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqSInt32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqSInt32} SeqSInt32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt32.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqSInt32();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.sint32());
                        } else
                            message.values.push(reader.sint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqSInt32 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqSInt32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqSInt32} SeqSInt32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt32.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqSInt32 message.
             * @function verify
             * @memberof CS.SeqSInt32
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqSInt32.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqSInt32 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqSInt32
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqSInt32} SeqSInt32
             */
            SeqSInt32.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqSInt32)
                    return object;
                var message = new $root.CS.SeqSInt32();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqSInt32.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] | 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqSInt32 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqSInt32
             * @static
             * @param {CS.SeqSInt32} message SeqSInt32
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqSInt32.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqSInt32 to JSON.
             * @function toJSON
             * @memberof CS.SeqSInt32
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqSInt32.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqSInt32;
        })();
    
        CS.SeqUInt64 = (function() {
    
            /**
             * Properties of a SeqUInt64.
             * @memberof CS
             * @interface ISeqUInt64
             * @property {Array.<number|Long>|null} [values] SeqUInt64 values
             */
    
            /**
             * Constructs a new SeqUInt64.
             * @memberof CS
             * @classdesc Represents a SeqUInt64.
             * @implements ISeqUInt64
             * @constructor
             * @param {CS.ISeqUInt64=} [properties] Properties to set
             */
            function SeqUInt64(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqUInt64 values.
             * @member {Array.<number|Long>} values
             * @memberof CS.SeqUInt64
             * @instance
             */
            SeqUInt64.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqUInt64 instance using the specified properties.
             * @function create
             * @memberof CS.SeqUInt64
             * @static
             * @param {CS.ISeqUInt64=} [properties] Properties to set
             * @returns {CS.SeqUInt64} SeqUInt64 instance
             */
            SeqUInt64.create = function create(properties) {
                return new SeqUInt64(properties);
            };
    
            /**
             * Encodes the specified SeqUInt64 message. Does not implicitly {@link CS.SeqUInt64.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqUInt64
             * @static
             * @param {CS.ISeqUInt64} message SeqUInt64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt64.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint64(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqUInt64 message, length delimited. Does not implicitly {@link CS.SeqUInt64.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqUInt64
             * @static
             * @param {CS.ISeqUInt64} message SeqUInt64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqUInt64.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqUInt64 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqUInt64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqUInt64} SeqUInt64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt64.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqUInt64();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.uint64());
                        } else
                            message.values.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqUInt64 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqUInt64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqUInt64} SeqUInt64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqUInt64.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqUInt64 message.
             * @function verify
             * @memberof CS.SeqUInt64
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqUInt64.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]) && !(message.values[i] && $util.isInteger(message.values[i].low) && $util.isInteger(message.values[i].high)))
                            return "values: integer|Long[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqUInt64 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqUInt64
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqUInt64} SeqUInt64
             */
            SeqUInt64.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqUInt64)
                    return object;
                var message = new $root.CS.SeqUInt64();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqUInt64.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        if ($util.Long)
                            (message.values[i] = $util.Long.fromValue(object.values[i])).unsigned = true;
                        else if (typeof object.values[i] === "string")
                            message.values[i] = parseInt(object.values[i], 10);
                        else if (typeof object.values[i] === "number")
                            message.values[i] = object.values[i];
                        else if (typeof object.values[i] === "object")
                            message.values[i] = new $util.LongBits(object.values[i].low >>> 0, object.values[i].high >>> 0).toNumber(true);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqUInt64 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqUInt64
             * @static
             * @param {CS.SeqUInt64} message SeqUInt64
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqUInt64.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        if (typeof message.values[j] === "number")
                            object.values[j] = options.longs === String ? String(message.values[j]) : message.values[j];
                        else
                            object.values[j] = options.longs === String ? $util.Long.prototype.toString.call(message.values[j]) : options.longs === Number ? new $util.LongBits(message.values[j].low >>> 0, message.values[j].high >>> 0).toNumber(true) : message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqUInt64 to JSON.
             * @function toJSON
             * @memberof CS.SeqUInt64
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqUInt64.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqUInt64;
        })();
    
        CS.SeqSInt64 = (function() {
    
            /**
             * Properties of a SeqSInt64.
             * @memberof CS
             * @interface ISeqSInt64
             * @property {Array.<number|Long>|null} [values] SeqSInt64 values
             */
    
            /**
             * Constructs a new SeqSInt64.
             * @memberof CS
             * @classdesc Represents a SeqSInt64.
             * @implements ISeqSInt64
             * @constructor
             * @param {CS.ISeqSInt64=} [properties] Properties to set
             */
            function SeqSInt64(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqSInt64 values.
             * @member {Array.<number|Long>} values
             * @memberof CS.SeqSInt64
             * @instance
             */
            SeqSInt64.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqSInt64 instance using the specified properties.
             * @function create
             * @memberof CS.SeqSInt64
             * @static
             * @param {CS.ISeqSInt64=} [properties] Properties to set
             * @returns {CS.SeqSInt64} SeqSInt64 instance
             */
            SeqSInt64.create = function create(properties) {
                return new SeqSInt64(properties);
            };
    
            /**
             * Encodes the specified SeqSInt64 message. Does not implicitly {@link CS.SeqSInt64.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqSInt64
             * @static
             * @param {CS.ISeqSInt64} message SeqSInt64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt64.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.sint64(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqSInt64 message, length delimited. Does not implicitly {@link CS.SeqSInt64.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqSInt64
             * @static
             * @param {CS.ISeqSInt64} message SeqSInt64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqSInt64.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqSInt64 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqSInt64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqSInt64} SeqSInt64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt64.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqSInt64();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.sint64());
                        } else
                            message.values.push(reader.sint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqSInt64 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqSInt64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqSInt64} SeqSInt64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqSInt64.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqSInt64 message.
             * @function verify
             * @memberof CS.SeqSInt64
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqSInt64.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]) && !(message.values[i] && $util.isInteger(message.values[i].low) && $util.isInteger(message.values[i].high)))
                            return "values: integer|Long[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqSInt64 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqSInt64
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqSInt64} SeqSInt64
             */
            SeqSInt64.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqSInt64)
                    return object;
                var message = new $root.CS.SeqSInt64();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqSInt64.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        if ($util.Long)
                            (message.values[i] = $util.Long.fromValue(object.values[i])).unsigned = false;
                        else if (typeof object.values[i] === "string")
                            message.values[i] = parseInt(object.values[i], 10);
                        else if (typeof object.values[i] === "number")
                            message.values[i] = object.values[i];
                        else if (typeof object.values[i] === "object")
                            message.values[i] = new $util.LongBits(object.values[i].low >>> 0, object.values[i].high >>> 0).toNumber();
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqSInt64 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqSInt64
             * @static
             * @param {CS.SeqSInt64} message SeqSInt64
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqSInt64.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        if (typeof message.values[j] === "number")
                            object.values[j] = options.longs === String ? String(message.values[j]) : message.values[j];
                        else
                            object.values[j] = options.longs === String ? $util.Long.prototype.toString.call(message.values[j]) : options.longs === Number ? new $util.LongBits(message.values[j].low >>> 0, message.values[j].high >>> 0).toNumber() : message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqSInt64 to JSON.
             * @function toJSON
             * @memberof CS.SeqSInt64
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqSInt64.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqSInt64;
        })();
    
        CS.SeqFloat32 = (function() {
    
            /**
             * Properties of a SeqFloat32.
             * @memberof CS
             * @interface ISeqFloat32
             * @property {Array.<number>|null} [values] SeqFloat32 values
             */
    
            /**
             * Constructs a new SeqFloat32.
             * @memberof CS
             * @classdesc Represents a SeqFloat32.
             * @implements ISeqFloat32
             * @constructor
             * @param {CS.ISeqFloat32=} [properties] Properties to set
             */
            function SeqFloat32(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqFloat32 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqFloat32
             * @instance
             */
            SeqFloat32.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqFloat32 instance using the specified properties.
             * @function create
             * @memberof CS.SeqFloat32
             * @static
             * @param {CS.ISeqFloat32=} [properties] Properties to set
             * @returns {CS.SeqFloat32} SeqFloat32 instance
             */
            SeqFloat32.create = function create(properties) {
                return new SeqFloat32(properties);
            };
    
            /**
             * Encodes the specified SeqFloat32 message. Does not implicitly {@link CS.SeqFloat32.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqFloat32
             * @static
             * @param {CS.ISeqFloat32} message SeqFloat32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqFloat32.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.float(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqFloat32 message, length delimited. Does not implicitly {@link CS.SeqFloat32.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqFloat32
             * @static
             * @param {CS.ISeqFloat32} message SeqFloat32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqFloat32.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqFloat32 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqFloat32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqFloat32} SeqFloat32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqFloat32.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqFloat32();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.float());
                        } else
                            message.values.push(reader.float());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqFloat32 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqFloat32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqFloat32} SeqFloat32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqFloat32.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqFloat32 message.
             * @function verify
             * @memberof CS.SeqFloat32
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqFloat32.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (typeof message.values[i] !== "number")
                            return "values: number[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqFloat32 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqFloat32
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqFloat32} SeqFloat32
             */
            SeqFloat32.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqFloat32)
                    return object;
                var message = new $root.CS.SeqFloat32();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqFloat32.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = Number(object.values[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqFloat32 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqFloat32
             * @static
             * @param {CS.SeqFloat32} message SeqFloat32
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqFloat32.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqFloat32 to JSON.
             * @function toJSON
             * @memberof CS.SeqFloat32
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqFloat32.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqFloat32;
        })();
    
        CS.SeqFloat64 = (function() {
    
            /**
             * Properties of a SeqFloat64.
             * @memberof CS
             * @interface ISeqFloat64
             * @property {Array.<number>|null} [values] SeqFloat64 values
             */
    
            /**
             * Constructs a new SeqFloat64.
             * @memberof CS
             * @classdesc Represents a SeqFloat64.
             * @implements ISeqFloat64
             * @constructor
             * @param {CS.ISeqFloat64=} [properties] Properties to set
             */
            function SeqFloat64(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqFloat64 values.
             * @member {Array.<number>} values
             * @memberof CS.SeqFloat64
             * @instance
             */
            SeqFloat64.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqFloat64 instance using the specified properties.
             * @function create
             * @memberof CS.SeqFloat64
             * @static
             * @param {CS.ISeqFloat64=} [properties] Properties to set
             * @returns {CS.SeqFloat64} SeqFloat64 instance
             */
            SeqFloat64.create = function create(properties) {
                return new SeqFloat64(properties);
            };
    
            /**
             * Encodes the specified SeqFloat64 message. Does not implicitly {@link CS.SeqFloat64.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqFloat64
             * @static
             * @param {CS.ISeqFloat64} message SeqFloat64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqFloat64.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.double(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified SeqFloat64 message, length delimited. Does not implicitly {@link CS.SeqFloat64.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqFloat64
             * @static
             * @param {CS.ISeqFloat64} message SeqFloat64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqFloat64.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqFloat64 message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqFloat64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqFloat64} SeqFloat64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqFloat64.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqFloat64();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.values.push(reader.double());
                        } else
                            message.values.push(reader.double());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqFloat64 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqFloat64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqFloat64} SeqFloat64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqFloat64.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqFloat64 message.
             * @function verify
             * @memberof CS.SeqFloat64
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqFloat64.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (typeof message.values[i] !== "number")
                            return "values: number[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqFloat64 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqFloat64
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqFloat64} SeqFloat64
             */
            SeqFloat64.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqFloat64)
                    return object;
                var message = new $root.CS.SeqFloat64();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqFloat64.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = Number(object.values[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqFloat64 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqFloat64
             * @static
             * @param {CS.SeqFloat64} message SeqFloat64
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqFloat64.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqFloat64 to JSON.
             * @function toJSON
             * @memberof CS.SeqFloat64
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqFloat64.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqFloat64;
        })();
    
        CS.SeqTime = (function() {
    
            /**
             * Properties of a SeqTime.
             * @memberof CS
             * @interface ISeqTime
             * @property {Array.<CS.ITime>|null} [values] SeqTime values
             */
    
            /**
             * Constructs a new SeqTime.
             * @memberof CS
             * @classdesc Represents a SeqTime.
             * @implements ISeqTime
             * @constructor
             * @param {CS.ISeqTime=} [properties] Properties to set
             */
            function SeqTime(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqTime values.
             * @member {Array.<CS.ITime>} values
             * @memberof CS.SeqTime
             * @instance
             */
            SeqTime.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqTime instance using the specified properties.
             * @function create
             * @memberof CS.SeqTime
             * @static
             * @param {CS.ISeqTime=} [properties] Properties to set
             * @returns {CS.SeqTime} SeqTime instance
             */
            SeqTime.create = function create(properties) {
                return new SeqTime(properties);
            };
    
            /**
             * Encodes the specified SeqTime message. Does not implicitly {@link CS.SeqTime.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqTime
             * @static
             * @param {CS.ISeqTime} message SeqTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqTime.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.CS.Time.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SeqTime message, length delimited. Does not implicitly {@link CS.SeqTime.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqTime
             * @static
             * @param {CS.ISeqTime} message SeqTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqTime.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqTime message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqTime} SeqTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqTime.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqTime();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.CS.Time.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqTime message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqTime} SeqTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqTime.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqTime message.
             * @function verify
             * @memberof CS.SeqTime
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqTime.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.CS.Time.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SeqTime message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqTime
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqTime} SeqTime
             */
            SeqTime.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqTime)
                    return object;
                var message = new $root.CS.SeqTime();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqTime.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".CS.SeqTime.values: object expected");
                        message.values[i] = $root.CS.Time.fromObject(object.values[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqTime message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqTime
             * @static
             * @param {CS.SeqTime} message SeqTime
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqTime.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.CS.Time.toObject(message.values[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SeqTime to JSON.
             * @function toJSON
             * @memberof CS.SeqTime
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqTime.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqTime;
        })();
    
        CS.SeqDate = (function() {
    
            /**
             * Properties of a SeqDate.
             * @memberof CS
             * @interface ISeqDate
             * @property {Array.<CS.IDate>|null} [values] SeqDate values
             */
    
            /**
             * Constructs a new SeqDate.
             * @memberof CS
             * @classdesc Represents a SeqDate.
             * @implements ISeqDate
             * @constructor
             * @param {CS.ISeqDate=} [properties] Properties to set
             */
            function SeqDate(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqDate values.
             * @member {Array.<CS.IDate>} values
             * @memberof CS.SeqDate
             * @instance
             */
            SeqDate.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqDate instance using the specified properties.
             * @function create
             * @memberof CS.SeqDate
             * @static
             * @param {CS.ISeqDate=} [properties] Properties to set
             * @returns {CS.SeqDate} SeqDate instance
             */
            SeqDate.create = function create(properties) {
                return new SeqDate(properties);
            };
    
            /**
             * Encodes the specified SeqDate message. Does not implicitly {@link CS.SeqDate.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqDate
             * @static
             * @param {CS.ISeqDate} message SeqDate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqDate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.CS.Date.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SeqDate message, length delimited. Does not implicitly {@link CS.SeqDate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqDate
             * @static
             * @param {CS.ISeqDate} message SeqDate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqDate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqDate message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqDate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqDate} SeqDate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqDate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqDate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.CS.Date.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqDate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqDate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqDate} SeqDate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqDate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqDate message.
             * @function verify
             * @memberof CS.SeqDate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqDate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.CS.Date.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SeqDate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqDate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqDate} SeqDate
             */
            SeqDate.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqDate)
                    return object;
                var message = new $root.CS.SeqDate();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqDate.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".CS.SeqDate.values: object expected");
                        message.values[i] = $root.CS.Date.fromObject(object.values[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqDate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqDate
             * @static
             * @param {CS.SeqDate} message SeqDate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqDate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.CS.Date.toObject(message.values[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SeqDate to JSON.
             * @function toJSON
             * @memberof CS.SeqDate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqDate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqDate;
        })();
    
        CS.SeqTimeStamp = (function() {
    
            /**
             * Properties of a SeqTimeStamp.
             * @memberof CS
             * @interface ISeqTimeStamp
             * @property {Array.<CS.ITimeStamp>|null} [values] SeqTimeStamp values
             */
    
            /**
             * Constructs a new SeqTimeStamp.
             * @memberof CS
             * @classdesc Represents a SeqTimeStamp.
             * @implements ISeqTimeStamp
             * @constructor
             * @param {CS.ISeqTimeStamp=} [properties] Properties to set
             */
            function SeqTimeStamp(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqTimeStamp values.
             * @member {Array.<CS.ITimeStamp>} values
             * @memberof CS.SeqTimeStamp
             * @instance
             */
            SeqTimeStamp.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqTimeStamp instance using the specified properties.
             * @function create
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {CS.ISeqTimeStamp=} [properties] Properties to set
             * @returns {CS.SeqTimeStamp} SeqTimeStamp instance
             */
            SeqTimeStamp.create = function create(properties) {
                return new SeqTimeStamp(properties);
            };
    
            /**
             * Encodes the specified SeqTimeStamp message. Does not implicitly {@link CS.SeqTimeStamp.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {CS.ISeqTimeStamp} message SeqTimeStamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqTimeStamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.CS.TimeStamp.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SeqTimeStamp message, length delimited. Does not implicitly {@link CS.SeqTimeStamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {CS.ISeqTimeStamp} message SeqTimeStamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqTimeStamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqTimeStamp message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqTimeStamp} SeqTimeStamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqTimeStamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqTimeStamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.CS.TimeStamp.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqTimeStamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqTimeStamp} SeqTimeStamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqTimeStamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqTimeStamp message.
             * @function verify
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqTimeStamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.CS.TimeStamp.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SeqTimeStamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqTimeStamp} SeqTimeStamp
             */
            SeqTimeStamp.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqTimeStamp)
                    return object;
                var message = new $root.CS.SeqTimeStamp();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqTimeStamp.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".CS.SeqTimeStamp.values: object expected");
                        message.values[i] = $root.CS.TimeStamp.fromObject(object.values[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqTimeStamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqTimeStamp
             * @static
             * @param {CS.SeqTimeStamp} message SeqTimeStamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqTimeStamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.CS.TimeStamp.toObject(message.values[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SeqTimeStamp to JSON.
             * @function toJSON
             * @memberof CS.SeqTimeStamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqTimeStamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqTimeStamp;
        })();
    
        CS.SeqDecimal = (function() {
    
            /**
             * Properties of a SeqDecimal.
             * @memberof CS
             * @interface ISeqDecimal
             * @property {Array.<Uint8Array>|null} [values] SeqDecimal values
             */
    
            /**
             * Constructs a new SeqDecimal.
             * @memberof CS
             * @classdesc Represents a SeqDecimal.
             * @implements ISeqDecimal
             * @constructor
             * @param {CS.ISeqDecimal=} [properties] Properties to set
             */
            function SeqDecimal(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeqDecimal values.
             * @member {Array.<Uint8Array>} values
             * @memberof CS.SeqDecimal
             * @instance
             */
            SeqDecimal.prototype.values = $util.emptyArray;
    
            /**
             * Creates a new SeqDecimal instance using the specified properties.
             * @function create
             * @memberof CS.SeqDecimal
             * @static
             * @param {CS.ISeqDecimal=} [properties] Properties to set
             * @returns {CS.SeqDecimal} SeqDecimal instance
             */
            SeqDecimal.create = function create(properties) {
                return new SeqDecimal(properties);
            };
    
            /**
             * Encodes the specified SeqDecimal message. Does not implicitly {@link CS.SeqDecimal.verify|verify} messages.
             * @function encode
             * @memberof CS.SeqDecimal
             * @static
             * @param {CS.ISeqDecimal} message SeqDecimal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqDecimal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.values[i]);
                return writer;
            };
    
            /**
             * Encodes the specified SeqDecimal message, length delimited. Does not implicitly {@link CS.SeqDecimal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SeqDecimal
             * @static
             * @param {CS.ISeqDecimal} message SeqDecimal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeqDecimal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeqDecimal message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SeqDecimal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SeqDecimal} SeqDecimal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqDecimal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SeqDecimal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeqDecimal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SeqDecimal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SeqDecimal} SeqDecimal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeqDecimal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeqDecimal message.
             * @function verify
             * @memberof CS.SeqDecimal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeqDecimal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!(message.values[i] && typeof message.values[i].length === "number" || $util.isString(message.values[i])))
                            return "values: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a SeqDecimal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SeqDecimal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SeqDecimal} SeqDecimal
             */
            SeqDecimal.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SeqDecimal)
                    return object;
                var message = new $root.CS.SeqDecimal();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".CS.SeqDecimal.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        if (typeof object.values[i] === "string")
                            $util.base64.decode(object.values[i], message.values[i] = $util.newBuffer($util.base64.length(object.values[i])), 0);
                        else if (object.values[i].length)
                            message.values[i] = object.values[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeqDecimal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SeqDecimal
             * @static
             * @param {CS.SeqDecimal} message SeqDecimal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeqDecimal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = options.bytes === String ? $util.base64.encode(message.values[j], 0, message.values[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.values[j]) : message.values[j];
                }
                return object;
            };
    
            /**
             * Converts this SeqDecimal to JSON.
             * @function toJSON
             * @memberof CS.SeqDecimal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeqDecimal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeqDecimal;
        })();
    
        /**
         * ParameterTag enum.
         * @name CS.ParameterTag
         * @enum {number}
         * @property {number} Unknown_ParameterTag=0 Unknown_ParameterTag value
         * @property {number} P_String=1 P_String value
         * @property {number} P_UTF8String=2 P_UTF8String value
         * @property {number} P_Binary=3 P_Binary value
         * @property {number} P_SInt8=4 P_SInt8 value
         * @property {number} P_UInt8=5 P_UInt8 value
         * @property {number} P_UInt16=6 P_UInt16 value
         * @property {number} P_SInt16=7 P_SInt16 value
         * @property {number} P_SInt32=8 P_SInt32 value
         * @property {number} P_UInt32=9 P_UInt32 value
         * @property {number} P_SInt64=10 P_SInt64 value
         * @property {number} P_UInt64=11 P_UInt64 value
         * @property {number} P_Float32=12 P_Float32 value
         * @property {number} P_Float64=13 P_Float64 value
         * @property {number} P_Time=14 P_Time value
         * @property {number} P_Date=15 P_Date value
         * @property {number} P_TimeStamp=16 P_TimeStamp value
         * @property {number} P_RefCursor=17 P_RefCursor value
         * @property {number} P_Decimal=18 P_Decimal value
         */
        CS.ParameterTag = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_ParameterTag"] = 0;
            values[valuesById[1] = "P_String"] = 1;
            values[valuesById[2] = "P_UTF8String"] = 2;
            values[valuesById[3] = "P_Binary"] = 3;
            values[valuesById[4] = "P_SInt8"] = 4;
            values[valuesById[5] = "P_UInt8"] = 5;
            values[valuesById[6] = "P_UInt16"] = 6;
            values[valuesById[7] = "P_SInt16"] = 7;
            values[valuesById[8] = "P_SInt32"] = 8;
            values[valuesById[9] = "P_UInt32"] = 9;
            values[valuesById[10] = "P_SInt64"] = 10;
            values[valuesById[11] = "P_UInt64"] = 11;
            values[valuesById[12] = "P_Float32"] = 12;
            values[valuesById[13] = "P_Float64"] = 13;
            values[valuesById[14] = "P_Time"] = 14;
            values[valuesById[15] = "P_Date"] = 15;
            values[valuesById[16] = "P_TimeStamp"] = 16;
            values[valuesById[17] = "P_RefCursor"] = 17;
            values[valuesById[18] = "P_Decimal"] = 18;
            return values;
        })();
    
        CS.Value = (function() {
    
            /**
             * Properties of a Value.
             * @memberof CS
             * @interface IValue
             * @property {CS.ISeqString|null} [m_String] Value m_String
             * @property {CS.ISeqUTF8String|null} [m_UTF8String] Value m_UTF8String
             * @property {CS.ISeqBinary|null} [m_Binary] Value m_Binary
             * @property {CS.ISeqUInt8|null} [m_UInt8] Value m_UInt8
             * @property {CS.ISeqSInt8|null} [m_SInt8] Value m_SInt8
             * @property {CS.ISeqUInt16|null} [m_UInt16] Value m_UInt16
             * @property {CS.ISeqSInt16|null} [m_SInt16] Value m_SInt16
             * @property {CS.ISeqUInt32|null} [m_UInt32] Value m_UInt32
             * @property {CS.ISeqSInt32|null} [m_SInt32] Value m_SInt32
             * @property {CS.ISeqUInt64|null} [m_UInt64] Value m_UInt64
             * @property {CS.ISeqSInt64|null} [m_SInt64] Value m_SInt64
             * @property {CS.ISeqFloat32|null} [m_Float32] Value m_Float32
             * @property {CS.ISeqFloat64|null} [m_Float64] Value m_Float64
             * @property {CS.ISeqTime|null} [m_Time] Value m_Time
             * @property {CS.ISeqDate|null} [m_Date] Value m_Date
             * @property {CS.ISeqTimeStamp|null} [m_TimeStamp] Value m_TimeStamp
             * @property {number|null} [m_RefCursor] Value m_RefCursor
             * @property {CS.ISeqDecimal|null} [m_Decimal] Value m_Decimal
             */
    
            /**
             * Constructs a new Value.
             * @memberof CS
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {CS.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Value m_String.
             * @member {CS.ISeqString|null|undefined} m_String
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_String = null;
    
            /**
             * Value m_UTF8String.
             * @member {CS.ISeqUTF8String|null|undefined} m_UTF8String
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_UTF8String = null;
    
            /**
             * Value m_Binary.
             * @member {CS.ISeqBinary|null|undefined} m_Binary
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_Binary = null;
    
            /**
             * Value m_UInt8.
             * @member {CS.ISeqUInt8|null|undefined} m_UInt8
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_UInt8 = null;
    
            /**
             * Value m_SInt8.
             * @member {CS.ISeqSInt8|null|undefined} m_SInt8
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_SInt8 = null;
    
            /**
             * Value m_UInt16.
             * @member {CS.ISeqUInt16|null|undefined} m_UInt16
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_UInt16 = null;
    
            /**
             * Value m_SInt16.
             * @member {CS.ISeqSInt16|null|undefined} m_SInt16
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_SInt16 = null;
    
            /**
             * Value m_UInt32.
             * @member {CS.ISeqUInt32|null|undefined} m_UInt32
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_UInt32 = null;
    
            /**
             * Value m_SInt32.
             * @member {CS.ISeqSInt32|null|undefined} m_SInt32
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_SInt32 = null;
    
            /**
             * Value m_UInt64.
             * @member {CS.ISeqUInt64|null|undefined} m_UInt64
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_UInt64 = null;
    
            /**
             * Value m_SInt64.
             * @member {CS.ISeqSInt64|null|undefined} m_SInt64
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_SInt64 = null;
    
            /**
             * Value m_Float32.
             * @member {CS.ISeqFloat32|null|undefined} m_Float32
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_Float32 = null;
    
            /**
             * Value m_Float64.
             * @member {CS.ISeqFloat64|null|undefined} m_Float64
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_Float64 = null;
    
            /**
             * Value m_Time.
             * @member {CS.ISeqTime|null|undefined} m_Time
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_Time = null;
    
            /**
             * Value m_Date.
             * @member {CS.ISeqDate|null|undefined} m_Date
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_Date = null;
    
            /**
             * Value m_TimeStamp.
             * @member {CS.ISeqTimeStamp|null|undefined} m_TimeStamp
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_TimeStamp = null;
    
            /**
             * Value m_RefCursor.
             * @member {number} m_RefCursor
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_RefCursor = 0;
    
            /**
             * Value m_Decimal.
             * @member {CS.ISeqDecimal|null|undefined} m_Decimal
             * @memberof CS.Value
             * @instance
             */
            Value.prototype.m_Decimal = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Value ValueUnion.
             * @member {"m_String"|"m_UTF8String"|"m_Binary"|"m_UInt8"|"m_SInt8"|"m_UInt16"|"m_SInt16"|"m_UInt32"|"m_SInt32"|"m_UInt64"|"m_SInt64"|"m_Float32"|"m_Float64"|"m_Time"|"m_Date"|"m_TimeStamp"|"m_RefCursor"|"m_Decimal"|undefined} ValueUnion
             * @memberof CS.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "ValueUnion", {
                get: $util.oneOfGetter($oneOfFields = ["m_String", "m_UTF8String", "m_Binary", "m_UInt8", "m_SInt8", "m_UInt16", "m_SInt16", "m_UInt32", "m_SInt32", "m_UInt64", "m_SInt64", "m_Float32", "m_Float64", "m_Time", "m_Date", "m_TimeStamp", "m_RefCursor", "m_Decimal"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof CS.Value
             * @static
             * @param {CS.IValue=} [properties] Properties to set
             * @returns {CS.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };
    
            /**
             * Encodes the specified Value message. Does not implicitly {@link CS.Value.verify|verify} messages.
             * @function encode
             * @memberof CS.Value
             * @static
             * @param {CS.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_String != null && Object.hasOwnProperty.call(message, "m_String"))
                    $root.CS.SeqString.encode(message.m_String, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_UTF8String != null && Object.hasOwnProperty.call(message, "m_UTF8String"))
                    $root.CS.SeqUTF8String.encode(message.m_UTF8String, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.m_Binary != null && Object.hasOwnProperty.call(message, "m_Binary"))
                    $root.CS.SeqBinary.encode(message.m_Binary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.m_UInt8 != null && Object.hasOwnProperty.call(message, "m_UInt8"))
                    $root.CS.SeqUInt8.encode(message.m_UInt8, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.m_SInt8 != null && Object.hasOwnProperty.call(message, "m_SInt8"))
                    $root.CS.SeqSInt8.encode(message.m_SInt8, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.m_UInt16 != null && Object.hasOwnProperty.call(message, "m_UInt16"))
                    $root.CS.SeqUInt16.encode(message.m_UInt16, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.m_SInt16 != null && Object.hasOwnProperty.call(message, "m_SInt16"))
                    $root.CS.SeqSInt16.encode(message.m_SInt16, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.m_UInt32 != null && Object.hasOwnProperty.call(message, "m_UInt32"))
                    $root.CS.SeqUInt32.encode(message.m_UInt32, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.m_SInt32 != null && Object.hasOwnProperty.call(message, "m_SInt32"))
                    $root.CS.SeqSInt32.encode(message.m_SInt32, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.m_UInt64 != null && Object.hasOwnProperty.call(message, "m_UInt64"))
                    $root.CS.SeqUInt64.encode(message.m_UInt64, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.m_SInt64 != null && Object.hasOwnProperty.call(message, "m_SInt64"))
                    $root.CS.SeqSInt64.encode(message.m_SInt64, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.m_Float32 != null && Object.hasOwnProperty.call(message, "m_Float32"))
                    $root.CS.SeqFloat32.encode(message.m_Float32, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.m_Float64 != null && Object.hasOwnProperty.call(message, "m_Float64"))
                    $root.CS.SeqFloat64.encode(message.m_Float64, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.m_Time != null && Object.hasOwnProperty.call(message, "m_Time"))
                    $root.CS.SeqTime.encode(message.m_Time, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.m_Date != null && Object.hasOwnProperty.call(message, "m_Date"))
                    $root.CS.SeqDate.encode(message.m_Date, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.m_TimeStamp != null && Object.hasOwnProperty.call(message, "m_TimeStamp"))
                    $root.CS.SeqTimeStamp.encode(message.m_TimeStamp, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.m_RefCursor != null && Object.hasOwnProperty.call(message, "m_RefCursor"))
                    writer.uint32(/* id 17, wireType 0 =*/136).sint32(message.m_RefCursor);
                if (message.m_Decimal != null && Object.hasOwnProperty.call(message, "m_Decimal"))
                    $root.CS.SeqDecimal.encode(message.m_Decimal, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link CS.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Value
             * @static
             * @param {CS.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_String = $root.CS.SeqString.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.m_UTF8String = $root.CS.SeqUTF8String.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.m_Binary = $root.CS.SeqBinary.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.m_UInt8 = $root.CS.SeqUInt8.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.m_SInt8 = $root.CS.SeqSInt8.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.m_UInt16 = $root.CS.SeqUInt16.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.m_SInt16 = $root.CS.SeqSInt16.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.m_UInt32 = $root.CS.SeqUInt32.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.m_SInt32 = $root.CS.SeqSInt32.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.m_UInt64 = $root.CS.SeqUInt64.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.m_SInt64 = $root.CS.SeqSInt64.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.m_Float32 = $root.CS.SeqFloat32.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.m_Float64 = $root.CS.SeqFloat64.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.m_Time = $root.CS.SeqTime.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.m_Date = $root.CS.SeqDate.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.m_TimeStamp = $root.CS.SeqTimeStamp.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.m_RefCursor = reader.sint32();
                        break;
                    case 18:
                        message.m_Decimal = $root.CS.SeqDecimal.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Value message.
             * @function verify
             * @memberof CS.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.m_String != null && message.hasOwnProperty("m_String")) {
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqString.verify(message.m_String);
                        if (error)
                            return "m_String." + error;
                    }
                }
                if (message.m_UTF8String != null && message.hasOwnProperty("m_UTF8String")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqUTF8String.verify(message.m_UTF8String);
                        if (error)
                            return "m_UTF8String." + error;
                    }
                }
                if (message.m_Binary != null && message.hasOwnProperty("m_Binary")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqBinary.verify(message.m_Binary);
                        if (error)
                            return "m_Binary." + error;
                    }
                }
                if (message.m_UInt8 != null && message.hasOwnProperty("m_UInt8")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqUInt8.verify(message.m_UInt8);
                        if (error)
                            return "m_UInt8." + error;
                    }
                }
                if (message.m_SInt8 != null && message.hasOwnProperty("m_SInt8")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqSInt8.verify(message.m_SInt8);
                        if (error)
                            return "m_SInt8." + error;
                    }
                }
                if (message.m_UInt16 != null && message.hasOwnProperty("m_UInt16")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqUInt16.verify(message.m_UInt16);
                        if (error)
                            return "m_UInt16." + error;
                    }
                }
                if (message.m_SInt16 != null && message.hasOwnProperty("m_SInt16")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqSInt16.verify(message.m_SInt16);
                        if (error)
                            return "m_SInt16." + error;
                    }
                }
                if (message.m_UInt32 != null && message.hasOwnProperty("m_UInt32")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqUInt32.verify(message.m_UInt32);
                        if (error)
                            return "m_UInt32." + error;
                    }
                }
                if (message.m_SInt32 != null && message.hasOwnProperty("m_SInt32")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqSInt32.verify(message.m_SInt32);
                        if (error)
                            return "m_SInt32." + error;
                    }
                }
                if (message.m_UInt64 != null && message.hasOwnProperty("m_UInt64")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqUInt64.verify(message.m_UInt64);
                        if (error)
                            return "m_UInt64." + error;
                    }
                }
                if (message.m_SInt64 != null && message.hasOwnProperty("m_SInt64")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqSInt64.verify(message.m_SInt64);
                        if (error)
                            return "m_SInt64." + error;
                    }
                }
                if (message.m_Float32 != null && message.hasOwnProperty("m_Float32")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqFloat32.verify(message.m_Float32);
                        if (error)
                            return "m_Float32." + error;
                    }
                }
                if (message.m_Float64 != null && message.hasOwnProperty("m_Float64")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqFloat64.verify(message.m_Float64);
                        if (error)
                            return "m_Float64." + error;
                    }
                }
                if (message.m_Time != null && message.hasOwnProperty("m_Time")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqTime.verify(message.m_Time);
                        if (error)
                            return "m_Time." + error;
                    }
                }
                if (message.m_Date != null && message.hasOwnProperty("m_Date")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqDate.verify(message.m_Date);
                        if (error)
                            return "m_Date." + error;
                    }
                }
                if (message.m_TimeStamp != null && message.hasOwnProperty("m_TimeStamp")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqTimeStamp.verify(message.m_TimeStamp);
                        if (error)
                            return "m_TimeStamp." + error;
                    }
                }
                if (message.m_RefCursor != null && message.hasOwnProperty("m_RefCursor")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    if (!$util.isInteger(message.m_RefCursor))
                        return "m_RefCursor: integer expected";
                }
                if (message.m_Decimal != null && message.hasOwnProperty("m_Decimal")) {
                    if (properties.ValueUnion === 1)
                        return "ValueUnion: multiple values";
                    properties.ValueUnion = 1;
                    {
                        var error = $root.CS.SeqDecimal.verify(message.m_Decimal);
                        if (error)
                            return "m_Decimal." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Value)
                    return object;
                var message = new $root.CS.Value();
                if (object.m_String != null) {
                    if (typeof object.m_String !== "object")
                        throw TypeError(".CS.Value.m_String: object expected");
                    message.m_String = $root.CS.SeqString.fromObject(object.m_String);
                }
                if (object.m_UTF8String != null) {
                    if (typeof object.m_UTF8String !== "object")
                        throw TypeError(".CS.Value.m_UTF8String: object expected");
                    message.m_UTF8String = $root.CS.SeqUTF8String.fromObject(object.m_UTF8String);
                }
                if (object.m_Binary != null) {
                    if (typeof object.m_Binary !== "object")
                        throw TypeError(".CS.Value.m_Binary: object expected");
                    message.m_Binary = $root.CS.SeqBinary.fromObject(object.m_Binary);
                }
                if (object.m_UInt8 != null) {
                    if (typeof object.m_UInt8 !== "object")
                        throw TypeError(".CS.Value.m_UInt8: object expected");
                    message.m_UInt8 = $root.CS.SeqUInt8.fromObject(object.m_UInt8);
                }
                if (object.m_SInt8 != null) {
                    if (typeof object.m_SInt8 !== "object")
                        throw TypeError(".CS.Value.m_SInt8: object expected");
                    message.m_SInt8 = $root.CS.SeqSInt8.fromObject(object.m_SInt8);
                }
                if (object.m_UInt16 != null) {
                    if (typeof object.m_UInt16 !== "object")
                        throw TypeError(".CS.Value.m_UInt16: object expected");
                    message.m_UInt16 = $root.CS.SeqUInt16.fromObject(object.m_UInt16);
                }
                if (object.m_SInt16 != null) {
                    if (typeof object.m_SInt16 !== "object")
                        throw TypeError(".CS.Value.m_SInt16: object expected");
                    message.m_SInt16 = $root.CS.SeqSInt16.fromObject(object.m_SInt16);
                }
                if (object.m_UInt32 != null) {
                    if (typeof object.m_UInt32 !== "object")
                        throw TypeError(".CS.Value.m_UInt32: object expected");
                    message.m_UInt32 = $root.CS.SeqUInt32.fromObject(object.m_UInt32);
                }
                if (object.m_SInt32 != null) {
                    if (typeof object.m_SInt32 !== "object")
                        throw TypeError(".CS.Value.m_SInt32: object expected");
                    message.m_SInt32 = $root.CS.SeqSInt32.fromObject(object.m_SInt32);
                }
                if (object.m_UInt64 != null) {
                    if (typeof object.m_UInt64 !== "object")
                        throw TypeError(".CS.Value.m_UInt64: object expected");
                    message.m_UInt64 = $root.CS.SeqUInt64.fromObject(object.m_UInt64);
                }
                if (object.m_SInt64 != null) {
                    if (typeof object.m_SInt64 !== "object")
                        throw TypeError(".CS.Value.m_SInt64: object expected");
                    message.m_SInt64 = $root.CS.SeqSInt64.fromObject(object.m_SInt64);
                }
                if (object.m_Float32 != null) {
                    if (typeof object.m_Float32 !== "object")
                        throw TypeError(".CS.Value.m_Float32: object expected");
                    message.m_Float32 = $root.CS.SeqFloat32.fromObject(object.m_Float32);
                }
                if (object.m_Float64 != null) {
                    if (typeof object.m_Float64 !== "object")
                        throw TypeError(".CS.Value.m_Float64: object expected");
                    message.m_Float64 = $root.CS.SeqFloat64.fromObject(object.m_Float64);
                }
                if (object.m_Time != null) {
                    if (typeof object.m_Time !== "object")
                        throw TypeError(".CS.Value.m_Time: object expected");
                    message.m_Time = $root.CS.SeqTime.fromObject(object.m_Time);
                }
                if (object.m_Date != null) {
                    if (typeof object.m_Date !== "object")
                        throw TypeError(".CS.Value.m_Date: object expected");
                    message.m_Date = $root.CS.SeqDate.fromObject(object.m_Date);
                }
                if (object.m_TimeStamp != null) {
                    if (typeof object.m_TimeStamp !== "object")
                        throw TypeError(".CS.Value.m_TimeStamp: object expected");
                    message.m_TimeStamp = $root.CS.SeqTimeStamp.fromObject(object.m_TimeStamp);
                }
                if (object.m_RefCursor != null)
                    message.m_RefCursor = object.m_RefCursor | 0;
                if (object.m_Decimal != null) {
                    if (typeof object.m_Decimal !== "object")
                        throw TypeError(".CS.Value.m_Decimal: object expected");
                    message.m_Decimal = $root.CS.SeqDecimal.fromObject(object.m_Decimal);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Value
             * @static
             * @param {CS.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.m_String != null && message.hasOwnProperty("m_String")) {
                    object.m_String = $root.CS.SeqString.toObject(message.m_String, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_String";
                }
                if (message.m_UTF8String != null && message.hasOwnProperty("m_UTF8String")) {
                    object.m_UTF8String = $root.CS.SeqUTF8String.toObject(message.m_UTF8String, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_UTF8String";
                }
                if (message.m_Binary != null && message.hasOwnProperty("m_Binary")) {
                    object.m_Binary = $root.CS.SeqBinary.toObject(message.m_Binary, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_Binary";
                }
                if (message.m_UInt8 != null && message.hasOwnProperty("m_UInt8")) {
                    object.m_UInt8 = $root.CS.SeqUInt8.toObject(message.m_UInt8, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_UInt8";
                }
                if (message.m_SInt8 != null && message.hasOwnProperty("m_SInt8")) {
                    object.m_SInt8 = $root.CS.SeqSInt8.toObject(message.m_SInt8, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_SInt8";
                }
                if (message.m_UInt16 != null && message.hasOwnProperty("m_UInt16")) {
                    object.m_UInt16 = $root.CS.SeqUInt16.toObject(message.m_UInt16, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_UInt16";
                }
                if (message.m_SInt16 != null && message.hasOwnProperty("m_SInt16")) {
                    object.m_SInt16 = $root.CS.SeqSInt16.toObject(message.m_SInt16, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_SInt16";
                }
                if (message.m_UInt32 != null && message.hasOwnProperty("m_UInt32")) {
                    object.m_UInt32 = $root.CS.SeqUInt32.toObject(message.m_UInt32, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_UInt32";
                }
                if (message.m_SInt32 != null && message.hasOwnProperty("m_SInt32")) {
                    object.m_SInt32 = $root.CS.SeqSInt32.toObject(message.m_SInt32, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_SInt32";
                }
                if (message.m_UInt64 != null && message.hasOwnProperty("m_UInt64")) {
                    object.m_UInt64 = $root.CS.SeqUInt64.toObject(message.m_UInt64, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_UInt64";
                }
                if (message.m_SInt64 != null && message.hasOwnProperty("m_SInt64")) {
                    object.m_SInt64 = $root.CS.SeqSInt64.toObject(message.m_SInt64, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_SInt64";
                }
                if (message.m_Float32 != null && message.hasOwnProperty("m_Float32")) {
                    object.m_Float32 = $root.CS.SeqFloat32.toObject(message.m_Float32, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_Float32";
                }
                if (message.m_Float64 != null && message.hasOwnProperty("m_Float64")) {
                    object.m_Float64 = $root.CS.SeqFloat64.toObject(message.m_Float64, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_Float64";
                }
                if (message.m_Time != null && message.hasOwnProperty("m_Time")) {
                    object.m_Time = $root.CS.SeqTime.toObject(message.m_Time, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_Time";
                }
                if (message.m_Date != null && message.hasOwnProperty("m_Date")) {
                    object.m_Date = $root.CS.SeqDate.toObject(message.m_Date, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_Date";
                }
                if (message.m_TimeStamp != null && message.hasOwnProperty("m_TimeStamp")) {
                    object.m_TimeStamp = $root.CS.SeqTimeStamp.toObject(message.m_TimeStamp, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_TimeStamp";
                }
                if (message.m_RefCursor != null && message.hasOwnProperty("m_RefCursor")) {
                    object.m_RefCursor = message.m_RefCursor;
                    if (options.oneofs)
                        object.ValueUnion = "m_RefCursor";
                }
                if (message.m_Decimal != null && message.hasOwnProperty("m_Decimal")) {
                    object.m_Decimal = $root.CS.SeqDecimal.toObject(message.m_Decimal, options);
                    if (options.oneofs)
                        object.ValueUnion = "m_Decimal";
                }
                return object;
            };
    
            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof CS.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Value;
        })();
    
        CS.Parameter = (function() {
    
            /**
             * Properties of a Parameter.
             * @memberof CS
             * @interface IParameter
             * @property {CS.SQLType|null} [m_SQLType] Parameter m_SQLType
             * @property {CS.Mode|null} [m_Mode] Parameter m_Mode
             * @property {number|Long|null} [m_ElementSize] Parameter m_ElementSize
             * @property {Array.<boolean>|null} [m_IsNull] Parameter m_IsNull
             * @property {CS.IValue|null} [m_Value] Parameter m_Value
             */
    
            /**
             * Constructs a new Parameter.
             * @memberof CS
             * @classdesc Represents a Parameter.
             * @implements IParameter
             * @constructor
             * @param {CS.IParameter=} [properties] Properties to set
             */
            function Parameter(properties) {
                this.m_IsNull = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Parameter m_SQLType.
             * @member {CS.SQLType} m_SQLType
             * @memberof CS.Parameter
             * @instance
             */
            Parameter.prototype.m_SQLType = 0;
    
            /**
             * Parameter m_Mode.
             * @member {CS.Mode} m_Mode
             * @memberof CS.Parameter
             * @instance
             */
            Parameter.prototype.m_Mode = 0;
    
            /**
             * Parameter m_ElementSize.
             * @member {number|Long} m_ElementSize
             * @memberof CS.Parameter
             * @instance
             */
            Parameter.prototype.m_ElementSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Parameter m_IsNull.
             * @member {Array.<boolean>} m_IsNull
             * @memberof CS.Parameter
             * @instance
             */
            Parameter.prototype.m_IsNull = $util.emptyArray;
    
            /**
             * Parameter m_Value.
             * @member {CS.IValue|null|undefined} m_Value
             * @memberof CS.Parameter
             * @instance
             */
            Parameter.prototype.m_Value = null;
    
            /**
             * Creates a new Parameter instance using the specified properties.
             * @function create
             * @memberof CS.Parameter
             * @static
             * @param {CS.IParameter=} [properties] Properties to set
             * @returns {CS.Parameter} Parameter instance
             */
            Parameter.create = function create(properties) {
                return new Parameter(properties);
            };
    
            /**
             * Encodes the specified Parameter message. Does not implicitly {@link CS.Parameter.verify|verify} messages.
             * @function encode
             * @memberof CS.Parameter
             * @static
             * @param {CS.IParameter} message Parameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Parameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_SQLType != null && Object.hasOwnProperty.call(message, "m_SQLType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.m_SQLType);
                if (message.m_Mode != null && Object.hasOwnProperty.call(message, "m_Mode"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.m_Mode);
                if (message.m_ElementSize != null && Object.hasOwnProperty.call(message, "m_ElementSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.m_ElementSize);
                if (message.m_IsNull != null && message.m_IsNull.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (var i = 0; i < message.m_IsNull.length; ++i)
                        writer.bool(message.m_IsNull[i]);
                    writer.ldelim();
                }
                if (message.m_Value != null && Object.hasOwnProperty.call(message, "m_Value"))
                    $root.CS.Value.encode(message.m_Value, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Parameter message, length delimited. Does not implicitly {@link CS.Parameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Parameter
             * @static
             * @param {CS.IParameter} message Parameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Parameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Parameter message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Parameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Parameter} Parameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Parameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Parameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_SQLType = reader.int32();
                        break;
                    case 2:
                        message.m_Mode = reader.int32();
                        break;
                    case 3:
                        message.m_ElementSize = reader.uint64();
                        break;
                    case 4:
                        if (!(message.m_IsNull && message.m_IsNull.length))
                            message.m_IsNull = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.m_IsNull.push(reader.bool());
                        } else
                            message.m_IsNull.push(reader.bool());
                        break;
                    case 5:
                        message.m_Value = $root.CS.Value.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Parameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Parameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Parameter} Parameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Parameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Parameter message.
             * @function verify
             * @memberof CS.Parameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Parameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_SQLType != null && message.hasOwnProperty("m_SQLType"))
                    switch (message.m_SQLType) {
                    default:
                        return "m_SQLType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                        break;
                    }
                if (message.m_Mode != null && message.hasOwnProperty("m_Mode"))
                    switch (message.m_Mode) {
                    default:
                        return "m_Mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.m_ElementSize != null && message.hasOwnProperty("m_ElementSize"))
                    if (!$util.isInteger(message.m_ElementSize) && !(message.m_ElementSize && $util.isInteger(message.m_ElementSize.low) && $util.isInteger(message.m_ElementSize.high)))
                        return "m_ElementSize: integer|Long expected";
                if (message.m_IsNull != null && message.hasOwnProperty("m_IsNull")) {
                    if (!Array.isArray(message.m_IsNull))
                        return "m_IsNull: array expected";
                    for (var i = 0; i < message.m_IsNull.length; ++i)
                        if (typeof message.m_IsNull[i] !== "boolean")
                            return "m_IsNull: boolean[] expected";
                }
                if (message.m_Value != null && message.hasOwnProperty("m_Value")) {
                    var error = $root.CS.Value.verify(message.m_Value);
                    if (error)
                        return "m_Value." + error;
                }
                return null;
            };
    
            /**
             * Creates a Parameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Parameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Parameter} Parameter
             */
            Parameter.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Parameter)
                    return object;
                var message = new $root.CS.Parameter();
                switch (object.m_SQLType) {
                case "Unknown_SQLType":
                case 0:
                    message.m_SQLType = 0;
                    break;
                case "SQL_Default":
                case 1:
                    message.m_SQLType = 1;
                    break;
                case "SQL_Char":
                case 2:
                    message.m_SQLType = 2;
                    break;
                case "SQL_VarChar":
                case 3:
                    message.m_SQLType = 3;
                    break;
                case "SQL_LongVarChar":
                case 4:
                    message.m_SQLType = 4;
                    break;
                case "SQL_Xml":
                case 5:
                    message.m_SQLType = 5;
                    break;
                case "SQL_Binary":
                case 6:
                    message.m_SQLType = 6;
                    break;
                case "SQL_VarBinary":
                case 7:
                    message.m_SQLType = 7;
                    break;
                case "SQL_LongVarBinary":
                case 8:
                    message.m_SQLType = 8;
                    break;
                case "SQL_Bit":
                case 9:
                    message.m_SQLType = 9;
                    break;
                case "SQL_TinyInt":
                case 10:
                    message.m_SQLType = 10;
                    break;
                case "SQL_SmallInt":
                case 11:
                    message.m_SQLType = 11;
                    break;
                case "SQL_Integer":
                case 12:
                    message.m_SQLType = 12;
                    break;
                case "SQL_BigInt":
                case 13:
                    message.m_SQLType = 13;
                    break;
                case "SQL_Decimal":
                case 14:
                    message.m_SQLType = 14;
                    break;
                case "SQL_Numeric":
                case 15:
                    message.m_SQLType = 15;
                    break;
                case "SQL_Real":
                case 16:
                    message.m_SQLType = 16;
                    break;
                case "SQL_Float":
                case 17:
                    message.m_SQLType = 17;
                    break;
                case "SQL_Double":
                case 18:
                    message.m_SQLType = 18;
                    break;
                case "SQL_Time":
                case 19:
                    message.m_SQLType = 19;
                    break;
                case "SQL_Date":
                case 20:
                    message.m_SQLType = 20;
                    break;
                case "SQL_TimeStamp":
                case 21:
                    message.m_SQLType = 21;
                    break;
                case "SQL_RefCursor":
                case 22:
                    message.m_SQLType = 22;
                    break;
                case "SQL_Extended":
                case 23:
                    message.m_SQLType = 23;
                    break;
                case "SQL_Unsupported":
                case 24:
                    message.m_SQLType = 24;
                    break;
                }
                switch (object.m_Mode) {
                case "Unknown_Mode":
                case 0:
                    message.m_Mode = 0;
                    break;
                case "InMode":
                case 1:
                    message.m_Mode = 1;
                    break;
                case "OutMode":
                case 2:
                    message.m_Mode = 2;
                    break;
                case "InOutMode":
                case 3:
                    message.m_Mode = 3;
                    break;
                }
                if (object.m_ElementSize != null)
                    if ($util.Long)
                        (message.m_ElementSize = $util.Long.fromValue(object.m_ElementSize)).unsigned = true;
                    else if (typeof object.m_ElementSize === "string")
                        message.m_ElementSize = parseInt(object.m_ElementSize, 10);
                    else if (typeof object.m_ElementSize === "number")
                        message.m_ElementSize = object.m_ElementSize;
                    else if (typeof object.m_ElementSize === "object")
                        message.m_ElementSize = new $util.LongBits(object.m_ElementSize.low >>> 0, object.m_ElementSize.high >>> 0).toNumber(true);
                if (object.m_IsNull) {
                    if (!Array.isArray(object.m_IsNull))
                        throw TypeError(".CS.Parameter.m_IsNull: array expected");
                    message.m_IsNull = [];
                    for (var i = 0; i < object.m_IsNull.length; ++i)
                        message.m_IsNull[i] = Boolean(object.m_IsNull[i]);
                }
                if (object.m_Value != null) {
                    if (typeof object.m_Value !== "object")
                        throw TypeError(".CS.Parameter.m_Value: object expected");
                    message.m_Value = $root.CS.Value.fromObject(object.m_Value);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Parameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Parameter
             * @static
             * @param {CS.Parameter} message Parameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Parameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.m_IsNull = [];
                if (options.defaults) {
                    object.m_SQLType = options.enums === String ? "Unknown_SQLType" : 0;
                    object.m_Mode = options.enums === String ? "Unknown_Mode" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.m_ElementSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.m_ElementSize = options.longs === String ? "0" : 0;
                    object.m_Value = null;
                }
                if (message.m_SQLType != null && message.hasOwnProperty("m_SQLType"))
                    object.m_SQLType = options.enums === String ? $root.CS.SQLType[message.m_SQLType] : message.m_SQLType;
                if (message.m_Mode != null && message.hasOwnProperty("m_Mode"))
                    object.m_Mode = options.enums === String ? $root.CS.Mode[message.m_Mode] : message.m_Mode;
                if (message.m_ElementSize != null && message.hasOwnProperty("m_ElementSize"))
                    if (typeof message.m_ElementSize === "number")
                        object.m_ElementSize = options.longs === String ? String(message.m_ElementSize) : message.m_ElementSize;
                    else
                        object.m_ElementSize = options.longs === String ? $util.Long.prototype.toString.call(message.m_ElementSize) : options.longs === Number ? new $util.LongBits(message.m_ElementSize.low >>> 0, message.m_ElementSize.high >>> 0).toNumber(true) : message.m_ElementSize;
                if (message.m_IsNull && message.m_IsNull.length) {
                    object.m_IsNull = [];
                    for (var j = 0; j < message.m_IsNull.length; ++j)
                        object.m_IsNull[j] = message.m_IsNull[j];
                }
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    object.m_Value = $root.CS.Value.toObject(message.m_Value, options);
                return object;
            };
    
            /**
             * Converts this Parameter to JSON.
             * @function toJSON
             * @memberof CS.Parameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Parameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Parameter;
        })();
    
        CS.FieldInfo = (function() {
    
            /**
             * Properties of a FieldInfo.
             * @memberof CS
             * @interface IFieldInfo
             * @property {string|null} [m_Name] FieldInfo m_Name
             * @property {CS.SQLType|null} [m_DataType] FieldInfo m_DataType
             * @property {number|Long|null} [m_DBSize] FieldInfo m_DBSize
             * @property {number|Long|null} [m_DisplaySize] FieldInfo m_DisplaySize
             * @property {number|null} [m_DecimalDigits] FieldInfo m_DecimalDigits
             * @property {boolean|null} [m_Nullable] FieldInfo m_Nullable
             * @property {boolean|null} [m_Unsigned] FieldInfo m_Unsigned
             * @property {number|null} [m_SortLevel] FieldInfo m_SortLevel
             * @property {boolean|null} [m_SortAscending] FieldInfo m_SortAscending
             * @property {number|null} [m_InputColumn] FieldInfo m_InputColumn
             * @property {string|null} [m_TypeName] FieldInfo m_TypeName
             */
    
            /**
             * Constructs a new FieldInfo.
             * @memberof CS
             * @classdesc Represents a FieldInfo.
             * @implements IFieldInfo
             * @constructor
             * @param {CS.IFieldInfo=} [properties] Properties to set
             */
            function FieldInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FieldInfo m_Name.
             * @member {string} m_Name
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_Name = "";
    
            /**
             * FieldInfo m_DataType.
             * @member {CS.SQLType} m_DataType
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_DataType = 0;
    
            /**
             * FieldInfo m_DBSize.
             * @member {number|Long} m_DBSize
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_DBSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * FieldInfo m_DisplaySize.
             * @member {number|Long} m_DisplaySize
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_DisplaySize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * FieldInfo m_DecimalDigits.
             * @member {number} m_DecimalDigits
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_DecimalDigits = 0;
    
            /**
             * FieldInfo m_Nullable.
             * @member {boolean} m_Nullable
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_Nullable = false;
    
            /**
             * FieldInfo m_Unsigned.
             * @member {boolean} m_Unsigned
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_Unsigned = false;
    
            /**
             * FieldInfo m_SortLevel.
             * @member {number} m_SortLevel
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_SortLevel = 0;
    
            /**
             * FieldInfo m_SortAscending.
             * @member {boolean} m_SortAscending
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_SortAscending = false;
    
            /**
             * FieldInfo m_InputColumn.
             * @member {number} m_InputColumn
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_InputColumn = 0;
    
            /**
             * FieldInfo m_TypeName.
             * @member {string} m_TypeName
             * @memberof CS.FieldInfo
             * @instance
             */
            FieldInfo.prototype.m_TypeName = "";
    
            /**
             * Creates a new FieldInfo instance using the specified properties.
             * @function create
             * @memberof CS.FieldInfo
             * @static
             * @param {CS.IFieldInfo=} [properties] Properties to set
             * @returns {CS.FieldInfo} FieldInfo instance
             */
            FieldInfo.create = function create(properties) {
                return new FieldInfo(properties);
            };
    
            /**
             * Encodes the specified FieldInfo message. Does not implicitly {@link CS.FieldInfo.verify|verify} messages.
             * @function encode
             * @memberof CS.FieldInfo
             * @static
             * @param {CS.IFieldInfo} message FieldInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Name);
                if (message.m_DataType != null && Object.hasOwnProperty.call(message, "m_DataType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.m_DataType);
                if (message.m_DBSize != null && Object.hasOwnProperty.call(message, "m_DBSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.m_DBSize);
                if (message.m_DisplaySize != null && Object.hasOwnProperty.call(message, "m_DisplaySize"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.m_DisplaySize);
                if (message.m_DecimalDigits != null && Object.hasOwnProperty.call(message, "m_DecimalDigits"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.m_DecimalDigits);
                if (message.m_Nullable != null && Object.hasOwnProperty.call(message, "m_Nullable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.m_Nullable);
                if (message.m_Unsigned != null && Object.hasOwnProperty.call(message, "m_Unsigned"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.m_Unsigned);
                if (message.m_SortLevel != null && Object.hasOwnProperty.call(message, "m_SortLevel"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.m_SortLevel);
                if (message.m_SortAscending != null && Object.hasOwnProperty.call(message, "m_SortAscending"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.m_SortAscending);
                if (message.m_InputColumn != null && Object.hasOwnProperty.call(message, "m_InputColumn"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.m_InputColumn);
                if (message.m_TypeName != null && Object.hasOwnProperty.call(message, "m_TypeName"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.m_TypeName);
                return writer;
            };
    
            /**
             * Encodes the specified FieldInfo message, length delimited. Does not implicitly {@link CS.FieldInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.FieldInfo
             * @static
             * @param {CS.IFieldInfo} message FieldInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FieldInfo message from the specified reader or buffer.
             * @function decode
             * @memberof CS.FieldInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.FieldInfo} FieldInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.FieldInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Name = reader.string();
                        break;
                    case 2:
                        message.m_DataType = reader.int32();
                        break;
                    case 3:
                        message.m_DBSize = reader.uint64();
                        break;
                    case 4:
                        message.m_DisplaySize = reader.uint64();
                        break;
                    case 5:
                        message.m_DecimalDigits = reader.uint32();
                        break;
                    case 6:
                        message.m_Nullable = reader.bool();
                        break;
                    case 7:
                        message.m_Unsigned = reader.bool();
                        break;
                    case 8:
                        message.m_SortLevel = reader.uint32();
                        break;
                    case 9:
                        message.m_SortAscending = reader.bool();
                        break;
                    case 10:
                        message.m_InputColumn = reader.uint32();
                        break;
                    case 11:
                        message.m_TypeName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FieldInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.FieldInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.FieldInfo} FieldInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FieldInfo message.
             * @function verify
             * @memberof CS.FieldInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_DataType != null && message.hasOwnProperty("m_DataType"))
                    switch (message.m_DataType) {
                    default:
                        return "m_DataType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                        break;
                    }
                if (message.m_DBSize != null && message.hasOwnProperty("m_DBSize"))
                    if (!$util.isInteger(message.m_DBSize) && !(message.m_DBSize && $util.isInteger(message.m_DBSize.low) && $util.isInteger(message.m_DBSize.high)))
                        return "m_DBSize: integer|Long expected";
                if (message.m_DisplaySize != null && message.hasOwnProperty("m_DisplaySize"))
                    if (!$util.isInteger(message.m_DisplaySize) && !(message.m_DisplaySize && $util.isInteger(message.m_DisplaySize.low) && $util.isInteger(message.m_DisplaySize.high)))
                        return "m_DisplaySize: integer|Long expected";
                if (message.m_DecimalDigits != null && message.hasOwnProperty("m_DecimalDigits"))
                    if (!$util.isInteger(message.m_DecimalDigits))
                        return "m_DecimalDigits: integer expected";
                if (message.m_Nullable != null && message.hasOwnProperty("m_Nullable"))
                    if (typeof message.m_Nullable !== "boolean")
                        return "m_Nullable: boolean expected";
                if (message.m_Unsigned != null && message.hasOwnProperty("m_Unsigned"))
                    if (typeof message.m_Unsigned !== "boolean")
                        return "m_Unsigned: boolean expected";
                if (message.m_SortLevel != null && message.hasOwnProperty("m_SortLevel"))
                    if (!$util.isInteger(message.m_SortLevel))
                        return "m_SortLevel: integer expected";
                if (message.m_SortAscending != null && message.hasOwnProperty("m_SortAscending"))
                    if (typeof message.m_SortAscending !== "boolean")
                        return "m_SortAscending: boolean expected";
                if (message.m_InputColumn != null && message.hasOwnProperty("m_InputColumn"))
                    if (!$util.isInteger(message.m_InputColumn))
                        return "m_InputColumn: integer expected";
                if (message.m_TypeName != null && message.hasOwnProperty("m_TypeName"))
                    if (!$util.isString(message.m_TypeName))
                        return "m_TypeName: string expected";
                return null;
            };
    
            /**
             * Creates a FieldInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.FieldInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.FieldInfo} FieldInfo
             */
            FieldInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.FieldInfo)
                    return object;
                var message = new $root.CS.FieldInfo();
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                switch (object.m_DataType) {
                case "Unknown_SQLType":
                case 0:
                    message.m_DataType = 0;
                    break;
                case "SQL_Default":
                case 1:
                    message.m_DataType = 1;
                    break;
                case "SQL_Char":
                case 2:
                    message.m_DataType = 2;
                    break;
                case "SQL_VarChar":
                case 3:
                    message.m_DataType = 3;
                    break;
                case "SQL_LongVarChar":
                case 4:
                    message.m_DataType = 4;
                    break;
                case "SQL_Xml":
                case 5:
                    message.m_DataType = 5;
                    break;
                case "SQL_Binary":
                case 6:
                    message.m_DataType = 6;
                    break;
                case "SQL_VarBinary":
                case 7:
                    message.m_DataType = 7;
                    break;
                case "SQL_LongVarBinary":
                case 8:
                    message.m_DataType = 8;
                    break;
                case "SQL_Bit":
                case 9:
                    message.m_DataType = 9;
                    break;
                case "SQL_TinyInt":
                case 10:
                    message.m_DataType = 10;
                    break;
                case "SQL_SmallInt":
                case 11:
                    message.m_DataType = 11;
                    break;
                case "SQL_Integer":
                case 12:
                    message.m_DataType = 12;
                    break;
                case "SQL_BigInt":
                case 13:
                    message.m_DataType = 13;
                    break;
                case "SQL_Decimal":
                case 14:
                    message.m_DataType = 14;
                    break;
                case "SQL_Numeric":
                case 15:
                    message.m_DataType = 15;
                    break;
                case "SQL_Real":
                case 16:
                    message.m_DataType = 16;
                    break;
                case "SQL_Float":
                case 17:
                    message.m_DataType = 17;
                    break;
                case "SQL_Double":
                case 18:
                    message.m_DataType = 18;
                    break;
                case "SQL_Time":
                case 19:
                    message.m_DataType = 19;
                    break;
                case "SQL_Date":
                case 20:
                    message.m_DataType = 20;
                    break;
                case "SQL_TimeStamp":
                case 21:
                    message.m_DataType = 21;
                    break;
                case "SQL_RefCursor":
                case 22:
                    message.m_DataType = 22;
                    break;
                case "SQL_Extended":
                case 23:
                    message.m_DataType = 23;
                    break;
                case "SQL_Unsupported":
                case 24:
                    message.m_DataType = 24;
                    break;
                }
                if (object.m_DBSize != null)
                    if ($util.Long)
                        (message.m_DBSize = $util.Long.fromValue(object.m_DBSize)).unsigned = true;
                    else if (typeof object.m_DBSize === "string")
                        message.m_DBSize = parseInt(object.m_DBSize, 10);
                    else if (typeof object.m_DBSize === "number")
                        message.m_DBSize = object.m_DBSize;
                    else if (typeof object.m_DBSize === "object")
                        message.m_DBSize = new $util.LongBits(object.m_DBSize.low >>> 0, object.m_DBSize.high >>> 0).toNumber(true);
                if (object.m_DisplaySize != null)
                    if ($util.Long)
                        (message.m_DisplaySize = $util.Long.fromValue(object.m_DisplaySize)).unsigned = true;
                    else if (typeof object.m_DisplaySize === "string")
                        message.m_DisplaySize = parseInt(object.m_DisplaySize, 10);
                    else if (typeof object.m_DisplaySize === "number")
                        message.m_DisplaySize = object.m_DisplaySize;
                    else if (typeof object.m_DisplaySize === "object")
                        message.m_DisplaySize = new $util.LongBits(object.m_DisplaySize.low >>> 0, object.m_DisplaySize.high >>> 0).toNumber(true);
                if (object.m_DecimalDigits != null)
                    message.m_DecimalDigits = object.m_DecimalDigits >>> 0;
                if (object.m_Nullable != null)
                    message.m_Nullable = Boolean(object.m_Nullable);
                if (object.m_Unsigned != null)
                    message.m_Unsigned = Boolean(object.m_Unsigned);
                if (object.m_SortLevel != null)
                    message.m_SortLevel = object.m_SortLevel >>> 0;
                if (object.m_SortAscending != null)
                    message.m_SortAscending = Boolean(object.m_SortAscending);
                if (object.m_InputColumn != null)
                    message.m_InputColumn = object.m_InputColumn >>> 0;
                if (object.m_TypeName != null)
                    message.m_TypeName = String(object.m_TypeName);
                return message;
            };
    
            /**
             * Creates a plain object from a FieldInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.FieldInfo
             * @static
             * @param {CS.FieldInfo} message FieldInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Name = "";
                    object.m_DataType = options.enums === String ? "Unknown_SQLType" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.m_DBSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.m_DBSize = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.m_DisplaySize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.m_DisplaySize = options.longs === String ? "0" : 0;
                    object.m_DecimalDigits = 0;
                    object.m_Nullable = false;
                    object.m_Unsigned = false;
                    object.m_SortLevel = 0;
                    object.m_SortAscending = false;
                    object.m_InputColumn = 0;
                    object.m_TypeName = "";
                }
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_DataType != null && message.hasOwnProperty("m_DataType"))
                    object.m_DataType = options.enums === String ? $root.CS.SQLType[message.m_DataType] : message.m_DataType;
                if (message.m_DBSize != null && message.hasOwnProperty("m_DBSize"))
                    if (typeof message.m_DBSize === "number")
                        object.m_DBSize = options.longs === String ? String(message.m_DBSize) : message.m_DBSize;
                    else
                        object.m_DBSize = options.longs === String ? $util.Long.prototype.toString.call(message.m_DBSize) : options.longs === Number ? new $util.LongBits(message.m_DBSize.low >>> 0, message.m_DBSize.high >>> 0).toNumber(true) : message.m_DBSize;
                if (message.m_DisplaySize != null && message.hasOwnProperty("m_DisplaySize"))
                    if (typeof message.m_DisplaySize === "number")
                        object.m_DisplaySize = options.longs === String ? String(message.m_DisplaySize) : message.m_DisplaySize;
                    else
                        object.m_DisplaySize = options.longs === String ? $util.Long.prototype.toString.call(message.m_DisplaySize) : options.longs === Number ? new $util.LongBits(message.m_DisplaySize.low >>> 0, message.m_DisplaySize.high >>> 0).toNumber(true) : message.m_DisplaySize;
                if (message.m_DecimalDigits != null && message.hasOwnProperty("m_DecimalDigits"))
                    object.m_DecimalDigits = message.m_DecimalDigits;
                if (message.m_Nullable != null && message.hasOwnProperty("m_Nullable"))
                    object.m_Nullable = message.m_Nullable;
                if (message.m_Unsigned != null && message.hasOwnProperty("m_Unsigned"))
                    object.m_Unsigned = message.m_Unsigned;
                if (message.m_SortLevel != null && message.hasOwnProperty("m_SortLevel"))
                    object.m_SortLevel = message.m_SortLevel;
                if (message.m_SortAscending != null && message.hasOwnProperty("m_SortAscending"))
                    object.m_SortAscending = message.m_SortAscending;
                if (message.m_InputColumn != null && message.hasOwnProperty("m_InputColumn"))
                    object.m_InputColumn = message.m_InputColumn;
                if (message.m_TypeName != null && message.hasOwnProperty("m_TypeName"))
                    object.m_TypeName = message.m_TypeName;
                return object;
            };
    
            /**
             * Converts this FieldInfo to JSON.
             * @function toJSON
             * @memberof CS.FieldInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FieldInfo;
        })();
    
        CS.ColumnDescription = (function() {
    
            /**
             * Properties of a ColumnDescription.
             * @memberof CS
             * @interface IColumnDescription
             * @property {CS.IFieldInfo|null} [m_Info] ColumnDescription m_Info
             * @property {number|Long|null} [m_Size] ColumnDescription m_Size
             * @property {CS.CType|null} [m_CDataType] ColumnDescription m_CDataType
             */
    
            /**
             * Constructs a new ColumnDescription.
             * @memberof CS
             * @classdesc Represents a ColumnDescription.
             * @implements IColumnDescription
             * @constructor
             * @param {CS.IColumnDescription=} [properties] Properties to set
             */
            function ColumnDescription(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ColumnDescription m_Info.
             * @member {CS.IFieldInfo|null|undefined} m_Info
             * @memberof CS.ColumnDescription
             * @instance
             */
            ColumnDescription.prototype.m_Info = null;
    
            /**
             * ColumnDescription m_Size.
             * @member {number|Long} m_Size
             * @memberof CS.ColumnDescription
             * @instance
             */
            ColumnDescription.prototype.m_Size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ColumnDescription m_CDataType.
             * @member {CS.CType} m_CDataType
             * @memberof CS.ColumnDescription
             * @instance
             */
            ColumnDescription.prototype.m_CDataType = 0;
    
            /**
             * Creates a new ColumnDescription instance using the specified properties.
             * @function create
             * @memberof CS.ColumnDescription
             * @static
             * @param {CS.IColumnDescription=} [properties] Properties to set
             * @returns {CS.ColumnDescription} ColumnDescription instance
             */
            ColumnDescription.create = function create(properties) {
                return new ColumnDescription(properties);
            };
    
            /**
             * Encodes the specified ColumnDescription message. Does not implicitly {@link CS.ColumnDescription.verify|verify} messages.
             * @function encode
             * @memberof CS.ColumnDescription
             * @static
             * @param {CS.IColumnDescription} message ColumnDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Info != null && Object.hasOwnProperty.call(message, "m_Info"))
                    $root.CS.FieldInfo.encode(message.m_Info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_Size != null && Object.hasOwnProperty.call(message, "m_Size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.m_Size);
                if (message.m_CDataType != null && Object.hasOwnProperty.call(message, "m_CDataType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.m_CDataType);
                return writer;
            };
    
            /**
             * Encodes the specified ColumnDescription message, length delimited. Does not implicitly {@link CS.ColumnDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.ColumnDescription
             * @static
             * @param {CS.IColumnDescription} message ColumnDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ColumnDescription message from the specified reader or buffer.
             * @function decode
             * @memberof CS.ColumnDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.ColumnDescription} ColumnDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.ColumnDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Info = $root.CS.FieldInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.m_Size = reader.uint64();
                        break;
                    case 3:
                        message.m_CDataType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ColumnDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.ColumnDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.ColumnDescription} ColumnDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ColumnDescription message.
             * @function verify
             * @memberof CS.ColumnDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Info != null && message.hasOwnProperty("m_Info")) {
                    var error = $root.CS.FieldInfo.verify(message.m_Info);
                    if (error)
                        return "m_Info." + error;
                }
                if (message.m_Size != null && message.hasOwnProperty("m_Size"))
                    if (!$util.isInteger(message.m_Size) && !(message.m_Size && $util.isInteger(message.m_Size.low) && $util.isInteger(message.m_Size.high)))
                        return "m_Size: integer|Long expected";
                if (message.m_CDataType != null && message.hasOwnProperty("m_CDataType"))
                    switch (message.m_CDataType) {
                    default:
                        return "m_CDataType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a ColumnDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.ColumnDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.ColumnDescription} ColumnDescription
             */
            ColumnDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.ColumnDescription)
                    return object;
                var message = new $root.CS.ColumnDescription();
                if (object.m_Info != null) {
                    if (typeof object.m_Info !== "object")
                        throw TypeError(".CS.ColumnDescription.m_Info: object expected");
                    message.m_Info = $root.CS.FieldInfo.fromObject(object.m_Info);
                }
                if (object.m_Size != null)
                    if ($util.Long)
                        (message.m_Size = $util.Long.fromValue(object.m_Size)).unsigned = true;
                    else if (typeof object.m_Size === "string")
                        message.m_Size = parseInt(object.m_Size, 10);
                    else if (typeof object.m_Size === "number")
                        message.m_Size = object.m_Size;
                    else if (typeof object.m_Size === "object")
                        message.m_Size = new $util.LongBits(object.m_Size.low >>> 0, object.m_Size.high >>> 0).toNumber(true);
                switch (object.m_CDataType) {
                case "Unknown_CType":
                case 0:
                    message.m_CDataType = 0;
                    break;
                case "C_Default":
                case 1:
                    message.m_CDataType = 1;
                    break;
                case "C_Char":
                case 2:
                    message.m_CDataType = 2;
                    break;
                case "C_String":
                case 3:
                    message.m_CDataType = 3;
                    break;
                case "C_UTF8Char":
                case 4:
                    message.m_CDataType = 4;
                    break;
                case "C_UTF8String":
                case 5:
                    message.m_CDataType = 5;
                    break;
                case "C_UCS2Char":
                case 6:
                    message.m_CDataType = 6;
                    break;
                case "C_UCS2String":
                case 7:
                    message.m_CDataType = 7;
                    break;
                case "C_Binary":
                case 8:
                    message.m_CDataType = 8;
                    break;
                case "C_UInt8":
                case 9:
                    message.m_CDataType = 9;
                    break;
                case "C_SInt8":
                case 10:
                    message.m_CDataType = 10;
                    break;
                case "C_UInt16":
                case 11:
                    message.m_CDataType = 11;
                    break;
                case "C_SInt16":
                case 12:
                    message.m_CDataType = 12;
                    break;
                case "C_UInt32":
                case 13:
                    message.m_CDataType = 13;
                    break;
                case "C_SInt32":
                case 14:
                    message.m_CDataType = 14;
                    break;
                case "C_UInt64":
                case 15:
                    message.m_CDataType = 15;
                    break;
                case "C_SInt64":
                case 16:
                    message.m_CDataType = 16;
                    break;
                case "C_Float32":
                case 17:
                    message.m_CDataType = 17;
                    break;
                case "C_Float64":
                case 18:
                    message.m_CDataType = 18;
                    break;
                case "C_CTime":
                case 19:
                    message.m_CDataType = 19;
                    break;
                case "C_CDate":
                case 20:
                    message.m_CDataType = 20;
                    break;
                case "C_CTimeStamp":
                case 21:
                    message.m_CDataType = 21;
                    break;
                case "C_RefCursor":
                case 22:
                    message.m_CDataType = 22;
                    break;
                case "C_Blob":
                case 23:
                    message.m_CDataType = 23;
                    break;
                case "C_Clob":
                case 24:
                    message.m_CDataType = 24;
                    break;
                case "C_Decimal":
                case 25:
                    message.m_CDataType = 25;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ColumnDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.ColumnDescription
             * @static
             * @param {CS.ColumnDescription} message ColumnDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Info = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.m_Size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.m_Size = options.longs === String ? "0" : 0;
                    object.m_CDataType = options.enums === String ? "Unknown_CType" : 0;
                }
                if (message.m_Info != null && message.hasOwnProperty("m_Info"))
                    object.m_Info = $root.CS.FieldInfo.toObject(message.m_Info, options);
                if (message.m_Size != null && message.hasOwnProperty("m_Size"))
                    if (typeof message.m_Size === "number")
                        object.m_Size = options.longs === String ? String(message.m_Size) : message.m_Size;
                    else
                        object.m_Size = options.longs === String ? $util.Long.prototype.toString.call(message.m_Size) : options.longs === Number ? new $util.LongBits(message.m_Size.low >>> 0, message.m_Size.high >>> 0).toNumber(true) : message.m_Size;
                if (message.m_CDataType != null && message.hasOwnProperty("m_CDataType"))
                    object.m_CDataType = options.enums === String ? $root.CS.CType[message.m_CDataType] : message.m_CDataType;
                return object;
            };
    
            /**
             * Converts this ColumnDescription to JSON.
             * @function toJSON
             * @memberof CS.ColumnDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ColumnDescription;
        })();
    
        CS.DescriptionSet = (function() {
    
            /**
             * Properties of a DescriptionSet.
             * @memberof CS
             * @interface IDescriptionSet
             * @property {Array.<CS.IColumnDescription>|null} [mDescList] DescriptionSet mDescList
             * @property {number|null} [m_CostEstimate] DescriptionSet m_CostEstimate
             */
    
            /**
             * Constructs a new DescriptionSet.
             * @memberof CS
             * @classdesc Represents a DescriptionSet.
             * @implements IDescriptionSet
             * @constructor
             * @param {CS.IDescriptionSet=} [properties] Properties to set
             */
            function DescriptionSet(properties) {
                this.mDescList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DescriptionSet mDescList.
             * @member {Array.<CS.IColumnDescription>} mDescList
             * @memberof CS.DescriptionSet
             * @instance
             */
            DescriptionSet.prototype.mDescList = $util.emptyArray;
    
            /**
             * DescriptionSet m_CostEstimate.
             * @member {number} m_CostEstimate
             * @memberof CS.DescriptionSet
             * @instance
             */
            DescriptionSet.prototype.m_CostEstimate = 0;
    
            /**
             * Creates a new DescriptionSet instance using the specified properties.
             * @function create
             * @memberof CS.DescriptionSet
             * @static
             * @param {CS.IDescriptionSet=} [properties] Properties to set
             * @returns {CS.DescriptionSet} DescriptionSet instance
             */
            DescriptionSet.create = function create(properties) {
                return new DescriptionSet(properties);
            };
    
            /**
             * Encodes the specified DescriptionSet message. Does not implicitly {@link CS.DescriptionSet.verify|verify} messages.
             * @function encode
             * @memberof CS.DescriptionSet
             * @static
             * @param {CS.IDescriptionSet} message DescriptionSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptionSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mDescList != null && message.mDescList.length)
                    for (var i = 0; i < message.mDescList.length; ++i)
                        $root.CS.ColumnDescription.encode(message.mDescList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_CostEstimate != null && Object.hasOwnProperty.call(message, "m_CostEstimate"))
                    writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.m_CostEstimate);
                return writer;
            };
    
            /**
             * Encodes the specified DescriptionSet message, length delimited. Does not implicitly {@link CS.DescriptionSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.DescriptionSet
             * @static
             * @param {CS.IDescriptionSet} message DescriptionSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptionSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DescriptionSet message from the specified reader or buffer.
             * @function decode
             * @memberof CS.DescriptionSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.DescriptionSet} DescriptionSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptionSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.DescriptionSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.mDescList && message.mDescList.length))
                            message.mDescList = [];
                        message.mDescList.push($root.CS.ColumnDescription.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.m_CostEstimate = reader.sint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DescriptionSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.DescriptionSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.DescriptionSet} DescriptionSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptionSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DescriptionSet message.
             * @function verify
             * @memberof CS.DescriptionSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptionSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mDescList != null && message.hasOwnProperty("mDescList")) {
                    if (!Array.isArray(message.mDescList))
                        return "mDescList: array expected";
                    for (var i = 0; i < message.mDescList.length; ++i) {
                        var error = $root.CS.ColumnDescription.verify(message.mDescList[i]);
                        if (error)
                            return "mDescList." + error;
                    }
                }
                if (message.m_CostEstimate != null && message.hasOwnProperty("m_CostEstimate"))
                    if (!$util.isInteger(message.m_CostEstimate))
                        return "m_CostEstimate: integer expected";
                return null;
            };
    
            /**
             * Creates a DescriptionSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.DescriptionSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.DescriptionSet} DescriptionSet
             */
            DescriptionSet.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.DescriptionSet)
                    return object;
                var message = new $root.CS.DescriptionSet();
                if (object.mDescList) {
                    if (!Array.isArray(object.mDescList))
                        throw TypeError(".CS.DescriptionSet.mDescList: array expected");
                    message.mDescList = [];
                    for (var i = 0; i < object.mDescList.length; ++i) {
                        if (typeof object.mDescList[i] !== "object")
                            throw TypeError(".CS.DescriptionSet.mDescList: object expected");
                        message.mDescList[i] = $root.CS.ColumnDescription.fromObject(object.mDescList[i]);
                    }
                }
                if (object.m_CostEstimate != null)
                    message.m_CostEstimate = object.m_CostEstimate | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a DescriptionSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.DescriptionSet
             * @static
             * @param {CS.DescriptionSet} message DescriptionSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptionSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.mDescList = [];
                if (options.defaults)
                    object.m_CostEstimate = 0;
                if (message.mDescList && message.mDescList.length) {
                    object.mDescList = [];
                    for (var j = 0; j < message.mDescList.length; ++j)
                        object.mDescList[j] = $root.CS.ColumnDescription.toObject(message.mDescList[j], options);
                }
                if (message.m_CostEstimate != null && message.hasOwnProperty("m_CostEstimate"))
                    object.m_CostEstimate = message.m_CostEstimate;
                return object;
            };
    
            /**
             * Converts this DescriptionSet to JSON.
             * @function toJSON
             * @memberof CS.DescriptionSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptionSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DescriptionSet;
        })();
    
        /**
         * FieldType enum.
         * @name CS.FieldType
         * @enum {number}
         * @property {number} Unknown_FieldType=0 Unknown_FieldType value
         * @property {number} F_NullData=1 F_NullData value
         * @property {number} F_Char=2 F_Char value
         * @property {number} F_String=3 F_String value
         * @property {number} F_UTF8Char=4 F_UTF8Char value
         * @property {number} F_UTF8String=5 F_UTF8String value
         * @property {number} F_Binary=6 F_Binary value
         * @property {number} F_UInt8=7 F_UInt8 value
         * @property {number} F_SInt8=8 F_SInt8 value
         * @property {number} F_UInt16=9 F_UInt16 value
         * @property {number} F_SInt16=10 F_SInt16 value
         * @property {number} F_UInt32=11 F_UInt32 value
         * @property {number} F_SInt32=12 F_SInt32 value
         * @property {number} F_UInt64=13 F_UInt64 value
         * @property {number} F_SInt64=14 F_SInt64 value
         * @property {number} F_Float32=15 F_Float32 value
         * @property {number} F_Float64=16 F_Float64 value
         * @property {number} F_Time=17 F_Time value
         * @property {number} F_Date=18 F_Date value
         * @property {number} F_TimeStamp=19 F_TimeStamp value
         * @property {number} F_Lob=20 F_Lob value
         * @property {number} F_Decimal=21 F_Decimal value
         */
        CS.FieldType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_FieldType"] = 0;
            values[valuesById[1] = "F_NullData"] = 1;
            values[valuesById[2] = "F_Char"] = 2;
            values[valuesById[3] = "F_String"] = 3;
            values[valuesById[4] = "F_UTF8Char"] = 4;
            values[valuesById[5] = "F_UTF8String"] = 5;
            values[valuesById[6] = "F_Binary"] = 6;
            values[valuesById[7] = "F_UInt8"] = 7;
            values[valuesById[8] = "F_SInt8"] = 8;
            values[valuesById[9] = "F_UInt16"] = 9;
            values[valuesById[10] = "F_SInt16"] = 10;
            values[valuesById[11] = "F_UInt32"] = 11;
            values[valuesById[12] = "F_SInt32"] = 12;
            values[valuesById[13] = "F_UInt64"] = 13;
            values[valuesById[14] = "F_SInt64"] = 14;
            values[valuesById[15] = "F_Float32"] = 15;
            values[valuesById[16] = "F_Float64"] = 16;
            values[valuesById[17] = "F_Time"] = 17;
            values[valuesById[18] = "F_Date"] = 18;
            values[valuesById[19] = "F_TimeStamp"] = 19;
            values[valuesById[20] = "F_Lob"] = 20;
            values[valuesById[21] = "F_Decimal"] = 21;
            return values;
        })();
    
        CS.LobIdentifier = (function() {
    
            /**
             * Properties of a LobIdentifier.
             * @memberof CS
             * @interface ILobIdentifier
             * @property {number|null} [m_ColumnIndex] LobIdentifier m_ColumnIndex
             * @property {number|null} [m_RowIndex] LobIdentifier m_RowIndex
             */
    
            /**
             * Constructs a new LobIdentifier.
             * @memberof CS
             * @classdesc Represents a LobIdentifier.
             * @implements ILobIdentifier
             * @constructor
             * @param {CS.ILobIdentifier=} [properties] Properties to set
             */
            function LobIdentifier(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LobIdentifier m_ColumnIndex.
             * @member {number} m_ColumnIndex
             * @memberof CS.LobIdentifier
             * @instance
             */
            LobIdentifier.prototype.m_ColumnIndex = 0;
    
            /**
             * LobIdentifier m_RowIndex.
             * @member {number} m_RowIndex
             * @memberof CS.LobIdentifier
             * @instance
             */
            LobIdentifier.prototype.m_RowIndex = 0;
    
            /**
             * Creates a new LobIdentifier instance using the specified properties.
             * @function create
             * @memberof CS.LobIdentifier
             * @static
             * @param {CS.ILobIdentifier=} [properties] Properties to set
             * @returns {CS.LobIdentifier} LobIdentifier instance
             */
            LobIdentifier.create = function create(properties) {
                return new LobIdentifier(properties);
            };
    
            /**
             * Encodes the specified LobIdentifier message. Does not implicitly {@link CS.LobIdentifier.verify|verify} messages.
             * @function encode
             * @memberof CS.LobIdentifier
             * @static
             * @param {CS.ILobIdentifier} message LobIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LobIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_ColumnIndex != null && Object.hasOwnProperty.call(message, "m_ColumnIndex"))
                    writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.m_ColumnIndex);
                if (message.m_RowIndex != null && Object.hasOwnProperty.call(message, "m_RowIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.m_RowIndex);
                return writer;
            };
    
            /**
             * Encodes the specified LobIdentifier message, length delimited. Does not implicitly {@link CS.LobIdentifier.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.LobIdentifier
             * @static
             * @param {CS.ILobIdentifier} message LobIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LobIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LobIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof CS.LobIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.LobIdentifier} LobIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LobIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.LobIdentifier();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_ColumnIndex = reader.sint32();
                        break;
                    case 2:
                        message.m_RowIndex = reader.sint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LobIdentifier message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.LobIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.LobIdentifier} LobIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LobIdentifier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LobIdentifier message.
             * @function verify
             * @memberof CS.LobIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LobIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_ColumnIndex != null && message.hasOwnProperty("m_ColumnIndex"))
                    if (!$util.isInteger(message.m_ColumnIndex))
                        return "m_ColumnIndex: integer expected";
                if (message.m_RowIndex != null && message.hasOwnProperty("m_RowIndex"))
                    if (!$util.isInteger(message.m_RowIndex))
                        return "m_RowIndex: integer expected";
                return null;
            };
    
            /**
             * Creates a LobIdentifier message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.LobIdentifier
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.LobIdentifier} LobIdentifier
             */
            LobIdentifier.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.LobIdentifier)
                    return object;
                var message = new $root.CS.LobIdentifier();
                if (object.m_ColumnIndex != null)
                    message.m_ColumnIndex = object.m_ColumnIndex | 0;
                if (object.m_RowIndex != null)
                    message.m_RowIndex = object.m_RowIndex | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a LobIdentifier message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.LobIdentifier
             * @static
             * @param {CS.LobIdentifier} message LobIdentifier
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LobIdentifier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_ColumnIndex = 0;
                    object.m_RowIndex = 0;
                }
                if (message.m_ColumnIndex != null && message.hasOwnProperty("m_ColumnIndex"))
                    object.m_ColumnIndex = message.m_ColumnIndex;
                if (message.m_RowIndex != null && message.hasOwnProperty("m_RowIndex"))
                    object.m_RowIndex = message.m_RowIndex;
                return object;
            };
    
            /**
             * Converts this LobIdentifier to JSON.
             * @function toJSON
             * @memberof CS.LobIdentifier
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LobIdentifier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LobIdentifier;
        })();
    
        CS.Field = (function() {
    
            /**
             * Properties of a Field.
             * @memberof CS
             * @interface IField
             * @property {boolean|null} [m_NullData] Field m_NullData
             * @property {string|null} [m_Char] Field m_Char
             * @property {string|null} [m_String] Field m_String
             * @property {string|null} [m_UTF8Char] Field m_UTF8Char
             * @property {string|null} [m_UTF8String] Field m_UTF8String
             * @property {Uint8Array|null} [m_Binary] Field m_Binary
             * @property {number|null} [m_UInt8] Field m_UInt8
             * @property {number|null} [m_SInt8] Field m_SInt8
             * @property {number|null} [m_UInt16] Field m_UInt16
             * @property {number|null} [m_SInt16] Field m_SInt16
             * @property {number|null} [m_UInt32] Field m_UInt32
             * @property {number|null} [m_SInt32] Field m_SInt32
             * @property {number|Long|null} [m_UInt64] Field m_UInt64
             * @property {number|Long|null} [m_SInt64] Field m_SInt64
             * @property {number|null} [m_Float32] Field m_Float32
             * @property {number|null} [m_Float64] Field m_Float64
             * @property {CS.ITime|null} [m_Time] Field m_Time
             * @property {CS.IDate|null} [m_Date] Field m_Date
             * @property {CS.ITimeStamp|null} [m_TimeStamp] Field m_TimeStamp
             * @property {CS.ILobIdentifier|null} [m_Lob] Field m_Lob
             * @property {Uint8Array|null} [m_Decimal] Field m_Decimal
             */
    
            /**
             * Constructs a new Field.
             * @memberof CS
             * @classdesc Represents a Field.
             * @implements IField
             * @constructor
             * @param {CS.IField=} [properties] Properties to set
             */
            function Field(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Field m_NullData.
             * @member {boolean} m_NullData
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_NullData = false;
    
            /**
             * Field m_Char.
             * @member {string} m_Char
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Char = "";
    
            /**
             * Field m_String.
             * @member {string} m_String
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_String = "";
    
            /**
             * Field m_UTF8Char.
             * @member {string} m_UTF8Char
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_UTF8Char = "";
    
            /**
             * Field m_UTF8String.
             * @member {string} m_UTF8String
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_UTF8String = "";
    
            /**
             * Field m_Binary.
             * @member {Uint8Array} m_Binary
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Binary = $util.newBuffer([]);
    
            /**
             * Field m_UInt8.
             * @member {number} m_UInt8
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_UInt8 = 0;
    
            /**
             * Field m_SInt8.
             * @member {number} m_SInt8
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_SInt8 = 0;
    
            /**
             * Field m_UInt16.
             * @member {number} m_UInt16
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_UInt16 = 0;
    
            /**
             * Field m_SInt16.
             * @member {number} m_SInt16
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_SInt16 = 0;
    
            /**
             * Field m_UInt32.
             * @member {number} m_UInt32
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_UInt32 = 0;
    
            /**
             * Field m_SInt32.
             * @member {number} m_SInt32
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_SInt32 = 0;
    
            /**
             * Field m_UInt64.
             * @member {number|Long} m_UInt64
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_UInt64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Field m_SInt64.
             * @member {number|Long} m_SInt64
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_SInt64 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Field m_Float32.
             * @member {number} m_Float32
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Float32 = 0;
    
            /**
             * Field m_Float64.
             * @member {number} m_Float64
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Float64 = 0;
    
            /**
             * Field m_Time.
             * @member {CS.ITime|null|undefined} m_Time
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Time = null;
    
            /**
             * Field m_Date.
             * @member {CS.IDate|null|undefined} m_Date
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Date = null;
    
            /**
             * Field m_TimeStamp.
             * @member {CS.ITimeStamp|null|undefined} m_TimeStamp
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_TimeStamp = null;
    
            /**
             * Field m_Lob.
             * @member {CS.ILobIdentifier|null|undefined} m_Lob
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Lob = null;
    
            /**
             * Field m_Decimal.
             * @member {Uint8Array} m_Decimal
             * @memberof CS.Field
             * @instance
             */
            Field.prototype.m_Decimal = $util.newBuffer([]);
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Field FieldUnion.
             * @member {"m_NullData"|"m_Char"|"m_String"|"m_UTF8Char"|"m_UTF8String"|"m_Binary"|"m_UInt8"|"m_SInt8"|"m_UInt16"|"m_SInt16"|"m_UInt32"|"m_SInt32"|"m_UInt64"|"m_SInt64"|"m_Float32"|"m_Float64"|"m_Time"|"m_Date"|"m_TimeStamp"|"m_Lob"|"m_Decimal"|undefined} FieldUnion
             * @memberof CS.Field
             * @instance
             */
            Object.defineProperty(Field.prototype, "FieldUnion", {
                get: $util.oneOfGetter($oneOfFields = ["m_NullData", "m_Char", "m_String", "m_UTF8Char", "m_UTF8String", "m_Binary", "m_UInt8", "m_SInt8", "m_UInt16", "m_SInt16", "m_UInt32", "m_SInt32", "m_UInt64", "m_SInt64", "m_Float32", "m_Float64", "m_Time", "m_Date", "m_TimeStamp", "m_Lob", "m_Decimal"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Field instance using the specified properties.
             * @function create
             * @memberof CS.Field
             * @static
             * @param {CS.IField=} [properties] Properties to set
             * @returns {CS.Field} Field instance
             */
            Field.create = function create(properties) {
                return new Field(properties);
            };
    
            /**
             * Encodes the specified Field message. Does not implicitly {@link CS.Field.verify|verify} messages.
             * @function encode
             * @memberof CS.Field
             * @static
             * @param {CS.IField} message Field message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Field.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_NullData != null && Object.hasOwnProperty.call(message, "m_NullData"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.m_NullData);
                if (message.m_Char != null && Object.hasOwnProperty.call(message, "m_Char"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Char);
                if (message.m_String != null && Object.hasOwnProperty.call(message, "m_String"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_String);
                if (message.m_UTF8Char != null && Object.hasOwnProperty.call(message, "m_UTF8Char"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_UTF8Char);
                if (message.m_UTF8String != null && Object.hasOwnProperty.call(message, "m_UTF8String"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.m_UTF8String);
                if (message.m_Binary != null && Object.hasOwnProperty.call(message, "m_Binary"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.m_Binary);
                if (message.m_UInt8 != null && Object.hasOwnProperty.call(message, "m_UInt8"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.m_UInt8);
                if (message.m_SInt8 != null && Object.hasOwnProperty.call(message, "m_SInt8"))
                    writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.m_SInt8);
                if (message.m_UInt16 != null && Object.hasOwnProperty.call(message, "m_UInt16"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.m_UInt16);
                if (message.m_SInt16 != null && Object.hasOwnProperty.call(message, "m_SInt16"))
                    writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.m_SInt16);
                if (message.m_UInt32 != null && Object.hasOwnProperty.call(message, "m_UInt32"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.m_UInt32);
                if (message.m_SInt32 != null && Object.hasOwnProperty.call(message, "m_SInt32"))
                    writer.uint32(/* id 12, wireType 0 =*/96).sint32(message.m_SInt32);
                if (message.m_UInt64 != null && Object.hasOwnProperty.call(message, "m_UInt64"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.m_UInt64);
                if (message.m_SInt64 != null && Object.hasOwnProperty.call(message, "m_SInt64"))
                    writer.uint32(/* id 14, wireType 0 =*/112).sint64(message.m_SInt64);
                if (message.m_Float32 != null && Object.hasOwnProperty.call(message, "m_Float32"))
                    writer.uint32(/* id 15, wireType 5 =*/125).float(message.m_Float32);
                if (message.m_Float64 != null && Object.hasOwnProperty.call(message, "m_Float64"))
                    writer.uint32(/* id 16, wireType 1 =*/129).double(message.m_Float64);
                if (message.m_Time != null && Object.hasOwnProperty.call(message, "m_Time"))
                    $root.CS.Time.encode(message.m_Time, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.m_Date != null && Object.hasOwnProperty.call(message, "m_Date"))
                    $root.CS.Date.encode(message.m_Date, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.m_TimeStamp != null && Object.hasOwnProperty.call(message, "m_TimeStamp"))
                    $root.CS.TimeStamp.encode(message.m_TimeStamp, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.m_Lob != null && Object.hasOwnProperty.call(message, "m_Lob"))
                    $root.CS.LobIdentifier.encode(message.m_Lob, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.m_Decimal != null && Object.hasOwnProperty.call(message, "m_Decimal"))
                    writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.m_Decimal);
                return writer;
            };
    
            /**
             * Encodes the specified Field message, length delimited. Does not implicitly {@link CS.Field.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Field
             * @static
             * @param {CS.IField} message Field message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Field.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Field message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Field
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Field} Field
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Field.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Field();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_NullData = reader.bool();
                        break;
                    case 2:
                        message.m_Char = reader.string();
                        break;
                    case 3:
                        message.m_String = reader.string();
                        break;
                    case 4:
                        message.m_UTF8Char = reader.string();
                        break;
                    case 5:
                        message.m_UTF8String = reader.string();
                        break;
                    case 6:
                        message.m_Binary = reader.bytes();
                        break;
                    case 7:
                        message.m_UInt8 = reader.uint32();
                        break;
                    case 8:
                        message.m_SInt8 = reader.sint32();
                        break;
                    case 9:
                        message.m_UInt16 = reader.uint32();
                        break;
                    case 10:
                        message.m_SInt16 = reader.sint32();
                        break;
                    case 11:
                        message.m_UInt32 = reader.uint32();
                        break;
                    case 12:
                        message.m_SInt32 = reader.sint32();
                        break;
                    case 13:
                        message.m_UInt64 = reader.uint64();
                        break;
                    case 14:
                        message.m_SInt64 = reader.sint64();
                        break;
                    case 15:
                        message.m_Float32 = reader.float();
                        break;
                    case 16:
                        message.m_Float64 = reader.double();
                        break;
                    case 17:
                        message.m_Time = $root.CS.Time.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.m_Date = $root.CS.Date.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.m_TimeStamp = $root.CS.TimeStamp.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.m_Lob = $root.CS.LobIdentifier.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.m_Decimal = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Field message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Field
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Field} Field
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Field.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Field message.
             * @function verify
             * @memberof CS.Field
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Field.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.m_NullData != null && message.hasOwnProperty("m_NullData")) {
                    properties.FieldUnion = 1;
                    if (typeof message.m_NullData !== "boolean")
                        return "m_NullData: boolean expected";
                }
                if (message.m_Char != null && message.hasOwnProperty("m_Char")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isString(message.m_Char))
                        return "m_Char: string expected";
                }
                if (message.m_String != null && message.hasOwnProperty("m_String")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isString(message.m_String))
                        return "m_String: string expected";
                }
                if (message.m_UTF8Char != null && message.hasOwnProperty("m_UTF8Char")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isString(message.m_UTF8Char))
                        return "m_UTF8Char: string expected";
                }
                if (message.m_UTF8String != null && message.hasOwnProperty("m_UTF8String")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isString(message.m_UTF8String))
                        return "m_UTF8String: string expected";
                }
                if (message.m_Binary != null && message.hasOwnProperty("m_Binary")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!(message.m_Binary && typeof message.m_Binary.length === "number" || $util.isString(message.m_Binary)))
                        return "m_Binary: buffer expected";
                }
                if (message.m_UInt8 != null && message.hasOwnProperty("m_UInt8")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_UInt8))
                        return "m_UInt8: integer expected";
                }
                if (message.m_SInt8 != null && message.hasOwnProperty("m_SInt8")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_SInt8))
                        return "m_SInt8: integer expected";
                }
                if (message.m_UInt16 != null && message.hasOwnProperty("m_UInt16")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_UInt16))
                        return "m_UInt16: integer expected";
                }
                if (message.m_SInt16 != null && message.hasOwnProperty("m_SInt16")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_SInt16))
                        return "m_SInt16: integer expected";
                }
                if (message.m_UInt32 != null && message.hasOwnProperty("m_UInt32")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_UInt32))
                        return "m_UInt32: integer expected";
                }
                if (message.m_SInt32 != null && message.hasOwnProperty("m_SInt32")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_SInt32))
                        return "m_SInt32: integer expected";
                }
                if (message.m_UInt64 != null && message.hasOwnProperty("m_UInt64")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_UInt64) && !(message.m_UInt64 && $util.isInteger(message.m_UInt64.low) && $util.isInteger(message.m_UInt64.high)))
                        return "m_UInt64: integer|Long expected";
                }
                if (message.m_SInt64 != null && message.hasOwnProperty("m_SInt64")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!$util.isInteger(message.m_SInt64) && !(message.m_SInt64 && $util.isInteger(message.m_SInt64.low) && $util.isInteger(message.m_SInt64.high)))
                        return "m_SInt64: integer|Long expected";
                }
                if (message.m_Float32 != null && message.hasOwnProperty("m_Float32")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (typeof message.m_Float32 !== "number")
                        return "m_Float32: number expected";
                }
                if (message.m_Float64 != null && message.hasOwnProperty("m_Float64")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (typeof message.m_Float64 !== "number")
                        return "m_Float64: number expected";
                }
                if (message.m_Time != null && message.hasOwnProperty("m_Time")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    {
                        var error = $root.CS.Time.verify(message.m_Time);
                        if (error)
                            return "m_Time." + error;
                    }
                }
                if (message.m_Date != null && message.hasOwnProperty("m_Date")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    {
                        var error = $root.CS.Date.verify(message.m_Date);
                        if (error)
                            return "m_Date." + error;
                    }
                }
                if (message.m_TimeStamp != null && message.hasOwnProperty("m_TimeStamp")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    {
                        var error = $root.CS.TimeStamp.verify(message.m_TimeStamp);
                        if (error)
                            return "m_TimeStamp." + error;
                    }
                }
                if (message.m_Lob != null && message.hasOwnProperty("m_Lob")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    {
                        var error = $root.CS.LobIdentifier.verify(message.m_Lob);
                        if (error)
                            return "m_Lob." + error;
                    }
                }
                if (message.m_Decimal != null && message.hasOwnProperty("m_Decimal")) {
                    if (properties.FieldUnion === 1)
                        return "FieldUnion: multiple values";
                    properties.FieldUnion = 1;
                    if (!(message.m_Decimal && typeof message.m_Decimal.length === "number" || $util.isString(message.m_Decimal)))
                        return "m_Decimal: buffer expected";
                }
                return null;
            };
    
            /**
             * Creates a Field message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Field
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Field} Field
             */
            Field.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Field)
                    return object;
                var message = new $root.CS.Field();
                if (object.m_NullData != null)
                    message.m_NullData = Boolean(object.m_NullData);
                if (object.m_Char != null)
                    message.m_Char = String(object.m_Char);
                if (object.m_String != null)
                    message.m_String = String(object.m_String);
                if (object.m_UTF8Char != null)
                    message.m_UTF8Char = String(object.m_UTF8Char);
                if (object.m_UTF8String != null)
                    message.m_UTF8String = String(object.m_UTF8String);
                if (object.m_Binary != null)
                    if (typeof object.m_Binary === "string")
                        $util.base64.decode(object.m_Binary, message.m_Binary = $util.newBuffer($util.base64.length(object.m_Binary)), 0);
                    else if (object.m_Binary.length)
                        message.m_Binary = object.m_Binary;
                if (object.m_UInt8 != null)
                    message.m_UInt8 = object.m_UInt8 >>> 0;
                if (object.m_SInt8 != null)
                    message.m_SInt8 = object.m_SInt8 | 0;
                if (object.m_UInt16 != null)
                    message.m_UInt16 = object.m_UInt16 >>> 0;
                if (object.m_SInt16 != null)
                    message.m_SInt16 = object.m_SInt16 | 0;
                if (object.m_UInt32 != null)
                    message.m_UInt32 = object.m_UInt32 >>> 0;
                if (object.m_SInt32 != null)
                    message.m_SInt32 = object.m_SInt32 | 0;
                if (object.m_UInt64 != null)
                    if ($util.Long)
                        (message.m_UInt64 = $util.Long.fromValue(object.m_UInt64)).unsigned = true;
                    else if (typeof object.m_UInt64 === "string")
                        message.m_UInt64 = parseInt(object.m_UInt64, 10);
                    else if (typeof object.m_UInt64 === "number")
                        message.m_UInt64 = object.m_UInt64;
                    else if (typeof object.m_UInt64 === "object")
                        message.m_UInt64 = new $util.LongBits(object.m_UInt64.low >>> 0, object.m_UInt64.high >>> 0).toNumber(true);
                if (object.m_SInt64 != null)
                    if ($util.Long)
                        (message.m_SInt64 = $util.Long.fromValue(object.m_SInt64)).unsigned = false;
                    else if (typeof object.m_SInt64 === "string")
                        message.m_SInt64 = parseInt(object.m_SInt64, 10);
                    else if (typeof object.m_SInt64 === "number")
                        message.m_SInt64 = object.m_SInt64;
                    else if (typeof object.m_SInt64 === "object")
                        message.m_SInt64 = new $util.LongBits(object.m_SInt64.low >>> 0, object.m_SInt64.high >>> 0).toNumber();
                if (object.m_Float32 != null)
                    message.m_Float32 = Number(object.m_Float32);
                if (object.m_Float64 != null)
                    message.m_Float64 = Number(object.m_Float64);
                if (object.m_Time != null) {
                    if (typeof object.m_Time !== "object")
                        throw TypeError(".CS.Field.m_Time: object expected");
                    message.m_Time = $root.CS.Time.fromObject(object.m_Time);
                }
                if (object.m_Date != null) {
                    if (typeof object.m_Date !== "object")
                        throw TypeError(".CS.Field.m_Date: object expected");
                    message.m_Date = $root.CS.Date.fromObject(object.m_Date);
                }
                if (object.m_TimeStamp != null) {
                    if (typeof object.m_TimeStamp !== "object")
                        throw TypeError(".CS.Field.m_TimeStamp: object expected");
                    message.m_TimeStamp = $root.CS.TimeStamp.fromObject(object.m_TimeStamp);
                }
                if (object.m_Lob != null) {
                    if (typeof object.m_Lob !== "object")
                        throw TypeError(".CS.Field.m_Lob: object expected");
                    message.m_Lob = $root.CS.LobIdentifier.fromObject(object.m_Lob);
                }
                if (object.m_Decimal != null)
                    if (typeof object.m_Decimal === "string")
                        $util.base64.decode(object.m_Decimal, message.m_Decimal = $util.newBuffer($util.base64.length(object.m_Decimal)), 0);
                    else if (object.m_Decimal.length)
                        message.m_Decimal = object.m_Decimal;
                return message;
            };
    
            /**
             * Creates a plain object from a Field message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Field
             * @static
             * @param {CS.Field} message Field
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Field.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.m_NullData != null && message.hasOwnProperty("m_NullData")) {
                    object.m_NullData = message.m_NullData;
                    if (options.oneofs)
                        object.FieldUnion = "m_NullData";
                }
                if (message.m_Char != null && message.hasOwnProperty("m_Char")) {
                    object.m_Char = message.m_Char;
                    if (options.oneofs)
                        object.FieldUnion = "m_Char";
                }
                if (message.m_String != null && message.hasOwnProperty("m_String")) {
                    object.m_String = message.m_String;
                    if (options.oneofs)
                        object.FieldUnion = "m_String";
                }
                if (message.m_UTF8Char != null && message.hasOwnProperty("m_UTF8Char")) {
                    object.m_UTF8Char = message.m_UTF8Char;
                    if (options.oneofs)
                        object.FieldUnion = "m_UTF8Char";
                }
                if (message.m_UTF8String != null && message.hasOwnProperty("m_UTF8String")) {
                    object.m_UTF8String = message.m_UTF8String;
                    if (options.oneofs)
                        object.FieldUnion = "m_UTF8String";
                }
                if (message.m_Binary != null && message.hasOwnProperty("m_Binary")) {
                    object.m_Binary = options.bytes === String ? $util.base64.encode(message.m_Binary, 0, message.m_Binary.length) : options.bytes === Array ? Array.prototype.slice.call(message.m_Binary) : message.m_Binary;
                    if (options.oneofs)
                        object.FieldUnion = "m_Binary";
                }
                if (message.m_UInt8 != null && message.hasOwnProperty("m_UInt8")) {
                    object.m_UInt8 = message.m_UInt8;
                    if (options.oneofs)
                        object.FieldUnion = "m_UInt8";
                }
                if (message.m_SInt8 != null && message.hasOwnProperty("m_SInt8")) {
                    object.m_SInt8 = message.m_SInt8;
                    if (options.oneofs)
                        object.FieldUnion = "m_SInt8";
                }
                if (message.m_UInt16 != null && message.hasOwnProperty("m_UInt16")) {
                    object.m_UInt16 = message.m_UInt16;
                    if (options.oneofs)
                        object.FieldUnion = "m_UInt16";
                }
                if (message.m_SInt16 != null && message.hasOwnProperty("m_SInt16")) {
                    object.m_SInt16 = message.m_SInt16;
                    if (options.oneofs)
                        object.FieldUnion = "m_SInt16";
                }
                if (message.m_UInt32 != null && message.hasOwnProperty("m_UInt32")) {
                    object.m_UInt32 = message.m_UInt32;
                    if (options.oneofs)
                        object.FieldUnion = "m_UInt32";
                }
                if (message.m_SInt32 != null && message.hasOwnProperty("m_SInt32")) {
                    object.m_SInt32 = message.m_SInt32;
                    if (options.oneofs)
                        object.FieldUnion = "m_SInt32";
                }
                if (message.m_UInt64 != null && message.hasOwnProperty("m_UInt64")) {
                    if (typeof message.m_UInt64 === "number")
                        object.m_UInt64 = options.longs === String ? String(message.m_UInt64) : message.m_UInt64;
                    else
                        object.m_UInt64 = options.longs === String ? $util.Long.prototype.toString.call(message.m_UInt64) : options.longs === Number ? new $util.LongBits(message.m_UInt64.low >>> 0, message.m_UInt64.high >>> 0).toNumber(true) : message.m_UInt64;
                    if (options.oneofs)
                        object.FieldUnion = "m_UInt64";
                }
                if (message.m_SInt64 != null && message.hasOwnProperty("m_SInt64")) {
                    if (typeof message.m_SInt64 === "number")
                        object.m_SInt64 = options.longs === String ? String(message.m_SInt64) : message.m_SInt64;
                    else
                        object.m_SInt64 = options.longs === String ? $util.Long.prototype.toString.call(message.m_SInt64) : options.longs === Number ? new $util.LongBits(message.m_SInt64.low >>> 0, message.m_SInt64.high >>> 0).toNumber() : message.m_SInt64;
                    if (options.oneofs)
                        object.FieldUnion = "m_SInt64";
                }
                if (message.m_Float32 != null && message.hasOwnProperty("m_Float32")) {
                    object.m_Float32 = options.json && !isFinite(message.m_Float32) ? String(message.m_Float32) : message.m_Float32;
                    if (options.oneofs)
                        object.FieldUnion = "m_Float32";
                }
                if (message.m_Float64 != null && message.hasOwnProperty("m_Float64")) {
                    object.m_Float64 = options.json && !isFinite(message.m_Float64) ? String(message.m_Float64) : message.m_Float64;
                    if (options.oneofs)
                        object.FieldUnion = "m_Float64";
                }
                if (message.m_Time != null && message.hasOwnProperty("m_Time")) {
                    object.m_Time = $root.CS.Time.toObject(message.m_Time, options);
                    if (options.oneofs)
                        object.FieldUnion = "m_Time";
                }
                if (message.m_Date != null && message.hasOwnProperty("m_Date")) {
                    object.m_Date = $root.CS.Date.toObject(message.m_Date, options);
                    if (options.oneofs)
                        object.FieldUnion = "m_Date";
                }
                if (message.m_TimeStamp != null && message.hasOwnProperty("m_TimeStamp")) {
                    object.m_TimeStamp = $root.CS.TimeStamp.toObject(message.m_TimeStamp, options);
                    if (options.oneofs)
                        object.FieldUnion = "m_TimeStamp";
                }
                if (message.m_Lob != null && message.hasOwnProperty("m_Lob")) {
                    object.m_Lob = $root.CS.LobIdentifier.toObject(message.m_Lob, options);
                    if (options.oneofs)
                        object.FieldUnion = "m_Lob";
                }
                if (message.m_Decimal != null && message.hasOwnProperty("m_Decimal")) {
                    object.m_Decimal = options.bytes === String ? $util.base64.encode(message.m_Decimal, 0, message.m_Decimal.length) : options.bytes === Array ? Array.prototype.slice.call(message.m_Decimal) : message.m_Decimal;
                    if (options.oneofs)
                        object.FieldUnion = "m_Decimal";
                }
                return object;
            };
    
            /**
             * Converts this Field to JSON.
             * @function toJSON
             * @memberof CS.Field
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Field.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Field;
        })();
    
        CS.Record = (function() {
    
            /**
             * Properties of a Record.
             * @memberof CS
             * @interface IRecord
             * @property {Array.<CS.IField>|null} [m_Fields] Record m_Fields
             */
    
            /**
             * Constructs a new Record.
             * @memberof CS
             * @classdesc Represents a Record.
             * @implements IRecord
             * @constructor
             * @param {CS.IRecord=} [properties] Properties to set
             */
            function Record(properties) {
                this.m_Fields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Record m_Fields.
             * @member {Array.<CS.IField>} m_Fields
             * @memberof CS.Record
             * @instance
             */
            Record.prototype.m_Fields = $util.emptyArray;
    
            /**
             * Creates a new Record instance using the specified properties.
             * @function create
             * @memberof CS.Record
             * @static
             * @param {CS.IRecord=} [properties] Properties to set
             * @returns {CS.Record} Record instance
             */
            Record.create = function create(properties) {
                return new Record(properties);
            };
    
            /**
             * Encodes the specified Record message. Does not implicitly {@link CS.Record.verify|verify} messages.
             * @function encode
             * @memberof CS.Record
             * @static
             * @param {CS.IRecord} message Record message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Record.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Fields != null && message.m_Fields.length)
                    for (var i = 0; i < message.m_Fields.length; ++i)
                        $root.CS.Field.encode(message.m_Fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Record message, length delimited. Does not implicitly {@link CS.Record.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Record
             * @static
             * @param {CS.IRecord} message Record message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Record.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Record message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Record
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Record} Record
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Record.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Record();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.m_Fields && message.m_Fields.length))
                            message.m_Fields = [];
                        message.m_Fields.push($root.CS.Field.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Record message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Record
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Record} Record
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Record.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Record message.
             * @function verify
             * @memberof CS.Record
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Record.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Fields != null && message.hasOwnProperty("m_Fields")) {
                    if (!Array.isArray(message.m_Fields))
                        return "m_Fields: array expected";
                    for (var i = 0; i < message.m_Fields.length; ++i) {
                        var error = $root.CS.Field.verify(message.m_Fields[i]);
                        if (error)
                            return "m_Fields." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Record message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Record
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Record} Record
             */
            Record.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Record)
                    return object;
                var message = new $root.CS.Record();
                if (object.m_Fields) {
                    if (!Array.isArray(object.m_Fields))
                        throw TypeError(".CS.Record.m_Fields: array expected");
                    message.m_Fields = [];
                    for (var i = 0; i < object.m_Fields.length; ++i) {
                        if (typeof object.m_Fields[i] !== "object")
                            throw TypeError(".CS.Record.m_Fields: object expected");
                        message.m_Fields[i] = $root.CS.Field.fromObject(object.m_Fields[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Record message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Record
             * @static
             * @param {CS.Record} message Record
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Record.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.m_Fields = [];
                if (message.m_Fields && message.m_Fields.length) {
                    object.m_Fields = [];
                    for (var j = 0; j < message.m_Fields.length; ++j)
                        object.m_Fields[j] = $root.CS.Field.toObject(message.m_Fields[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Record to JSON.
             * @function toJSON
             * @memberof CS.Record
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Record.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Record;
        })();
    
        CS.ColumnInfo = (function() {
    
            /**
             * Properties of a ColumnInfo.
             * @memberof CS
             * @interface IColumnInfo
             * @property {CS.IFieldInfo|null} [m_Info] ColumnInfo m_Info
             * @property {string|null} [m_Description] ColumnInfo m_Description
             * @property {string|null} [m_TableQualifier] ColumnInfo m_TableQualifier
             * @property {string|null} [m_TableOwner] ColumnInfo m_TableOwner
             * @property {string|null} [m_TableName] ColumnInfo m_TableName
             */
    
            /**
             * Constructs a new ColumnInfo.
             * @memberof CS
             * @classdesc Represents a ColumnInfo.
             * @implements IColumnInfo
             * @constructor
             * @param {CS.IColumnInfo=} [properties] Properties to set
             */
            function ColumnInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ColumnInfo m_Info.
             * @member {CS.IFieldInfo|null|undefined} m_Info
             * @memberof CS.ColumnInfo
             * @instance
             */
            ColumnInfo.prototype.m_Info = null;
    
            /**
             * ColumnInfo m_Description.
             * @member {string} m_Description
             * @memberof CS.ColumnInfo
             * @instance
             */
            ColumnInfo.prototype.m_Description = "";
    
            /**
             * ColumnInfo m_TableQualifier.
             * @member {string} m_TableQualifier
             * @memberof CS.ColumnInfo
             * @instance
             */
            ColumnInfo.prototype.m_TableQualifier = "";
    
            /**
             * ColumnInfo m_TableOwner.
             * @member {string} m_TableOwner
             * @memberof CS.ColumnInfo
             * @instance
             */
            ColumnInfo.prototype.m_TableOwner = "";
    
            /**
             * ColumnInfo m_TableName.
             * @member {string} m_TableName
             * @memberof CS.ColumnInfo
             * @instance
             */
            ColumnInfo.prototype.m_TableName = "";
    
            /**
             * Creates a new ColumnInfo instance using the specified properties.
             * @function create
             * @memberof CS.ColumnInfo
             * @static
             * @param {CS.IColumnInfo=} [properties] Properties to set
             * @returns {CS.ColumnInfo} ColumnInfo instance
             */
            ColumnInfo.create = function create(properties) {
                return new ColumnInfo(properties);
            };
    
            /**
             * Encodes the specified ColumnInfo message. Does not implicitly {@link CS.ColumnInfo.verify|verify} messages.
             * @function encode
             * @memberof CS.ColumnInfo
             * @static
             * @param {CS.IColumnInfo} message ColumnInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Info != null && Object.hasOwnProperty.call(message, "m_Info"))
                    $root.CS.FieldInfo.encode(message.m_Info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_Description != null && Object.hasOwnProperty.call(message, "m_Description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Description);
                if (message.m_TableQualifier != null && Object.hasOwnProperty.call(message, "m_TableQualifier"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_TableQualifier);
                if (message.m_TableOwner != null && Object.hasOwnProperty.call(message, "m_TableOwner"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_TableOwner);
                if (message.m_TableName != null && Object.hasOwnProperty.call(message, "m_TableName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.m_TableName);
                return writer;
            };
    
            /**
             * Encodes the specified ColumnInfo message, length delimited. Does not implicitly {@link CS.ColumnInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.ColumnInfo
             * @static
             * @param {CS.IColumnInfo} message ColumnInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ColumnInfo message from the specified reader or buffer.
             * @function decode
             * @memberof CS.ColumnInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.ColumnInfo} ColumnInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.ColumnInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Info = $root.CS.FieldInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.m_Description = reader.string();
                        break;
                    case 3:
                        message.m_TableQualifier = reader.string();
                        break;
                    case 4:
                        message.m_TableOwner = reader.string();
                        break;
                    case 5:
                        message.m_TableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ColumnInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.ColumnInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.ColumnInfo} ColumnInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ColumnInfo message.
             * @function verify
             * @memberof CS.ColumnInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Info != null && message.hasOwnProperty("m_Info")) {
                    var error = $root.CS.FieldInfo.verify(message.m_Info);
                    if (error)
                        return "m_Info." + error;
                }
                if (message.m_Description != null && message.hasOwnProperty("m_Description"))
                    if (!$util.isString(message.m_Description))
                        return "m_Description: string expected";
                if (message.m_TableQualifier != null && message.hasOwnProperty("m_TableQualifier"))
                    if (!$util.isString(message.m_TableQualifier))
                        return "m_TableQualifier: string expected";
                if (message.m_TableOwner != null && message.hasOwnProperty("m_TableOwner"))
                    if (!$util.isString(message.m_TableOwner))
                        return "m_TableOwner: string expected";
                if (message.m_TableName != null && message.hasOwnProperty("m_TableName"))
                    if (!$util.isString(message.m_TableName))
                        return "m_TableName: string expected";
                return null;
            };
    
            /**
             * Creates a ColumnInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.ColumnInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.ColumnInfo} ColumnInfo
             */
            ColumnInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.ColumnInfo)
                    return object;
                var message = new $root.CS.ColumnInfo();
                if (object.m_Info != null) {
                    if (typeof object.m_Info !== "object")
                        throw TypeError(".CS.ColumnInfo.m_Info: object expected");
                    message.m_Info = $root.CS.FieldInfo.fromObject(object.m_Info);
                }
                if (object.m_Description != null)
                    message.m_Description = String(object.m_Description);
                if (object.m_TableQualifier != null)
                    message.m_TableQualifier = String(object.m_TableQualifier);
                if (object.m_TableOwner != null)
                    message.m_TableOwner = String(object.m_TableOwner);
                if (object.m_TableName != null)
                    message.m_TableName = String(object.m_TableName);
                return message;
            };
    
            /**
             * Creates a plain object from a ColumnInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.ColumnInfo
             * @static
             * @param {CS.ColumnInfo} message ColumnInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Info = null;
                    object.m_Description = "";
                    object.m_TableQualifier = "";
                    object.m_TableOwner = "";
                    object.m_TableName = "";
                }
                if (message.m_Info != null && message.hasOwnProperty("m_Info"))
                    object.m_Info = $root.CS.FieldInfo.toObject(message.m_Info, options);
                if (message.m_Description != null && message.hasOwnProperty("m_Description"))
                    object.m_Description = message.m_Description;
                if (message.m_TableQualifier != null && message.hasOwnProperty("m_TableQualifier"))
                    object.m_TableQualifier = message.m_TableQualifier;
                if (message.m_TableOwner != null && message.hasOwnProperty("m_TableOwner"))
                    object.m_TableOwner = message.m_TableOwner;
                if (message.m_TableName != null && message.hasOwnProperty("m_TableName"))
                    object.m_TableName = message.m_TableName;
                return object;
            };
    
            /**
             * Converts this ColumnInfo to JSON.
             * @function toJSON
             * @memberof CS.ColumnInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ColumnInfo;
        })();
    
        CS.ProcedureParamInfo = (function() {
    
            /**
             * Properties of a ProcedureParamInfo.
             * @memberof CS
             * @interface IProcedureParamInfo
             * @property {CS.IFieldInfo|null} [m_Info] ProcedureParamInfo m_Info
             * @property {CS.Mode|null} [m_Mode] ProcedureParamInfo m_Mode
             */
    
            /**
             * Constructs a new ProcedureParamInfo.
             * @memberof CS
             * @classdesc Represents a ProcedureParamInfo.
             * @implements IProcedureParamInfo
             * @constructor
             * @param {CS.IProcedureParamInfo=} [properties] Properties to set
             */
            function ProcedureParamInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ProcedureParamInfo m_Info.
             * @member {CS.IFieldInfo|null|undefined} m_Info
             * @memberof CS.ProcedureParamInfo
             * @instance
             */
            ProcedureParamInfo.prototype.m_Info = null;
    
            /**
             * ProcedureParamInfo m_Mode.
             * @member {CS.Mode} m_Mode
             * @memberof CS.ProcedureParamInfo
             * @instance
             */
            ProcedureParamInfo.prototype.m_Mode = 0;
    
            /**
             * Creates a new ProcedureParamInfo instance using the specified properties.
             * @function create
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {CS.IProcedureParamInfo=} [properties] Properties to set
             * @returns {CS.ProcedureParamInfo} ProcedureParamInfo instance
             */
            ProcedureParamInfo.create = function create(properties) {
                return new ProcedureParamInfo(properties);
            };
    
            /**
             * Encodes the specified ProcedureParamInfo message. Does not implicitly {@link CS.ProcedureParamInfo.verify|verify} messages.
             * @function encode
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {CS.IProcedureParamInfo} message ProcedureParamInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProcedureParamInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Info != null && Object.hasOwnProperty.call(message, "m_Info"))
                    $root.CS.FieldInfo.encode(message.m_Info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.m_Mode != null && Object.hasOwnProperty.call(message, "m_Mode"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.m_Mode);
                return writer;
            };
    
            /**
             * Encodes the specified ProcedureParamInfo message, length delimited. Does not implicitly {@link CS.ProcedureParamInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {CS.IProcedureParamInfo} message ProcedureParamInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProcedureParamInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ProcedureParamInfo message from the specified reader or buffer.
             * @function decode
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.ProcedureParamInfo} ProcedureParamInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProcedureParamInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.ProcedureParamInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Info = $root.CS.FieldInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.m_Mode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ProcedureParamInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.ProcedureParamInfo} ProcedureParamInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProcedureParamInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ProcedureParamInfo message.
             * @function verify
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProcedureParamInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Info != null && message.hasOwnProperty("m_Info")) {
                    var error = $root.CS.FieldInfo.verify(message.m_Info);
                    if (error)
                        return "m_Info." + error;
                }
                if (message.m_Mode != null && message.hasOwnProperty("m_Mode"))
                    switch (message.m_Mode) {
                    default:
                        return "m_Mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a ProcedureParamInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.ProcedureParamInfo} ProcedureParamInfo
             */
            ProcedureParamInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.ProcedureParamInfo)
                    return object;
                var message = new $root.CS.ProcedureParamInfo();
                if (object.m_Info != null) {
                    if (typeof object.m_Info !== "object")
                        throw TypeError(".CS.ProcedureParamInfo.m_Info: object expected");
                    message.m_Info = $root.CS.FieldInfo.fromObject(object.m_Info);
                }
                switch (object.m_Mode) {
                case "Unknown_Mode":
                case 0:
                    message.m_Mode = 0;
                    break;
                case "InMode":
                case 1:
                    message.m_Mode = 1;
                    break;
                case "OutMode":
                case 2:
                    message.m_Mode = 2;
                    break;
                case "InOutMode":
                case 3:
                    message.m_Mode = 3;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ProcedureParamInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.ProcedureParamInfo
             * @static
             * @param {CS.ProcedureParamInfo} message ProcedureParamInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProcedureParamInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Info = null;
                    object.m_Mode = options.enums === String ? "Unknown_Mode" : 0;
                }
                if (message.m_Info != null && message.hasOwnProperty("m_Info"))
                    object.m_Info = $root.CS.FieldInfo.toObject(message.m_Info, options);
                if (message.m_Mode != null && message.hasOwnProperty("m_Mode"))
                    object.m_Mode = options.enums === String ? $root.CS.Mode[message.m_Mode] : message.m_Mode;
                return object;
            };
    
            /**
             * Converts this ProcedureParamInfo to JSON.
             * @function toJSON
             * @memberof CS.ProcedureParamInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProcedureParamInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ProcedureParamInfo;
        })();
    
        CS.DBObject = (function() {
    
            /**
             * Properties of a DBObject.
             * @memberof CS
             * @interface IDBObject
             * @property {string|null} [m_Qualifier] DBObject m_Qualifier
             * @property {string|null} [m_Owner] DBObject m_Owner
             * @property {string|null} [m_Name] DBObject m_Name
             * @property {string|null} [m_Type] DBObject m_Type
             * @property {string|null} [m_Description] DBObject m_Description
             */
    
            /**
             * Constructs a new DBObject.
             * @memberof CS
             * @classdesc Represents a DBObject.
             * @implements IDBObject
             * @constructor
             * @param {CS.IDBObject=} [properties] Properties to set
             */
            function DBObject(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DBObject m_Qualifier.
             * @member {string} m_Qualifier
             * @memberof CS.DBObject
             * @instance
             */
            DBObject.prototype.m_Qualifier = "";
    
            /**
             * DBObject m_Owner.
             * @member {string} m_Owner
             * @memberof CS.DBObject
             * @instance
             */
            DBObject.prototype.m_Owner = "";
    
            /**
             * DBObject m_Name.
             * @member {string} m_Name
             * @memberof CS.DBObject
             * @instance
             */
            DBObject.prototype.m_Name = "";
    
            /**
             * DBObject m_Type.
             * @member {string} m_Type
             * @memberof CS.DBObject
             * @instance
             */
            DBObject.prototype.m_Type = "";
    
            /**
             * DBObject m_Description.
             * @member {string} m_Description
             * @memberof CS.DBObject
             * @instance
             */
            DBObject.prototype.m_Description = "";
    
            /**
             * Creates a new DBObject instance using the specified properties.
             * @function create
             * @memberof CS.DBObject
             * @static
             * @param {CS.IDBObject=} [properties] Properties to set
             * @returns {CS.DBObject} DBObject instance
             */
            DBObject.create = function create(properties) {
                return new DBObject(properties);
            };
    
            /**
             * Encodes the specified DBObject message. Does not implicitly {@link CS.DBObject.verify|verify} messages.
             * @function encode
             * @memberof CS.DBObject
             * @static
             * @param {CS.IDBObject} message DBObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DBObject.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Qualifier != null && Object.hasOwnProperty.call(message, "m_Qualifier"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Qualifier);
                if (message.m_Owner != null && Object.hasOwnProperty.call(message, "m_Owner"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Owner);
                if (message.m_Name != null && Object.hasOwnProperty.call(message, "m_Name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_Name);
                if (message.m_Type != null && Object.hasOwnProperty.call(message, "m_Type"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.m_Type);
                if (message.m_Description != null && Object.hasOwnProperty.call(message, "m_Description"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.m_Description);
                return writer;
            };
    
            /**
             * Encodes the specified DBObject message, length delimited. Does not implicitly {@link CS.DBObject.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.DBObject
             * @static
             * @param {CS.IDBObject} message DBObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DBObject.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DBObject message from the specified reader or buffer.
             * @function decode
             * @memberof CS.DBObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.DBObject} DBObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DBObject.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.DBObject();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Qualifier = reader.string();
                        break;
                    case 2:
                        message.m_Owner = reader.string();
                        break;
                    case 3:
                        message.m_Name = reader.string();
                        break;
                    case 4:
                        message.m_Type = reader.string();
                        break;
                    case 5:
                        message.m_Description = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DBObject message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.DBObject
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.DBObject} DBObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DBObject.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DBObject message.
             * @function verify
             * @memberof CS.DBObject
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DBObject.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Qualifier != null && message.hasOwnProperty("m_Qualifier"))
                    if (!$util.isString(message.m_Qualifier))
                        return "m_Qualifier: string expected";
                if (message.m_Owner != null && message.hasOwnProperty("m_Owner"))
                    if (!$util.isString(message.m_Owner))
                        return "m_Owner: string expected";
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    if (!$util.isString(message.m_Name))
                        return "m_Name: string expected";
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    if (!$util.isString(message.m_Type))
                        return "m_Type: string expected";
                if (message.m_Description != null && message.hasOwnProperty("m_Description"))
                    if (!$util.isString(message.m_Description))
                        return "m_Description: string expected";
                return null;
            };
    
            /**
             * Creates a DBObject message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.DBObject
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.DBObject} DBObject
             */
            DBObject.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.DBObject)
                    return object;
                var message = new $root.CS.DBObject();
                if (object.m_Qualifier != null)
                    message.m_Qualifier = String(object.m_Qualifier);
                if (object.m_Owner != null)
                    message.m_Owner = String(object.m_Owner);
                if (object.m_Name != null)
                    message.m_Name = String(object.m_Name);
                if (object.m_Type != null)
                    message.m_Type = String(object.m_Type);
                if (object.m_Description != null)
                    message.m_Description = String(object.m_Description);
                return message;
            };
    
            /**
             * Creates a plain object from a DBObject message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.DBObject
             * @static
             * @param {CS.DBObject} message DBObject
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DBObject.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Qualifier = "";
                    object.m_Owner = "";
                    object.m_Name = "";
                    object.m_Type = "";
                    object.m_Description = "";
                }
                if (message.m_Qualifier != null && message.hasOwnProperty("m_Qualifier"))
                    object.m_Qualifier = message.m_Qualifier;
                if (message.m_Owner != null && message.hasOwnProperty("m_Owner"))
                    object.m_Owner = message.m_Owner;
                if (message.m_Name != null && message.hasOwnProperty("m_Name"))
                    object.m_Name = message.m_Name;
                if (message.m_Type != null && message.hasOwnProperty("m_Type"))
                    object.m_Type = message.m_Type;
                if (message.m_Description != null && message.hasOwnProperty("m_Description"))
                    object.m_Description = message.m_Description;
                return object;
            };
    
            /**
             * Converts this DBObject to JSON.
             * @function toJSON
             * @memberof CS.DBObject
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DBObject.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DBObject;
        })();
    
        CS.Locale = (function() {
    
            /**
             * Properties of a Locale.
             * @memberof CS
             * @interface ILocale
             * @property {string|null} [m_Language] Locale m_Language
             * @property {string|null} [m_Country] Locale m_Country
             * @property {string|null} [m_CharSet] Locale m_CharSet
             */
    
            /**
             * Constructs a new Locale.
             * @memberof CS
             * @classdesc Represents a Locale.
             * @implements ILocale
             * @constructor
             * @param {CS.ILocale=} [properties] Properties to set
             */
            function Locale(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Locale m_Language.
             * @member {string} m_Language
             * @memberof CS.Locale
             * @instance
             */
            Locale.prototype.m_Language = "";
    
            /**
             * Locale m_Country.
             * @member {string} m_Country
             * @memberof CS.Locale
             * @instance
             */
            Locale.prototype.m_Country = "";
    
            /**
             * Locale m_CharSet.
             * @member {string} m_CharSet
             * @memberof CS.Locale
             * @instance
             */
            Locale.prototype.m_CharSet = "";
    
            /**
             * Creates a new Locale instance using the specified properties.
             * @function create
             * @memberof CS.Locale
             * @static
             * @param {CS.ILocale=} [properties] Properties to set
             * @returns {CS.Locale} Locale instance
             */
            Locale.create = function create(properties) {
                return new Locale(properties);
            };
    
            /**
             * Encodes the specified Locale message. Does not implicitly {@link CS.Locale.verify|verify} messages.
             * @function encode
             * @memberof CS.Locale
             * @static
             * @param {CS.ILocale} message Locale message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Locale.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Language != null && Object.hasOwnProperty.call(message, "m_Language"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Language);
                if (message.m_Country != null && Object.hasOwnProperty.call(message, "m_Country"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Country);
                if (message.m_CharSet != null && Object.hasOwnProperty.call(message, "m_CharSet"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.m_CharSet);
                return writer;
            };
    
            /**
             * Encodes the specified Locale message, length delimited. Does not implicitly {@link CS.Locale.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.Locale
             * @static
             * @param {CS.ILocale} message Locale message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Locale.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Locale message from the specified reader or buffer.
             * @function decode
             * @memberof CS.Locale
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.Locale} Locale
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Locale.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.Locale();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Language = reader.string();
                        break;
                    case 2:
                        message.m_Country = reader.string();
                        break;
                    case 3:
                        message.m_CharSet = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Locale message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.Locale
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.Locale} Locale
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Locale.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Locale message.
             * @function verify
             * @memberof CS.Locale
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Locale.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Language != null && message.hasOwnProperty("m_Language"))
                    if (!$util.isString(message.m_Language))
                        return "m_Language: string expected";
                if (message.m_Country != null && message.hasOwnProperty("m_Country"))
                    if (!$util.isString(message.m_Country))
                        return "m_Country: string expected";
                if (message.m_CharSet != null && message.hasOwnProperty("m_CharSet"))
                    if (!$util.isString(message.m_CharSet))
                        return "m_CharSet: string expected";
                return null;
            };
    
            /**
             * Creates a Locale message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.Locale
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.Locale} Locale
             */
            Locale.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.Locale)
                    return object;
                var message = new $root.CS.Locale();
                if (object.m_Language != null)
                    message.m_Language = String(object.m_Language);
                if (object.m_Country != null)
                    message.m_Country = String(object.m_Country);
                if (object.m_CharSet != null)
                    message.m_CharSet = String(object.m_CharSet);
                return message;
            };
    
            /**
             * Creates a plain object from a Locale message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.Locale
             * @static
             * @param {CS.Locale} message Locale
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Locale.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Language = "";
                    object.m_Country = "";
                    object.m_CharSet = "";
                }
                if (message.m_Language != null && message.hasOwnProperty("m_Language"))
                    object.m_Language = message.m_Language;
                if (message.m_Country != null && message.hasOwnProperty("m_Country"))
                    object.m_Country = message.m_Country;
                if (message.m_CharSet != null && message.hasOwnProperty("m_CharSet"))
                    object.m_CharSet = message.m_CharSet;
                return object;
            };
    
            /**
             * Converts this Locale to JSON.
             * @function toJSON
             * @memberof CS.Locale
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Locale.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Locale;
        })();
    
        CS.ConnectionProperty = (function() {
    
            /**
             * Properties of a ConnectionProperty.
             * @memberof CS
             * @interface IConnectionProperty
             * @property {string|null} [m_Key] ConnectionProperty m_Key
             * @property {string|null} [m_Value] ConnectionProperty m_Value
             */
    
            /**
             * Constructs a new ConnectionProperty.
             * @memberof CS
             * @classdesc Represents a ConnectionProperty.
             * @implements IConnectionProperty
             * @constructor
             * @param {CS.IConnectionProperty=} [properties] Properties to set
             */
            function ConnectionProperty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConnectionProperty m_Key.
             * @member {string} m_Key
             * @memberof CS.ConnectionProperty
             * @instance
             */
            ConnectionProperty.prototype.m_Key = "";
    
            /**
             * ConnectionProperty m_Value.
             * @member {string} m_Value
             * @memberof CS.ConnectionProperty
             * @instance
             */
            ConnectionProperty.prototype.m_Value = "";
    
            /**
             * Creates a new ConnectionProperty instance using the specified properties.
             * @function create
             * @memberof CS.ConnectionProperty
             * @static
             * @param {CS.IConnectionProperty=} [properties] Properties to set
             * @returns {CS.ConnectionProperty} ConnectionProperty instance
             */
            ConnectionProperty.create = function create(properties) {
                return new ConnectionProperty(properties);
            };
    
            /**
             * Encodes the specified ConnectionProperty message. Does not implicitly {@link CS.ConnectionProperty.verify|verify} messages.
             * @function encode
             * @memberof CS.ConnectionProperty
             * @static
             * @param {CS.IConnectionProperty} message ConnectionProperty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionProperty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_Key != null && Object.hasOwnProperty.call(message, "m_Key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_Key);
                if (message.m_Value != null && Object.hasOwnProperty.call(message, "m_Value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Value);
                return writer;
            };
    
            /**
             * Encodes the specified ConnectionProperty message, length delimited. Does not implicitly {@link CS.ConnectionProperty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.ConnectionProperty
             * @static
             * @param {CS.IConnectionProperty} message ConnectionProperty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionProperty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnectionProperty message from the specified reader or buffer.
             * @function decode
             * @memberof CS.ConnectionProperty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.ConnectionProperty} ConnectionProperty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionProperty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.ConnectionProperty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_Key = reader.string();
                        break;
                    case 2:
                        message.m_Value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnectionProperty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.ConnectionProperty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.ConnectionProperty} ConnectionProperty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionProperty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnectionProperty message.
             * @function verify
             * @memberof CS.ConnectionProperty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectionProperty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_Key != null && message.hasOwnProperty("m_Key"))
                    if (!$util.isString(message.m_Key))
                        return "m_Key: string expected";
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    if (!$util.isString(message.m_Value))
                        return "m_Value: string expected";
                return null;
            };
    
            /**
             * Creates a ConnectionProperty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.ConnectionProperty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.ConnectionProperty} ConnectionProperty
             */
            ConnectionProperty.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.ConnectionProperty)
                    return object;
                var message = new $root.CS.ConnectionProperty();
                if (object.m_Key != null)
                    message.m_Key = String(object.m_Key);
                if (object.m_Value != null)
                    message.m_Value = String(object.m_Value);
                return message;
            };
    
            /**
             * Creates a plain object from a ConnectionProperty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.ConnectionProperty
             * @static
             * @param {CS.ConnectionProperty} message ConnectionProperty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectionProperty.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_Key = "";
                    object.m_Value = "";
                }
                if (message.m_Key != null && message.hasOwnProperty("m_Key"))
                    object.m_Key = message.m_Key;
                if (message.m_Value != null && message.hasOwnProperty("m_Value"))
                    object.m_Value = message.m_Value;
                return object;
            };
    
            /**
             * Converts this ConnectionProperty to JSON.
             * @function toJSON
             * @memberof CS.ConnectionProperty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectionProperty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConnectionProperty;
        })();
    
        CS.SubstituteValue = (function() {
    
            /**
             * Properties of a SubstituteValue.
             * @memberof CS
             * @interface ISubstituteValue
             * @property {string|null} [m_CurrentValue] SubstituteValue m_CurrentValue
             * @property {string|null} [m_NewValue] SubstituteValue m_NewValue
             */
    
            /**
             * Constructs a new SubstituteValue.
             * @memberof CS
             * @classdesc Represents a SubstituteValue.
             * @implements ISubstituteValue
             * @constructor
             * @param {CS.ISubstituteValue=} [properties] Properties to set
             */
            function SubstituteValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SubstituteValue m_CurrentValue.
             * @member {string} m_CurrentValue
             * @memberof CS.SubstituteValue
             * @instance
             */
            SubstituteValue.prototype.m_CurrentValue = "";
    
            /**
             * SubstituteValue m_NewValue.
             * @member {string} m_NewValue
             * @memberof CS.SubstituteValue
             * @instance
             */
            SubstituteValue.prototype.m_NewValue = "";
    
            /**
             * Creates a new SubstituteValue instance using the specified properties.
             * @function create
             * @memberof CS.SubstituteValue
             * @static
             * @param {CS.ISubstituteValue=} [properties] Properties to set
             * @returns {CS.SubstituteValue} SubstituteValue instance
             */
            SubstituteValue.create = function create(properties) {
                return new SubstituteValue(properties);
            };
    
            /**
             * Encodes the specified SubstituteValue message. Does not implicitly {@link CS.SubstituteValue.verify|verify} messages.
             * @function encode
             * @memberof CS.SubstituteValue
             * @static
             * @param {CS.ISubstituteValue} message SubstituteValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubstituteValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_CurrentValue != null && Object.hasOwnProperty.call(message, "m_CurrentValue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.m_CurrentValue);
                if (message.m_NewValue != null && Object.hasOwnProperty.call(message, "m_NewValue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_NewValue);
                return writer;
            };
    
            /**
             * Encodes the specified SubstituteValue message, length delimited. Does not implicitly {@link CS.SubstituteValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.SubstituteValue
             * @static
             * @param {CS.ISubstituteValue} message SubstituteValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubstituteValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SubstituteValue message from the specified reader or buffer.
             * @function decode
             * @memberof CS.SubstituteValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.SubstituteValue} SubstituteValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubstituteValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.SubstituteValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_CurrentValue = reader.string();
                        break;
                    case 2:
                        message.m_NewValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SubstituteValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.SubstituteValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.SubstituteValue} SubstituteValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubstituteValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SubstituteValue message.
             * @function verify
             * @memberof CS.SubstituteValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubstituteValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_CurrentValue != null && message.hasOwnProperty("m_CurrentValue"))
                    if (!$util.isString(message.m_CurrentValue))
                        return "m_CurrentValue: string expected";
                if (message.m_NewValue != null && message.hasOwnProperty("m_NewValue"))
                    if (!$util.isString(message.m_NewValue))
                        return "m_NewValue: string expected";
                return null;
            };
    
            /**
             * Creates a SubstituteValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.SubstituteValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.SubstituteValue} SubstituteValue
             */
            SubstituteValue.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.SubstituteValue)
                    return object;
                var message = new $root.CS.SubstituteValue();
                if (object.m_CurrentValue != null)
                    message.m_CurrentValue = String(object.m_CurrentValue);
                if (object.m_NewValue != null)
                    message.m_NewValue = String(object.m_NewValue);
                return message;
            };
    
            /**
             * Creates a plain object from a SubstituteValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.SubstituteValue
             * @static
             * @param {CS.SubstituteValue} message SubstituteValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubstituteValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_CurrentValue = "";
                    object.m_NewValue = "";
                }
                if (message.m_CurrentValue != null && message.hasOwnProperty("m_CurrentValue"))
                    object.m_CurrentValue = message.m_CurrentValue;
                if (message.m_NewValue != null && message.hasOwnProperty("m_NewValue"))
                    object.m_NewValue = message.m_NewValue;
                return object;
            };
    
            /**
             * Converts this SubstituteValue to JSON.
             * @function toJSON
             * @memberof CS.SubstituteValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubstituteValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SubstituteValue;
        })();
    
        /**
         * LobType enum.
         * @name CS.LobType
         * @enum {number}
         * @property {number} Unknown_LobType=0 Unknown_LobType value
         * @property {number} BLOB=1 BLOB value
         * @property {number} CLOB=2 CLOB value
         */
        CS.LobType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknown_LobType"] = 0;
            values[valuesById[1] = "BLOB"] = 1;
            values[valuesById[2] = "CLOB"] = 2;
            return values;
        })();
    
        CS.LobDescriptor = (function() {
    
            /**
             * Properties of a LobDescriptor.
             * @memberof CS
             * @interface ILobDescriptor
             * @property {CS.LobType|null} [m_LobType] LobDescriptor m_LobType
             * @property {string|null} [m_Description] LobDescriptor m_Description
             * @property {number|Long|null} [m_Length] LobDescriptor m_Length
             * @property {number|null} [m_ChunkSize] LobDescriptor m_ChunkSize
             */
    
            /**
             * Constructs a new LobDescriptor.
             * @memberof CS
             * @classdesc Represents a LobDescriptor.
             * @implements ILobDescriptor
             * @constructor
             * @param {CS.ILobDescriptor=} [properties] Properties to set
             */
            function LobDescriptor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LobDescriptor m_LobType.
             * @member {CS.LobType} m_LobType
             * @memberof CS.LobDescriptor
             * @instance
             */
            LobDescriptor.prototype.m_LobType = 0;
    
            /**
             * LobDescriptor m_Description.
             * @member {string} m_Description
             * @memberof CS.LobDescriptor
             * @instance
             */
            LobDescriptor.prototype.m_Description = "";
    
            /**
             * LobDescriptor m_Length.
             * @member {number|Long} m_Length
             * @memberof CS.LobDescriptor
             * @instance
             */
            LobDescriptor.prototype.m_Length = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * LobDescriptor m_ChunkSize.
             * @member {number} m_ChunkSize
             * @memberof CS.LobDescriptor
             * @instance
             */
            LobDescriptor.prototype.m_ChunkSize = 0;
    
            /**
             * Creates a new LobDescriptor instance using the specified properties.
             * @function create
             * @memberof CS.LobDescriptor
             * @static
             * @param {CS.ILobDescriptor=} [properties] Properties to set
             * @returns {CS.LobDescriptor} LobDescriptor instance
             */
            LobDescriptor.create = function create(properties) {
                return new LobDescriptor(properties);
            };
    
            /**
             * Encodes the specified LobDescriptor message. Does not implicitly {@link CS.LobDescriptor.verify|verify} messages.
             * @function encode
             * @memberof CS.LobDescriptor
             * @static
             * @param {CS.ILobDescriptor} message LobDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LobDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m_LobType != null && Object.hasOwnProperty.call(message, "m_LobType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.m_LobType);
                if (message.m_Description != null && Object.hasOwnProperty.call(message, "m_Description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.m_Description);
                if (message.m_Length != null && Object.hasOwnProperty.call(message, "m_Length"))
                    writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.m_Length);
                if (message.m_ChunkSize != null && Object.hasOwnProperty.call(message, "m_ChunkSize"))
                    writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.m_ChunkSize);
                return writer;
            };
    
            /**
             * Encodes the specified LobDescriptor message, length delimited. Does not implicitly {@link CS.LobDescriptor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.LobDescriptor
             * @static
             * @param {CS.ILobDescriptor} message LobDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LobDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LobDescriptor message from the specified reader or buffer.
             * @function decode
             * @memberof CS.LobDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.LobDescriptor} LobDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LobDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.LobDescriptor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.m_LobType = reader.int32();
                        break;
                    case 2:
                        message.m_Description = reader.string();
                        break;
                    case 3:
                        message.m_Length = reader.sint64();
                        break;
                    case 4:
                        message.m_ChunkSize = reader.sint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LobDescriptor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.LobDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.LobDescriptor} LobDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LobDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LobDescriptor message.
             * @function verify
             * @memberof CS.LobDescriptor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LobDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m_LobType != null && message.hasOwnProperty("m_LobType"))
                    switch (message.m_LobType) {
                    default:
                        return "m_LobType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.m_Description != null && message.hasOwnProperty("m_Description"))
                    if (!$util.isString(message.m_Description))
                        return "m_Description: string expected";
                if (message.m_Length != null && message.hasOwnProperty("m_Length"))
                    if (!$util.isInteger(message.m_Length) && !(message.m_Length && $util.isInteger(message.m_Length.low) && $util.isInteger(message.m_Length.high)))
                        return "m_Length: integer|Long expected";
                if (message.m_ChunkSize != null && message.hasOwnProperty("m_ChunkSize"))
                    if (!$util.isInteger(message.m_ChunkSize))
                        return "m_ChunkSize: integer expected";
                return null;
            };
    
            /**
             * Creates a LobDescriptor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.LobDescriptor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.LobDescriptor} LobDescriptor
             */
            LobDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.LobDescriptor)
                    return object;
                var message = new $root.CS.LobDescriptor();
                switch (object.m_LobType) {
                case "Unknown_LobType":
                case 0:
                    message.m_LobType = 0;
                    break;
                case "BLOB":
                case 1:
                    message.m_LobType = 1;
                    break;
                case "CLOB":
                case 2:
                    message.m_LobType = 2;
                    break;
                }
                if (object.m_Description != null)
                    message.m_Description = String(object.m_Description);
                if (object.m_Length != null)
                    if ($util.Long)
                        (message.m_Length = $util.Long.fromValue(object.m_Length)).unsigned = false;
                    else if (typeof object.m_Length === "string")
                        message.m_Length = parseInt(object.m_Length, 10);
                    else if (typeof object.m_Length === "number")
                        message.m_Length = object.m_Length;
                    else if (typeof object.m_Length === "object")
                        message.m_Length = new $util.LongBits(object.m_Length.low >>> 0, object.m_Length.high >>> 0).toNumber();
                if (object.m_ChunkSize != null)
                    message.m_ChunkSize = object.m_ChunkSize | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a LobDescriptor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.LobDescriptor
             * @static
             * @param {CS.LobDescriptor} message LobDescriptor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LobDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m_LobType = options.enums === String ? "Unknown_LobType" : 0;
                    object.m_Description = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.m_Length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.m_Length = options.longs === String ? "0" : 0;
                    object.m_ChunkSize = 0;
                }
                if (message.m_LobType != null && message.hasOwnProperty("m_LobType"))
                    object.m_LobType = options.enums === String ? $root.CS.LobType[message.m_LobType] : message.m_LobType;
                if (message.m_Description != null && message.hasOwnProperty("m_Description"))
                    object.m_Description = message.m_Description;
                if (message.m_Length != null && message.hasOwnProperty("m_Length"))
                    if (typeof message.m_Length === "number")
                        object.m_Length = options.longs === String ? String(message.m_Length) : message.m_Length;
                    else
                        object.m_Length = options.longs === String ? $util.Long.prototype.toString.call(message.m_Length) : options.longs === Number ? new $util.LongBits(message.m_Length.low >>> 0, message.m_Length.high >>> 0).toNumber() : message.m_Length;
                if (message.m_ChunkSize != null && message.hasOwnProperty("m_ChunkSize"))
                    object.m_ChunkSize = message.m_ChunkSize;
                return object;
            };
    
            /**
             * Converts this LobDescriptor to JSON.
             * @function toJSON
             * @memberof CS.LobDescriptor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LobDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LobDescriptor;
        })();
    
        CS.KeyValueProperty = (function() {
    
            /**
             * Properties of a KeyValueProperty.
             * @memberof CS
             * @interface IKeyValueProperty
             * @property {string|null} [key] KeyValueProperty key
             * @property {string|null} [value] KeyValueProperty value
             */
    
            /**
             * Constructs a new KeyValueProperty.
             * @memberof CS
             * @classdesc Represents a KeyValueProperty.
             * @implements IKeyValueProperty
             * @constructor
             * @param {CS.IKeyValueProperty=} [properties] Properties to set
             */
            function KeyValueProperty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KeyValueProperty key.
             * @member {string} key
             * @memberof CS.KeyValueProperty
             * @instance
             */
            KeyValueProperty.prototype.key = "";
    
            /**
             * KeyValueProperty value.
             * @member {string} value
             * @memberof CS.KeyValueProperty
             * @instance
             */
            KeyValueProperty.prototype.value = "";
    
            /**
             * Creates a new KeyValueProperty instance using the specified properties.
             * @function create
             * @memberof CS.KeyValueProperty
             * @static
             * @param {CS.IKeyValueProperty=} [properties] Properties to set
             * @returns {CS.KeyValueProperty} KeyValueProperty instance
             */
            KeyValueProperty.create = function create(properties) {
                return new KeyValueProperty(properties);
            };
    
            /**
             * Encodes the specified KeyValueProperty message. Does not implicitly {@link CS.KeyValueProperty.verify|verify} messages.
             * @function encode
             * @memberof CS.KeyValueProperty
             * @static
             * @param {CS.IKeyValueProperty} message KeyValueProperty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyValueProperty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KeyValueProperty message, length delimited. Does not implicitly {@link CS.KeyValueProperty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CS.KeyValueProperty
             * @static
             * @param {CS.IKeyValueProperty} message KeyValueProperty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyValueProperty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KeyValueProperty message from the specified reader or buffer.
             * @function decode
             * @memberof CS.KeyValueProperty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CS.KeyValueProperty} KeyValueProperty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyValueProperty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CS.KeyValueProperty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KeyValueProperty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CS.KeyValueProperty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CS.KeyValueProperty} KeyValueProperty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyValueProperty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KeyValueProperty message.
             * @function verify
             * @memberof CS.KeyValueProperty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyValueProperty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a KeyValueProperty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CS.KeyValueProperty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CS.KeyValueProperty} KeyValueProperty
             */
            KeyValueProperty.fromObject = function fromObject(object) {
                if (object instanceof $root.CS.KeyValueProperty)
                    return object;
                var message = new $root.CS.KeyValueProperty();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a KeyValueProperty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CS.KeyValueProperty
             * @static
             * @param {CS.KeyValueProperty} message KeyValueProperty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyValueProperty.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this KeyValueProperty to JSON.
             * @function toJSON
             * @memberof CS.KeyValueProperty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyValueProperty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KeyValueProperty;
        })();
    
        return CS;
    })();

    return $root;
});
